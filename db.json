{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/png/netty/channelPipeline.jpg","path":"png/netty/channelPipeline.jpg","modified":0,"renderable":0},{"_id":"source/png/netty/channel&eventLoop.jpg","path":"png/netty/channel&eventLoop.jpg","modified":0,"renderable":0},{"_id":"source/png/netty/ByteBuffer.png","path":"png/netty/ByteBuffer.png","modified":0,"renderable":0},{"_id":"source/png/netty/reactor模式.png","path":"png/netty/reactor模式.png","modified":0,"renderable":0},{"_id":"source/png/netty/netty.png","path":"png/netty/netty.png","modified":0,"renderable":0},{"_id":"source/png/netty/主从模式reactor多线程模型.jpg","path":"png/netty/主从模式reactor多线程模型.jpg","modified":0,"renderable":0},{"_id":"source/png/netty/多线程reactor模型.jpg","path":"png/netty/多线程reactor模型.jpg","modified":0,"renderable":0},{"_id":"source/png/netty/单线程reactor模型.jpg","path":"png/netty/单线程reactor模型.jpg","modified":0,"renderable":0},{"_id":"source/png/netty/discardReadBytes.png","path":"png/netty/discardReadBytes.png","modified":0,"renderable":0},{"_id":"source/png/netty/clear后的Buffer.png","path":"png/netty/clear后的Buffer.png","modified":0,"renderable":0},{"_id":"source/png/netty/流-粘包.png","path":"png/netty/流-粘包.png","modified":0,"renderable":0},{"_id":"source/png/netty/流-拆包.png","path":"png/netty/流-拆包.png","modified":0,"renderable":0},{"_id":"source/png/netty/读写中间状态的Buffer.png","path":"png/netty/读写中间状态的Buffer.png","modified":0,"renderable":0},{"_id":"themes/next/source/images/apple-touch-icon-next.png","path":"images/apple-touch-icon-next.png","modified":0,"renderable":1},{"_id":"themes/next/source/css/main.styl","path":"css/main.styl","modified":0,"renderable":1},{"_id":"themes/next/source/images/avatar.gif","path":"images/avatar.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/algolia_logo.svg","path":"images/algolia_logo.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","path":"images/cc-by-nc-nd.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","path":"images/cc-by-nc-sa.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc.svg","path":"images/cc-by-nc.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-sa.svg","path":"images/cc-by-sa.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nd.svg","path":"images/cc-by-nd.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/favicon-16x16-next.png","path":"images/favicon-16x16-next.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/favicon-32x32-next.png","path":"images/favicon-32x32-next.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/loading.gif","path":"images/loading.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/placeholder.gif","path":"images/placeholder.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-zero.svg","path":"images/cc-zero.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by.svg","path":"images/cc-by.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/searchicon.png","path":"images/searchicon.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/logo.svg","path":"images/logo.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/quote-l.svg","path":"images/quote-l.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/quote-r.svg","path":"images/quote-r.svg","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/bootstrap.js","path":"js/src/bootstrap.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/algolia-search.js","path":"js/src/algolia-search.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/affix.js","path":"js/src/affix.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/exturl.js","path":"js/src/exturl.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/motion.js","path":"js/src/motion.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/js.cookie.js","path":"js/src/js.cookie.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/hook-duoshuo.js","path":"js/src/hook-duoshuo.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/post-details.js","path":"js/src/post-details.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/scroll-cookie.js","path":"js/src/scroll-cookie.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/scrollspy.js","path":"js/src/scrollspy.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/utils.js","path":"js/src/utils.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.css","path":"lib/algolia-instant-search/instantsearch.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/canvas-nest/canvas-nest.min.js","path":"lib/canvas-nest/canvas-nest.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/LICENSE","path":"lib/fastclick/LICENSE","modified":0,"renderable":1},{"_id":"themes/next/source/lib/canvas-ribbon/canvas-ribbon.js","path":"lib/canvas-ribbon/canvas-ribbon.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/bower.json","path":"lib/fastclick/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/README.md","path":"lib/fastclick/README.md","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/bower.json","path":"lib/font-awesome/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/HELP-US-OUT.txt","path":"lib/font-awesome/HELP-US-OUT.txt","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/README.md","path":"lib/jquery_lazyload/README.md","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/bower.json","path":"lib/jquery_lazyload/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/CONTRIBUTING.md","path":"lib/jquery_lazyload/CONTRIBUTING.md","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.lazyload.js","path":"lib/jquery_lazyload/jquery.lazyload.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/needsharebutton/needsharebutton.css","path":"lib/needsharebutton/needsharebutton.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.scrollstop.js","path":"lib/jquery_lazyload/jquery.scrollstop.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/needsharebutton/needsharebutton.js","path":"lib/needsharebutton/needsharebutton.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-barber-shop.min.css","path":"lib/pace/pace-theme-barber-shop.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-big-counter.min.css","path":"lib/pace/pace-theme-big-counter.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-atom.min.css","path":"lib/pace/pace-theme-center-atom.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/needsharebutton/font-embedded.css","path":"lib/needsharebutton/font-embedded.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-bounce.min.css","path":"lib/pace/pace-theme-bounce.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-circle.min.css","path":"lib/pace/pace-theme-center-circle.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-simple.min.css","path":"lib/pace/pace-theme-center-simple.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-radar.min.css","path":"lib/pace/pace-theme-center-radar.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-fill-left.min.css","path":"lib/pace/pace-theme-fill-left.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-corner-indicator.min.css","path":"lib/pace/pace-theme-corner-indicator.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-flash.min.css","path":"lib/pace/pace-theme-flash.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-loading-bar.min.css","path":"lib/pace/pace-theme-loading-bar.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-mac-osx.min.css","path":"lib/pace/pace-theme-mac-osx.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-minimal.min.css","path":"lib/pace/pace-theme-minimal.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/three/canvas_sphere.min.js","path":"lib/three/canvas_sphere.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace.min.js","path":"lib/pace/pace.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/three/three-waves.min.js","path":"lib/three/three-waves.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/bower.json","path":"lib/velocity/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/lib/three/canvas_lines.min.js","path":"lib/three/canvas_lines.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.js","path":"lib/velocity/velocity.ui.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.min.js","path":"lib/velocity/velocity.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","path":"lib/velocity/velocity.ui.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery/index.js","path":"lib/jquery/index.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.css","path":"lib/Han/dist/han.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.min.css","path":"lib/Han/dist/han.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/blank.gif","path":"lib/fancybox/source/blank.gif","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading.gif","path":"lib/fancybox/source/fancybox_loading.gif","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading@2x.gif","path":"lib/fancybox/source/fancybox_loading@2x.gif","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_overlay.png","path":"lib/fancybox/source/fancybox_overlay.png","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite.png","path":"lib/fancybox/source/fancybox_sprite.png","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite@2x.png","path":"lib/fancybox/source/fancybox_sprite@2x.png","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.css","path":"lib/fancybox/source/jquery.fancybox.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.min.js","path":"lib/Han/dist/han.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.js","path":"lib/fancybox/source/jquery.fancybox.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.js","path":"lib/fastclick/lib/fastclick.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css.map","path":"lib/font-awesome/css/font-awesome.css.map","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.min.js","path":"lib/fastclick/lib/fastclick.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css","path":"lib/font-awesome/css/font-awesome.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.pack.js","path":"lib/fancybox/source/jquery.fancybox.pack.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.min.css","path":"lib/font-awesome/css/font-awesome.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.min.js","path":"lib/ua-parser-js/dist/ua-parser.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.pack.js","path":"lib/ua-parser-js/dist/ua-parser.pack.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/schemes/pisces.js","path":"js/src/schemes/pisces.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.js","path":"lib/Han/dist/han.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","path":"lib/font-awesome/fonts/fontawesome-webfont.woff2","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","path":"lib/font-awesome/fonts/fontawesome-webfont.woff","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.js","path":"lib/velocity/velocity.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han-space.otf","path":"lib/Han/dist/font/han-space.otf","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han-space.woff","path":"lib/Han/dist/font/han-space.woff","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han.woff","path":"lib/Han/dist/font/han.woff","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han.otf","path":"lib/Han/dist/font/han.otf","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/fancybox_buttons.png","path":"lib/fancybox/source/helpers/fancybox_buttons.png","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han.woff2","path":"lib/Han/dist/font/han.woff2","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","path":"lib/fancybox/source/helpers/jquery.fancybox-buttons.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","path":"lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.ttf","path":"lib/font-awesome/fonts/fontawesome-webfont.ttf","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/FontAwesome.otf","path":"lib/font-awesome/fonts/FontAwesome.otf","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","path":"lib/fancybox/source/helpers/jquery.fancybox-buttons.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-media.js","path":"lib/fancybox/source/helpers/jquery.fancybox-media.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","path":"lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","path":"lib/font-awesome/fonts/fontawesome-webfont.eot","modified":0,"renderable":1},{"_id":"source/png/netty/netty线程模型.png","path":"png/netty/netty线程模型.png","modified":0,"renderable":0},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.js","path":"lib/algolia-instant-search/instantsearch.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.svg","path":"lib/font-awesome/fonts/fontawesome-webfont.svg","modified":0,"renderable":1},{"_id":"themes/next/source/lib/three/three.min.js","path":"lib/three/three.min.js","modified":0,"renderable":1}],"Cache":[{"_id":"themes/next/.gitattributes","hash":"8454b9313cb1a97b63fb87e2d29daee497ce6249","modified":1567532730736},{"_id":"themes/next/.editorconfig","hash":"211d2c92bfdddb3e81ea946f4ca7a539f150f4da","modified":1567532730736},{"_id":"themes/next/.gitignore","hash":"ee0b13c268cc8695d3883a5da84930af02d4ed08","modified":1567532730738},{"_id":"themes/next/.javascript_ignore","hash":"cd250ad74ca22bd2c054476456a73d9687f05f87","modified":1567532730743},{"_id":"themes/next/.bowerrc","hash":"334da94ca6f024d60d012cc26ea655681e724ad8","modified":1567532730735},{"_id":"themes/next/.jshintrc","hash":"b7d23f2ce8d99fa073f22f9960605f318acd7710","modified":1567532730745},{"_id":"themes/next/.hound.yml","hash":"289dcf5bfe92dbd680d54d6e0668f41c9c9c0c78","modified":1567532730742},{"_id":"themes/next/.stylintrc","hash":"3b7f9785e9ad0dab764e1c535b40df02f4ff5fd6","modified":1567532730746},{"_id":"themes/next/.travis.yml","hash":"6674fbdfe0d0c03b8a04527ffb8ab66a94253acd","modified":1567532730747},{"_id":"themes/next/_config.yml","hash":"3e33b548ee3bd76cbac5e45c066f19e19ecd8a6e","modified":1567702930060},{"_id":"themes/next/README.cn.md","hash":"b878b73f3fcdef47849453c94420871903d487b3","modified":1567532730750},{"_id":"themes/next/LICENSE","hash":"ec44503d7e617144909e54533754f0147845f0c5","modified":1567532730748},{"_id":"themes/next/README.md","hash":"efcdc4b0ca791c3fc64afa28c8721e137f2d11ea","modified":1567532730751},{"_id":"themes/next/bower.json","hash":"486ebd72068848c97def75f36b71cbec9bb359c5","modified":1567532730753},{"_id":"themes/next/package.json","hash":"3963ad558a24c78a3fd4ef23cf5f73f421854627","modified":1567532730786},{"_id":"themes/next/gulpfile.coffee","hash":"412defab3d93d404b7c26aaa0279e2e586e97454","modified":1567532730753},{"_id":"source/_posts/Netty浅析.md","hash":"ee5c016077c51d554c734adf71e6a622e928cf82","modified":1568134142875},{"_id":"themes/next/.git/HEAD","hash":"acbaef275e46a7f14c1ef456fff2c8bbe8c84724","modified":1567532730713},{"_id":"source/categories/index.md","hash":"d72dac0d45e98018b47ff1fb32bdd146d7d684b8","modified":1567703142794},{"_id":"source/tags/index.md","hash":"a583d497e34adf9ed4eca55254a02fb29b55b68a","modified":1567703938082},{"_id":"source/_posts/DirectBuffer垃圾回收.md","hash":"630be8acc0c543b6cf2f8965aa469ea4e657ae35","modified":1568134174756},{"_id":"themes/next/.git/description","hash":"9635f1b7e12c045212819dd934d809ef07efa2f4","modified":1567532714641},{"_id":"themes/next/.git/config","hash":"8e94cc015a498d35202e9fd57e44b3c51e1e5634","modified":1567532730721},{"_id":"themes/next/.git/index","hash":"d68d294f8de91360d295c5972b17a5b8f0de32ed","modified":1567532767959},{"_id":"themes/next/.github/browserstack_logo.png","hash":"a6c43887f64a7f48a2814e3714eaa1215e542037","modified":1567532730738},{"_id":"themes/next/.git/packed-refs","hash":"ae421c3c59b504716340fe85ae852ebd4aed1b8d","modified":1567532730707},{"_id":"themes/next/.github/CONTRIBUTING.md","hash":"5adfad3ef1b870063e621bc0838268eb2c7c697a","modified":1567532730736},{"_id":"themes/next/.github/ISSUE_TEMPLATE.md","hash":"a0a82dbfabdef9a9d7c17a08ceebfb4052d98d81","modified":1567532730737},{"_id":"themes/next/languages/de.yml","hash":"fd02d9c2035798d5dc7c1a96b4c3e24b05b31a47","modified":1567532730754},{"_id":"themes/next/.github/PULL_REQUEST_TEMPLATE.md","hash":"1228506a940114288d61812bfe60c045a0abeac1","modified":1567532730737},{"_id":"themes/next/languages/en.yml","hash":"2f4b4776ca1a08cc266a19afb0d1350a3926f42c","modified":1567532730755},{"_id":"themes/next/languages/default.yml","hash":"b3bcd8934327448a43d9bfada5dd11b1b8c1402e","modified":1567532730755},{"_id":"themes/next/languages/it.yml","hash":"a215d016146b1bd92cef046042081cbe0c7f976f","modified":1567532730757},{"_id":"themes/next/languages/fr-FR.yml","hash":"efeeb55d5c4add54ad59a612fc0630ee1300388c","modified":1567532730756},{"_id":"themes/next/languages/id.yml","hash":"dccae33e2a5b3c9f11c0e05ec4a7201af1b25745","modified":1567532730757},{"_id":"themes/next/languages/ko.yml","hash":"dc8f3e8c64eb7c4bb2385025b3006b8efec8b31d","modified":1567532730758},{"_id":"themes/next/languages/pt-BR.yml","hash":"568d494a1f37726a5375b11452a45c71c3e2852d","modified":1567532730759},{"_id":"themes/next/languages/ja.yml","hash":"37f954e47a3bc669620ca559e3edb3b0072a4be5","modified":1567532730758},{"_id":"themes/next/languages/nl-NL.yml","hash":"213e7a002b82fb265f69dabafbbc382cfd460030","modified":1567532730759},{"_id":"themes/next/languages/pt.yml","hash":"2efcd240c66ab1a122f061505ca0fb1e8819877b","modified":1567532730760},{"_id":"themes/next/languages/zh-Hans.yml","hash":"66b9b42f143c3cb2f782a94abd4c4cbd5fd7f55f","modified":1567532730761},{"_id":"themes/next/languages/ru.yml","hash":"e33ee44e80f82e329900fc41eb0bb6823397a4d6","modified":1567532730760},{"_id":"themes/next/languages/zh-hk.yml","hash":"fe0d45807d015082049f05b54714988c244888da","modified":1567532730762},{"_id":"themes/next/languages/vi.yml","hash":"a9b89ebd3e5933033d1386c7c56b66c44aca299a","modified":1567532730761},{"_id":"themes/next/languages/zh-tw.yml","hash":"432463b481e105073accda16c3e590e54c8e7b74","modified":1567532730762},{"_id":"themes/next/layout/_layout.swig","hash":"2164570bb05db11ee4bcfbbb5d183a759afe9d07","modified":1567532730763},{"_id":"themes/next/layout/archive.swig","hash":"9a2c14874a75c7085d2bada5e39201d3fc4fd2b4","modified":1567532730785},{"_id":"themes/next/layout/index.swig","hash":"555a357ecf17128db4e29346c92bb6298e66547a","modified":1567532730785},{"_id":"themes/next/layout/category.swig","hash":"3cbb3f72429647411f9e85f2544bdf0e3ad2e6b2","modified":1567532730785},{"_id":"themes/next/layout/page.swig","hash":"e8fcaa641d46930237675d2ad4b56964d9e262e9","modified":1567532730785},{"_id":"themes/next/scripts/merge-configs.js","hash":"38d86aab4fc12fb741ae52099be475196b9db972","modified":1567532730787},{"_id":"themes/next/scripts/merge.js","hash":"39b84b937b2a9608b94e5872349a47200e1800ff","modified":1567532730787},{"_id":"themes/next/layout/schedule.swig","hash":"87ad6055df01fa2e63e51887d34a2d8f0fbd2f5a","modified":1567532730786},{"_id":"themes/next/layout/tag.swig","hash":"34e1c016cbdf94a31f9c5d494854ff46b2a182e9","modified":1567532730786},{"_id":"themes/next/layout/post.swig","hash":"7a6ce102ca82c3a80f776e555dddae1a9981e1ed","modified":1567532730786},{"_id":"themes/next/test/.jshintrc","hash":"c9fca43ae0d99718e45a6f5ce736a18ba5fc8fb6","modified":1567532730886},{"_id":"themes/next/test/intern.js","hash":"db90b1063356727d72be0d77054fdc32fa882a66","modified":1567532730887},{"_id":"source/png/netty/channelPipeline.jpg","hash":"9da7a12635677014babd7c67effced6b7315dbb2","modified":1567698397190},{"_id":"source/png/netty/channel&eventLoop.jpg","hash":"fe45f794698f2a887463c5c79032a8ec85b302b7","modified":1567698349795},{"_id":"themes/next/test/helpers.js","hash":"f25e7f3265eb5a6e1ccbb5e5012fa9bebf134105","modified":1567532730886},{"_id":"source/png/netty/ByteBuffer.png","hash":"68dec4a916987e5d0f042a1bd149a1afae81a272","modified":1567698452846},{"_id":"themes/next/source/fonts/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1567532730822},{"_id":"source/png/netty/reactor模式.png","hash":"b3296b5a0ac09337dc5c264ec60b189353d4b3fb","modified":1567697752228},{"_id":"source/png/netty/netty.png","hash":"ad6b3b294ac4485dc6c72ae4755fa73fb8b3516b","modified":1567697659986},{"_id":"source/png/netty/主从模式reactor多线程模型.jpg","hash":"901c589ad67aa3dcd36f2058f57ec808251ce16a","modified":1567698003329},{"_id":"source/png/netty/多线程reactor模型.jpg","hash":"f5012c8d928989860a1ff734dfa96d50e067bd6c","modified":1567697948149},{"_id":"source/png/netty/单线程reactor模型.jpg","hash":"ca05fb6343b8f587aa20ba4c1e8677efe01816c1","modified":1567697913264},{"_id":"source/png/netty/discardReadBytes.png","hash":"b59b5db33799ea479b2f373e3c84f7b7136941c3","modified":1567698539266},{"_id":"source/png/netty/clear后的Buffer.png","hash":"5c1d2f643f5cd158bbf50f468a6e817b421a3581","modified":1567698576711},{"_id":"source/png/netty/流-粘包.png","hash":"cbf461b16f7e4d8be2104abebf81c8c4ef8e95df","modified":1567698658142},{"_id":"source/png/netty/流-拆包.png","hash":"6074251aed7623f2f074a403559229a21aea83a7","modified":1567698630734},{"_id":"themes/next/.git/hooks/applypatch-msg.sample","hash":"4de88eb95a5e93fd27e78b5fb3b5231a8d8917dd","modified":1567532714641},{"_id":"themes/next/.git/hooks/pre-applypatch.sample","hash":"f208287c1a92525de9f5462e905a9d31de1e2d75","modified":1567532714641},{"_id":"themes/next/.git/hooks/pre-commit.sample","hash":"36aed8976dcc08b5076844f0ec645b18bc37758f","modified":1567532714641},{"_id":"themes/next/.git/hooks/pre-push.sample","hash":"5c8518bfd1d1d3d2c1a7194994c0a16d8a313a41","modified":1567532714641},{"_id":"source/png/netty/读写中间状态的Buffer.png","hash":"3a34f013db392abf98d2411d693854dd4501937b","modified":1567698492356},{"_id":"themes/next/.git/hooks/post-update.sample","hash":"b614c2f63da7dca9f1db2e7ade61ef30448fc96c","modified":1567532714641},{"_id":"themes/next/.git/hooks/commit-msg.sample","hash":"ee1ed5aad98a435f2020b6de35c173b75d9affac","modified":1567532714641},{"_id":"themes/next/.git/hooks/prepare-commit-msg.sample","hash":"2b6275eda365cad50d167fe3a387c9bc9fedd54f","modified":1567532714641},{"_id":"themes/next/.git/hooks/pre-rebase.sample","hash":"5885a56ab4fca8075a05a562d005e922cde9853b","modified":1567532714641},{"_id":"themes/next/.git/hooks/pre-receive.sample","hash":"705a17d259e7896f0082fe2e9f2c0c3b127be5ac","modified":1567532714641},{"_id":"themes/next/.git/hooks/update.sample","hash":"e729cd61b27c128951d139de8e7c63d1a3758dde","modified":1567532714656},{"_id":"themes/next/.git/info/exclude","hash":"c879df015d97615050afa7b9641e3352a1e701ac","modified":1567532714656},{"_id":"themes/next/layout/_macro/post-collapse.swig","hash":"8c56dd26157cbc580ae41d97ac34b90ab48ced3f","modified":1567532730763},{"_id":"themes/next/.git/logs/HEAD","hash":"7c30010e0c4c678c4e6991c91f13581210eb4eb5","modified":1567532730715},{"_id":"themes/next/layout/_macro/post-copyright.swig","hash":"f83befdc740beb8dc88805efd7fbb0fef9ed19be","modified":1567532730764},{"_id":"themes/next/layout/_macro/sidebar.swig","hash":"9c7343fd470e0943ebd75f227a083a980816290b","modified":1567532730765},{"_id":"themes/next/layout/_macro/reward.swig","hash":"357d86ec9586705bfbb2c40a8c7d247a407db21a","modified":1567532730764},{"_id":"themes/next/layout/_custom/header.swig","hash":"ba8ab5a0280b953aa97435ff8946cbcbb2755a27","modified":1567532730762},{"_id":"themes/next/layout/_custom/sidebar.swig","hash":"ba8ab5a0280b953aa97435ff8946cbcbb2755a27","modified":1567532730763},{"_id":"themes/next/layout/_macro/wechat-subscriber.swig","hash":"e2e4eae391476da994045ed4c7faf5e05aca2cd7","modified":1567532730765},{"_id":"themes/next/layout/_partials/footer.swig","hash":"26e93336dc57a39590ba8dc80564a1d2ad5ff93b","modified":1567532730766},{"_id":"themes/next/layout/_macro/post.swig","hash":"4ba938822d56c597490f0731893eaa2443942e0f","modified":1567532730764},{"_id":"themes/next/layout/_partials/page-header.swig","hash":"77c61e0baea3544df361b7338c3cd13dc84dde22","modified":1567532730768},{"_id":"themes/next/layout/_partials/comments.swig","hash":"4adc65a602d1276615da3b887dcbf2ac68e7382b","modified":1567532730766},{"_id":"themes/next/layout/_partials/pagination.swig","hash":"1634fb887842698e01ff6e632597fe03c75d2d01","modified":1567532730768},{"_id":"themes/next/layout/_partials/header.swig","hash":"c54b32263bc8d75918688fb21f795103b3f57f03","modified":1567532730768},{"_id":"themes/next/layout/_partials/head.swig","hash":"f14a39dad1ddd98e6d3ceb25dda092ba80d391b5","modified":1567532730767},{"_id":"themes/next/layout/_scripts/boostrap.swig","hash":"c0f5a0955f69ca4ed9ee64a2d5f8aa75064935ad","modified":1567532730772},{"_id":"themes/next/layout/_partials/search.swig","hash":"b4ebe4a52a3b51efe549dd1cdee846103664f5eb","modified":1567532730769},{"_id":"themes/next/layout/_scripts/commons.swig","hash":"931808ad9b8d8390c0dcf9bdeb0954eeb9185d68","modified":1567532730772},{"_id":"themes/next/layout/_third-party/duoshuo-hot-articles.swig","hash":"ba75672183d94f1de7c8bd0eeee497a58c70e889","modified":1567532730780},{"_id":"themes/next/layout/_scripts/vendors.swig","hash":"9be624634703be496a5d2535228bc568a8373af9","modified":1567532730773},{"_id":"themes/next/layout/_third-party/exturl.swig","hash":"8301c9600bb3e47f7fb98b0e0332ef3c51bb1688","modified":1567532730781},{"_id":"themes/next/layout/_third-party/mathjax.swig","hash":"a0bd3388587fd943baae0d84ca779a707fbcad89","modified":1567532730781},{"_id":"themes/next/layout/_third-party/needsharebutton.swig","hash":"fa882641da3bd83d9a58a8a97f9d4c62a9ee7b5c","modified":1567532730782},{"_id":"themes/next/scripts/tags/center-quote.js","hash":"99b66949f18398689b904907af23c013be1b978f","modified":1567532730788},{"_id":"themes/next/scripts/tags/button.js","hash":"eddbb612c15ac27faf11c59c019ce188f33dec2c","modified":1567532730788},{"_id":"themes/next/scripts/tags/exturl.js","hash":"5022c0ba9f1d13192677cf1fd66005c57c3d0f53","modified":1567532730788},{"_id":"themes/next/scripts/tags/full-image.js","hash":"c9f833158c66bd72f627a0559cf96550e867aa72","modified":1567532730789},{"_id":"themes/next/scripts/tags/group-pictures.js","hash":"ac681b0d0d8d39ba3817336c0270c6787c2b6b70","modified":1567532730789},{"_id":"themes/next/scripts/tags/lazy-image.js","hash":"bcba2ff25cd7850ce6da322d8bd85a8dd00b5ceb","modified":1567532730790},{"_id":"themes/next/scripts/tags/label.js","hash":"6f00952d70aadece844ce7fd27adc52816cc7374","modified":1567532730789},{"_id":"themes/next/scripts/tags/note.js","hash":"f7eae135f35cdab23728e9d0d88b76e00715faa0","modified":1567532730790},{"_id":"themes/next/scripts/tags/tabs.js","hash":"aa7fc94a5ec27737458d9fe1a75c0db7593352fd","modified":1567532730790},{"_id":"themes/next/layout/_third-party/rating.swig","hash":"554ec568e9d2c71e4a624a8de3cb5929050811d6","modified":1567532730782},{"_id":"themes/next/layout/_third-party/scroll-cookie.swig","hash":"9a188938d46931d5f3882a140aa1c48b3a893f0c","modified":1567532730782},{"_id":"themes/next/source/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1567532730822},{"_id":"themes/next/source/css/main.styl","hash":"a91dbb7ef799f0a171b5e726c801139efe545176","modified":1567532730822},{"_id":"themes/next/source/images/avatar.gif","hash":"264082bb3a1af70d5499c7d22b0902cb454b6d12","modified":1567532730823},{"_id":"themes/next/source/images/algolia_logo.svg","hash":"45eeea0b5fba833e21e38ea10ed5ab385ceb4f01","modified":1567532730822},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","hash":"bc3588c9b2d7c68830524783120ff6cf957cf668","modified":1567532730823},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","hash":"6f55543d1fb9cbc436c101d24f802dec7b41efc3","modified":1567532730823},{"_id":"themes/next/source/images/cc-by-nc.svg","hash":"6f076713fb9bf934aa2c1046bdf2cf2e37bc1eab","modified":1567532730824},{"_id":"themes/next/layout/_third-party/schedule.swig","hash":"db15d7e1552aa2d2386a6b8a33b3b3a40bf9e43d","modified":1567532730782},{"_id":"themes/next/source/images/cc-by-sa.svg","hash":"70c1535f43e54e5ff35ca81419e77e4c0c301398","modified":1567532730824},{"_id":"themes/next/source/images/cc-by-nd.svg","hash":"42cd73da328077ccc92f859bb8f3cf621b3484f8","modified":1567532730824},{"_id":"themes/next/source/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1567532730825},{"_id":"themes/next/source/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1567532730826},{"_id":"themes/next/source/images/loading.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1567532730826},{"_id":"themes/next/source/images/placeholder.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1567532730826},{"_id":"themes/next/source/images/cc-zero.svg","hash":"9bfb52b2f63527a7049247bf00d44e6dc1170e7d","modified":1567532730825},{"_id":"themes/next/source/images/cc-by.svg","hash":"e92a33c32d1dac8ed94849b2b4e6456e887efe70","modified":1567532730825},{"_id":"themes/next/source/images/searchicon.png","hash":"67727a6a969be0b2659b908518fa6706eed307b8","modified":1567532730827},{"_id":"themes/next/source/images/logo.svg","hash":"169f56fd82941591dad3abd734a50ec7259be950","modified":1567532730826},{"_id":"themes/next/source/images/quote-l.svg","hash":"cd108d6f44351cadf8e6742565217f88818a0458","modified":1567532730827},{"_id":"themes/next/layout/_scripts/schemes/mist.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1567532730773},{"_id":"themes/next/layout/_scripts/schemes/muse.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1567532730773},{"_id":"themes/next/source/images/quote-r.svg","hash":"2a2a250b32a87c69dcc1b1976c74b747bedbfb41","modified":1567532730827},{"_id":"themes/next/source/css/_mixins/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1567532730813},{"_id":"themes/next/source/css/_mixins/Mist.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1567532730812},{"_id":"themes/next/source/css/_mixins/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1567532730812},{"_id":"themes/next/source/css/_variables/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1567532730821},{"_id":"themes/next/source/css/_variables/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1567532730821},{"_id":"themes/next/.git/refs/heads/master","hash":"3c959678e3fe6e51e935526c19927d21443a3be3","modified":1567532730715},{"_id":"themes/next/layout/_partials/head/external-fonts.swig","hash":"f5e487b0d213ca0bd94aa30bc23b240d65081627","modified":1567532730767},{"_id":"themes/next/layout/_partials/head/custom-head.swig","hash":"a223919d2e1bf17ca4d6abb2c86f2efca9883dc1","modified":1567532730767},{"_id":"themes/next/layout/_partials/search/localsearch.swig","hash":"b2f0d247b213e4cf8de47af6a304d98070cc7256","modified":1567532730769},{"_id":"themes/next/layout/_partials/search/tinysou.swig","hash":"b25002a83cbd2ca0c4a5df87ad5bff26477c0457","modified":1567532730770},{"_id":"themes/next/layout/_partials/share/add-this.swig","hash":"9e3d133ac5bcc6cb51702c83b2611a49811abad1","modified":1567532730770},{"_id":"themes/next/layout/_partials/search/swiftype.swig","hash":"a8c7f9ca7c605d039a1f3bf4e4d3183700a3dd62","modified":1567532730769},{"_id":"themes/next/layout/_partials/share/duoshuo_share.swig","hash":"d4fbffd7fa8f2090eb32a871872665d90a885fac","modified":1567532730771},{"_id":"themes/next/layout/_scripts/schemes/pisces.swig","hash":"a9a3995b9615adfb8d6b127c78c6771627bee19a","modified":1567532730773},{"_id":"themes/next/layout/_scripts/schemes/gemini.swig","hash":"a9a3995b9615adfb8d6b127c78c6771627bee19a","modified":1567532730773},{"_id":"themes/next/layout/_partials/share/jiathis.swig","hash":"0a9cdd6958395fcdffc80ab60f0c6301b63664a5","modified":1567532730771},{"_id":"themes/next/layout/_scripts/pages/post-details.swig","hash":"9b84ab576982b2c3bb0291da49143bc77fba3cc6","modified":1567532730772},{"_id":"themes/next/layout/_partials/share/baidushare.swig","hash":"d9e2d9282f9be6e04eae105964abb81e512bffed","modified":1567532730771},{"_id":"themes/next/layout/_third-party/comments/disqus.swig","hash":"b83a51bbe0f1e2ded9819070840b0ea145f003a6","modified":1567532730778},{"_id":"themes/next/layout/_third-party/comments/duoshuo.swig","hash":"1600f340e0225361580c44890568dc07dbcf2c89","modified":1567532730779},{"_id":"themes/next/layout/_third-party/comments/index.swig","hash":"493bd5999a1061b981922be92d8277a0f9152447","modified":1567532730779},{"_id":"themes/next/layout/_third-party/comments/gitment.swig","hash":"4dcc3213c033994d342d02b800b6229295433d30","modified":1567532730779},{"_id":"themes/next/layout/_third-party/comments/hypercomments.swig","hash":"af7f3e43cbdc4f88c13f101f0f341af96ace3383","modified":1567532730779},{"_id":"themes/next/layout/_third-party/comments/youyan.swig","hash":"7e65ff8fe586cd655b0e9d1ad2912663ff9bd36c","modified":1567532730780},{"_id":"themes/next/layout/_third-party/comments/livere.swig","hash":"9246162d4bc7e949ce1d12d135cbbaf5dc3024ec","modified":1567532730780},{"_id":"themes/next/layout/_third-party/analytics/analytics-with-widget.swig","hash":"ff947f3561b229bc528cb1837d4ca19612219411","modified":1567532730774},{"_id":"themes/next/layout/_third-party/comments/changyan.swig","hash":"4c501ea0b9c494181eb3c607c5526a5754e7fbd8","modified":1567532730778},{"_id":"themes/next/layout/_third-party/comments/valine.swig","hash":"4050553d44ba1396174161c9a6bb0f89fa779eca","modified":1567532730780},{"_id":"themes/next/layout/_third-party/analytics/cnzz-analytics.swig","hash":"a10b7f19d7b5725527514622899df413a34a89db","modified":1567532730775},{"_id":"themes/next/layout/_third-party/analytics/busuanzi-counter.swig","hash":"7b11eac3a0685fa1ab2ab6ecff60afc4f15f0d16","modified":1567532730775},{"_id":"themes/next/layout/_third-party/analytics/application-insights.swig","hash":"71397a5823e8ec8aad3b68aace13150623b3e19d","modified":1567532730774},{"_id":"themes/next/layout/_third-party/analytics/facebook-sdk.swig","hash":"7d94845f96197d9d84a405fa5d4ede75fb81b225","modified":1567532730775},{"_id":"themes/next/layout/_third-party/analytics/index.swig","hash":"45f3f629c2aacc381095750e1c8649041a71a84b","modified":1567532730776},{"_id":"themes/next/layout/_third-party/analytics/baidu-analytics.swig","hash":"753d262911c27baf663fcaf199267133528656af","modified":1567532730774},{"_id":"themes/next/layout/_third-party/analytics/firestore.swig","hash":"ccc443b22bd4f8c7ac4145664686c756395b90e0","modified":1567532730776},{"_id":"themes/next/layout/_third-party/analytics/google-analytics.swig","hash":"b1e13df83fb2b1d5d513b30b7aa6158b0837daab","modified":1567532730776},{"_id":"themes/next/layout/_third-party/analytics/tencent-mta.swig","hash":"5a8027328f060f965b3014060bebec1d7cf149c1","modified":1567532730777},{"_id":"themes/next/layout/_third-party/analytics/vkontakte-api.swig","hash":"f9a1647a8f1866deeb94052d1f87a5df99cb1e70","modified":1567532730777},{"_id":"themes/next/layout/_third-party/search/index.swig","hash":"34599633658f3b0ffb487728b7766e1c7b551f5a","modified":1567532730783},{"_id":"themes/next/layout/_third-party/analytics/tencent-analytics.swig","hash":"8a399df90dadba5ad4e781445b58f4765aeb701e","modified":1567532730777},{"_id":"themes/next/layout/_third-party/search/tinysou.swig","hash":"fe95dd3d166634c466e19aa756e65ad6e8254d3e","modified":1567532730784},{"_id":"themes/next/layout/_third-party/analytics/lean-analytics.swig","hash":"e6d10ee4fb70b3ae1cd37e9e36e000306734aa2e","modified":1567532730776},{"_id":"themes/next/layout/_third-party/seo/baidu-push.swig","hash":"d8c98938719284fa06492c114d99a1904652a555","modified":1567532730784},{"_id":"themes/next/source/js/src/bootstrap.js","hash":"0289031200c3d4c2bdd801ee10fff13bb2c353e4","modified":1567532730828},{"_id":"themes/next/source/js/src/algolia-search.js","hash":"cb431b54ba9c692165a1f5a12e4c564a560f8058","modified":1567532730828},{"_id":"themes/next/source/js/src/affix.js","hash":"1b509c3b5b290a6f4607f0f06461a0c33acb69b1","modified":1567532730828},{"_id":"themes/next/layout/_third-party/search/localsearch.swig","hash":"93479642fd076a1257fecc25fcf5d20ccdefe509","modified":1567532730784},{"_id":"themes/next/source/js/src/exturl.js","hash":"a2a0f0de07e46211f74942a468f42ee270aa555c","modified":1567532730828},{"_id":"themes/next/source/js/src/motion.js","hash":"885176ed51d468f662fbf0fc09611f45c7e5a3b1","modified":1567532730829},{"_id":"themes/next/source/js/src/js.cookie.js","hash":"1512c751d219577d338ac0780fb2bbd9075d5298","modified":1567532730829},{"_id":"themes/next/source/js/src/hook-duoshuo.js","hash":"b35a7dc47b634197b93487cea8671a40a9fdffce","modified":1567532730829},{"_id":"themes/next/source/js/src/post-details.js","hash":"93a18271b4123dd8f94f09d1439b47c3c19a8712","modified":1567532730830},{"_id":"themes/next/source/css/_mixins/Pisces.styl","hash":"7896c3ee107e1a8b9108b6019f1c070600a1e8cc","modified":1567532730813},{"_id":"themes/next/source/js/src/scroll-cookie.js","hash":"02cf91514e41200bc9df5d8bdbeb58575ec06074","modified":1567532730830},{"_id":"themes/next/source/css/_mixins/Gemini.styl","hash":"07f7da320689f828f6e36a6123807964a45157a0","modified":1567532730812},{"_id":"themes/next/source/css/_mixins/base.styl","hash":"0e55cbd93852dc3f8ccb44df74d35d9918f847e0","modified":1567532730813},{"_id":"themes/next/source/js/src/scrollspy.js","hash":"b7657be25fc52ec67c75ab5481bdcb483573338b","modified":1567532730831},{"_id":"themes/next/source/js/src/utils.js","hash":"b3e9eca64aba59403334f3fa821f100d98d40337","modified":1567532730831},{"_id":"themes/next/source/css/_custom/custom.styl","hash":"3403fdd8efde1a0afd11ae8a5a97673f5903087f","modified":1567532730812},{"_id":"themes/next/source/css/_variables/Pisces.styl","hash":"4069f918ccc312da86db6c51205fc6c6eaabb116","modified":1567532730821},{"_id":"themes/next/source/css/_variables/Gemini.styl","hash":"58e7dd5947817d9fc30770712fc39b2f52230d1e","modified":1567532730820},{"_id":"themes/next/source/css/_variables/Mist.styl","hash":"a25408534f8fe6e321db4bbf9dd03335d648fe17","modified":1567532730820},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.css","hash":"90ef19edc982645b118b095615838d9c5eaba0de","modified":1567532730837},{"_id":"themes/next/source/css/_variables/base.styl","hash":"b1f6ea881a4938a54603d68282b0f8efb4d7915d","modified":1567532730821},{"_id":"themes/next/source/lib/canvas-nest/canvas-nest.min.js","hash":"0387e75e23b1db108a755073fe52a0d03eb391a7","modified":1567532730840},{"_id":"themes/next/source/lib/fancybox/.bower.json","hash":"9be892a4e14e0da18ff9cb962c9ef71f163b1b22","modified":1567532730841},{"_id":"themes/next/source/lib/fancybox/.gitattributes","hash":"672d3b5767e0eacd83bb41b188c913f2cf754793","modified":1567532730841},{"_id":"themes/next/source/lib/fastclick/LICENSE","hash":"6f474ea75c42442da7bbcf2e9143ce98258efd8d","modified":1567532730848},{"_id":"themes/next/source/lib/canvas-ribbon/canvas-ribbon.js","hash":"b02737510e9b89aeed6b54f89f602a9c24b06ff2","modified":1567532730841},{"_id":"themes/next/source/lib/fastclick/.bower.json","hash":"bf3eef9d647cd7c9b62feda3bc708c6cdd7c0877","modified":1567532730848},{"_id":"themes/next/source/lib/fastclick/bower.json","hash":"a9b3ee1e4db71a0e4ea6d5bed292d176dd68b261","modified":1567532730849},{"_id":"themes/next/source/lib/font-awesome/.gitignore","hash":"03ddbf76c1dd1afb93eed0b670d2eee747472ef1","modified":1567532730850},{"_id":"themes/next/source/lib/font-awesome/.bower.json","hash":"b4aefc910578d76b267e86dfffdd5121c8db9aec","modified":1567532730850},{"_id":"themes/next/source/lib/fastclick/README.md","hash":"68a9b9d53126405b0fa5f3324f1fb96dbcc547aa","modified":1567532730849},{"_id":"themes/next/source/lib/font-awesome/bower.json","hash":"71e7183634dc1b9449f590f15ebd7201add22ca7","modified":1567532730851},{"_id":"themes/next/source/lib/font-awesome/.npmignore","hash":"c31ff06a740955e44edd4403902e653ccabfd4db","modified":1567532730851},{"_id":"themes/next/source/lib/font-awesome/HELP-US-OUT.txt","hash":"ee33b2798b1e714b904d663436c6b3521011d1fa","modified":1567532730851},{"_id":"themes/next/source/lib/jquery/.bower.json","hash":"865d6c1328ab209a4376b9d2b7a7824369565f28","modified":1567532730865},{"_id":"themes/next/source/lib/jquery_lazyload/.bower.json","hash":"90fa628f156d8045357ff11eaf32e61abacf10e8","modified":1567532730867},{"_id":"themes/next/source/lib/jquery_lazyload/README.md","hash":"b930297cb98b8e1dbd5abe9bc1ed9d5935d18ce8","modified":1567532730867},{"_id":"themes/next/source/lib/jquery_lazyload/bower.json","hash":"e0acf1db27b0cc16128a59c46db1db406b5c4c58","modified":1567532730868},{"_id":"themes/next/source/lib/jquery_lazyload/CONTRIBUTING.md","hash":"4ded6fee668544778e97e38c2b211fc56c848e77","modified":1567532730867},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.lazyload.js","hash":"f4a570908f6c89c6edfb1c74959e733eaadea4f2","modified":1567532730868},{"_id":"themes/next/source/lib/needsharebutton/needsharebutton.css","hash":"e33aa8fa48b6639d8d8b937d13261597dd473b3a","modified":1567532730869},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.scrollstop.js","hash":"bf773ad48a0b9aa77681a89d7569eefc0f7b7b18","modified":1567532730868},{"_id":"themes/next/source/lib/needsharebutton/needsharebutton.js","hash":"2ce5f3bf15c523b9bfc97720d8884bb22602a454","modified":1567532730870},{"_id":"themes/next/source/lib/pace/pace-theme-barber-shop.min.css","hash":"ee0d51446cb4ffe1bb96bd7bc8c8e046dddfcf46","modified":1567532730870},{"_id":"themes/next/source/lib/pace/pace-theme-big-counter.min.css","hash":"5b561dc328af4c4d512e20a76fe964d113a32ba8","modified":1567532730871},{"_id":"themes/next/source/lib/pace/pace-theme-center-atom.min.css","hash":"dcf79c24fe5350fb73d8038573a104e73639e9d3","modified":1567532730871},{"_id":"themes/next/source/lib/needsharebutton/font-embedded.css","hash":"14264a210bf94232d58d7599ea2ba93bfa4fb458","modified":1567532730869},{"_id":"themes/next/source/lib/pace/pace-theme-bounce.min.css","hash":"f6bdb9a785b7979dd8ec5c60e278af955ef1e585","modified":1567532730871},{"_id":"themes/next/source/lib/pace/pace-theme-center-circle.min.css","hash":"a4066769c78affbfbc5e30a600e2c7862cd532e0","modified":1567532730872},{"_id":"themes/next/source/lib/pace/pace-theme-center-simple.min.css","hash":"67f44c947548bd4d77e7590d3f59e236cbf9e98a","modified":1567532730872},{"_id":"themes/next/source/lib/pace/pace-theme-center-radar.min.css","hash":"ab7cba998bf4c03b13df342bf43647fa4f419783","modified":1567532730872},{"_id":"themes/next/source/lib/pace/pace-theme-fill-left.min.css","hash":"0bec1e235a4a2cccda3f993b205424e1441a44ae","modified":1567532730873},{"_id":"themes/next/source/lib/pace/pace-theme-corner-indicator.min.css","hash":"b3c64c973f31884e3d8145989476707333406b9a","modified":1567532730873},{"_id":"themes/next/source/lib/pace/pace-theme-flash.min.css","hash":"13ace22c40312d7bbd8d9c1e50eff897a7a497d8","modified":1567532730873},{"_id":"themes/next/source/lib/pace/pace-theme-loading-bar.min.css","hash":"7ee28875dfc1230d76c537f6605766e8d4011e9f","modified":1567532730873},{"_id":"themes/next/source/lib/pace/pace-theme-mac-osx.min.css","hash":"9f2e7b51b084da407863826b25265b31150b3821","modified":1567532730874},{"_id":"themes/next/source/lib/pace/pace-theme-minimal.min.css","hash":"9cd783cceb8a191f3c8b5d81f7a430ecc3e489d3","modified":1567532730874},{"_id":"themes/next/source/lib/three/canvas_sphere.min.js","hash":"46a50b91c98b639c9a2b9265c5a1e66a5c656881","modified":1567532730875},{"_id":"themes/next/source/lib/pace/pace.min.js","hash":"8aaa675f577d5501f5f22d5ccb07c2b76310b690","modified":1567532730874},{"_id":"themes/next/source/lib/three/three-waves.min.js","hash":"8148492dd49aa876d32bb7d5b728d3f5bf6f5074","modified":1567532730876},{"_id":"themes/next/source/lib/velocity/.bower.json","hash":"63da5e80ebb61bb66a2794d5936315ca44231f0c","modified":1567532730881},{"_id":"themes/next/source/lib/velocity/bower.json","hash":"92d92860418c4216aa59eb4cb4a556290a7ad9c3","modified":1567532730881},{"_id":"themes/next/source/lib/three/canvas_lines.min.js","hash":"2d9a9f38c493fdf7c0b833bb9184b6a1645c11b2","modified":1567532730875},{"_id":"themes/next/source/lib/velocity/velocity.ui.js","hash":"dbbfb50f6502f6b81dcc9fee7b31f1e812da3464","modified":1567532730885},{"_id":"themes/next/source/lib/velocity/velocity.min.js","hash":"bf172816a9c57f9040e3d19c24e181a142daf92b","modified":1567532730884},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","hash":"dde584994ac13dc601836e86f4cf490e418d9723","modified":1567532730885},{"_id":"themes/next/source/lib/jquery/index.js","hash":"17a740d68a1c330876c198b6a4d9319f379f3af2","modified":1567532730866},{"_id":"themes/next/.git/logs/refs/heads/master","hash":"7c30010e0c4c678c4e6991c91f13581210eb4eb5","modified":1567532730716},{"_id":"themes/next/.git/refs/remotes/origin/HEAD","hash":"d9427cda09aba1cdde5c69c2b13c905bddb0bc51","modified":1567532730712},{"_id":"themes/next/layout/_third-party/search/algolia-search/assets.swig","hash":"218cc936ba3518a3591b2c9eda46bc701edf7710","modified":1567532730783},{"_id":"themes/next/layout/_third-party/search/algolia-search/dom.swig","hash":"2530de0f3125a912756f6c0e9090cd012134a4c5","modified":1567532730783},{"_id":"themes/next/source/css/_common/components/back-to-top.styl","hash":"237d185ac62ec9877e300947fa0109c44fb8db19","modified":1567532730791},{"_id":"themes/next/source/css/_common/components/back-to-top-sidebar.styl","hash":"8f86f694c0749a18ab3ad6f6df75466ca137a4bc","modified":1567532730791},{"_id":"themes/next/source/css/_common/components/buttons.styl","hash":"8b32928686c327151e13d3ab100157f9a03cd59f","modified":1567532730792},{"_id":"themes/next/source/css/_common/components/comments.styl","hash":"ff4489cd582f518bba6909a301ac1292a38b4e96","modified":1567532730792},{"_id":"themes/next/source/css/_common/components/components.styl","hash":"7ad4081466b397e2a6204141bb7768b7c01bd93c","modified":1567532730792},{"_id":"themes/next/source/css/_common/components/pagination.styl","hash":"4f2801fc4cf3f31bf2069f41db8c6ce0e3da9e39","modified":1567532730797},{"_id":"themes/next/source/css/_common/components/tag-cloud.styl","hash":"6eb4bcc3056bd279d000607e8b4dad50d368ca69","modified":1567532730804},{"_id":"themes/next/source/css/_common/scaffolding/base.styl","hash":"24ee4b356ff55fc6e58f26a929fa07750002cf29","modified":1567532730810},{"_id":"themes/next/source/css/_common/scaffolding/scaffolding.styl","hash":"a17e2b871a335f290afb392a08f94fd35f59c715","modified":1567532730811},{"_id":"themes/next/source/css/_common/scaffolding/helpers.styl","hash":"1da5c800d025345f212a3bf1be035060f4e5e6ed","modified":1567532730810},{"_id":"themes/next/source/css/_common/scaffolding/normalize.styl","hash":"3f40e8a9fe8e7bd5cfc4cf4cbbbcb9539462e973","modified":1567532730811},{"_id":"themes/next/source/css/_common/scaffolding/mobile.styl","hash":"91ca75492cd51f2553f4d294ed2f48239fcd55eb","modified":1567532730811},{"_id":"themes/next/source/css/_common/scaffolding/tables.styl","hash":"ea9069645696f86c5df64208490876fe150c8cae","modified":1567532730812},{"_id":"themes/next/source/css/_schemes/Mist/_base.styl","hash":"25d5e45a355ee2093f3b8b8eeac125ebf3905026","modified":1567532730814},{"_id":"themes/next/source/css/_common/outline/outline.styl","hash":"12662536c7a07fff548abe94171f34b768dd610f","modified":1567532730810},{"_id":"themes/next/source/css/_schemes/Mist/_header.styl","hash":"d0bfd1bef988c76f7d7dd72d88af6f0908a8b0db","modified":1567532730814},{"_id":"themes/next/source/css/_schemes/Mist/_menu.styl","hash":"26666c1f472bf5f3fb9bc62081cca22b4de15ccb","modified":1567532730815},{"_id":"themes/next/source/css/_schemes/Mist/_logo.styl","hash":"b1025c421406d2c24cc92a02ae28c1915b01e240","modified":1567532730814},{"_id":"themes/next/source/css/_schemes/Mist/_posts-expanded.styl","hash":"9c99034f8e00d47e978b3959f51eb4a9ded0fcc8","modified":1567532730815},{"_id":"themes/next/source/css/_schemes/Mist/_search.styl","hash":"09c965022c13b84ed8a661fee8ac2a6d550495ae","modified":1567532730815},{"_id":"themes/next/source/css/_schemes/Mist/index.styl","hash":"9b913b73d31d21f057f97115ffab93cfa578b884","modified":1567532730816},{"_id":"themes/next/source/css/_schemes/Pisces/_brand.styl","hash":"bce344d3a665b4c55230d2a91eac2ad16d6f32fd","modified":1567532730818},{"_id":"themes/next/source/css/_schemes/Gemini/index.styl","hash":"60fa84aa7731760f05f52dd7d8f79b5f74ac478d","modified":1567532730813},{"_id":"themes/next/source/css/_schemes/Pisces/_layout.styl","hash":"416988dca389e6e2fdfa51fa7f4ee07eb53f82fb","modified":1567532730819},{"_id":"themes/next/source/css/_schemes/Pisces/_posts.styl","hash":"1f6e2ce674735269599acc6d77b3ea18d31967fc","modified":1567532730819},{"_id":"themes/next/source/css/_schemes/Pisces/_menu.styl","hash":"4642e30010af8b2b037f5b43146b10a934941958","modified":1567532730819},{"_id":"themes/next/source/css/_schemes/Pisces/index.styl","hash":"86197902dfd3bededba10ba62b8f9f22e0420bde","modified":1567532730820},{"_id":"themes/next/source/css/_schemes/Muse/_layout.styl","hash":"31127dcbf4c7b4ada53ffbf1638b5fe325b7cbc0","modified":1567532730817},{"_id":"themes/next/source/css/_schemes/Muse/_logo.styl","hash":"748dbfbf9c08e719ddc775958003c64b00d39dab","modified":1567532730817},{"_id":"themes/next/source/css/_schemes/Pisces/_sidebar.styl","hash":"ad2dcedf393ed1f3f5afd2508d24969c916d02fc","modified":1567532730820},{"_id":"themes/next/source/css/_schemes/Muse/_search.styl","hash":"09c965022c13b84ed8a661fee8ac2a6d550495ae","modified":1567532730817},{"_id":"themes/next/source/css/_schemes/Muse/_menu.styl","hash":"e695e58f714129ca292c2e54cd62c251aca7f7fe","modified":1567532730817},{"_id":"themes/next/source/css/_schemes/Muse/index.styl","hash":"5dbc0d0c897e46760e5dbee416530d485c747bba","modified":1567532730818},{"_id":"themes/next/source/lib/Han/dist/han.css","hash":"6c26cdb36687d4f0a11dabf5290a909c3506be5c","modified":1567532730831},{"_id":"themes/next/source/lib/Han/dist/han.min.css","hash":"6d586bfcfb7ae48f1b12f76eec82d3ad31947501","modified":1567532730836},{"_id":"themes/next/source/lib/fancybox/source/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1567532730842},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1567532730842},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1567532730843},{"_id":"themes/next/source/lib/fancybox/source/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1567532730843},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1567532730844},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1567532730844},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.css","hash":"82f33ad0842aa9c154d029e0dada2497d4eb1d57","modified":1567532730846},{"_id":"themes/next/source/lib/Han/dist/han.min.js","hash":"16b03db23a52623348f37c04544f2792032c1fb6","modified":1567532730836},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.js","hash":"d71602cbca33b9ecdb7ab291b7f86a49530f3601","modified":1567532730847},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.js","hash":"1d6aeda0480d0e4cb6198edf7719d601d4ae2ccc","modified":1567532730849},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css.map","hash":"1573904b82807abbb32c97a3632c6c6808eaac50","modified":1567532730852},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.min.js","hash":"2cae0f5a6c5d6f3cb993015e6863f9483fc4de18","modified":1567532730850},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css","hash":"3655f1fdf1e584c4d8e8d39026093ca306a5a341","modified":1567532730852},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.pack.js","hash":"ae6318aeb62ad4ce7a7e9a4cdacd93ffb004f0fb","modified":1567532730847},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.min.css","hash":"88af80502c44cd52ca81ffe7dc7276b7eccb06cf","modified":1567532730853},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.min.js","hash":"41ea797c68dbcff2f6fb3aba1d1043a22e7cc0f6","modified":1567532730880},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.pack.js","hash":"a817b6c158cbc5bab3582713de9fe18a18a80552","modified":1567532730880},{"_id":"themes/next/source/js/src/schemes/pisces.js","hash":"f1d0b5d7af32c423eaa8bb93ab6a0b45655645dc","modified":1567532730830},{"_id":"themes/next/source/lib/Han/dist/han.js","hash":"4ac683b2bc8531c84d98f51b86957be0e6f830f3","modified":1567532730835},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1567532730864},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1567532730863},{"_id":"themes/next/source/lib/velocity/velocity.js","hash":"4237c6e9d59da349639de20e559e87c2c0218cfd","modified":1567532730883},{"_id":"themes/next/.git/logs/refs/remotes/origin/HEAD","hash":"7c30010e0c4c678c4e6991c91f13581210eb4eb5","modified":1567532730712},{"_id":"themes/next/source/css/_common/components/header/header.styl","hash":"53cde051e0337f4bf42fb8d6d7a79fa3fa6d4ef2","modified":1567532730793},{"_id":"themes/next/source/css/_common/components/header/site-meta.styl","hash":"0656e753f182c9f47fef7304c847b7587a85ef0d","modified":1567532730794},{"_id":"themes/next/source/css/_common/components/header/menu.styl","hash":"1a0d059799a298fe17c49a44298d32cebde93785","modified":1567532730793},{"_id":"themes/next/source/css/_common/components/header/site-nav.styl","hash":"1727702eac5d326b5c81a667944a245016668231","modified":1567532730794},{"_id":"themes/next/source/css/_common/components/header/headerband.styl","hash":"d63e0cacc53dd375fcc113465a4328c59ff5f2c1","modified":1567532730793},{"_id":"themes/next/source/css/_common/components/highlight/diff.styl","hash":"167986d0f649516671ddf7193eebba7b421cd115","modified":1567532730794},{"_id":"themes/next/source/css/_common/components/highlight/theme.styl","hash":"7fe4d4d656e86276c17cb4e48a560cb6a4def703","modified":1567532730795},{"_id":"themes/next/source/css/_common/components/highlight/highlight.styl","hash":"50450d9fdc8a2b2be8cfca51e3e1a01ffd636c0b","modified":1567532730795},{"_id":"themes/next/source/css/_common/components/footer/footer.styl","hash":"9f73c4696f0907aa451a855444f88fc0698fa472","modified":1567532730793},{"_id":"themes/next/source/css/_common/components/pages/archive.styl","hash":"b6f3a06a94a6ee5470c956663164d58eda818a64","modified":1567532730795},{"_id":"themes/next/source/css/_common/components/pages/categories.styl","hash":"7fb593f90d74a99c21840679933b9ef6fdc16a61","modified":1567532730796},{"_id":"themes/next/source/css/_common/components/pages/pages.styl","hash":"f9760ecf186954cee3ba4a149be334e9ba296b89","modified":1567532730796},{"_id":"themes/next/source/css/_common/components/pages/post-detail.styl","hash":"4e3838d7ac81d9ad133960f0f7ed58a44a015285","modified":1567532730796},{"_id":"themes/next/source/css/_common/components/post/post-button.styl","hash":"62fbbd32cf5a99ae550c45c763a2c4813a138d01","modified":1567532730797},{"_id":"themes/next/source/css/_common/components/pages/schedule.styl","hash":"8cf318644acc8b4978537c263290363e21c7f5af","modified":1567532730796},{"_id":"themes/next/source/css/_common/components/post/post-collapse.styl","hash":"875cbe88d5c7f6248990e2beb97c9828920e7e24","modified":1567532730797},{"_id":"themes/next/source/css/_common/components/post/post-copyright.styl","hash":"caf263d1928496688c0e1419801eafd7e6919ce5","modified":1567532730797},{"_id":"themes/next/source/css/_common/components/post/post-eof.styl","hash":"a200c0a1c5a895ac9dc41e0641a5dfcd766be99b","modified":1567532730798},{"_id":"themes/next/source/css/_common/components/post/post-expand.styl","hash":"a6c6eb8adba0a090ad1f4b9124e866887f20d10d","modified":1567532730798},{"_id":"themes/next/source/css/_common/components/post/post-gallery.styl","hash":"cd9e214e502697f2f2db84eb721bac57a49b0fce","modified":1567532730798},{"_id":"themes/next/source/css/_common/components/post/post-meta.styl","hash":"d0d7a5c90d62b685520d2b47fea8ba6019ff5402","modified":1567532730799},{"_id":"themes/next/source/css/_common/components/post/post-reward.styl","hash":"ca88ea6999a61fb905eb6e72eba5f92d4ee31e6e","modified":1567532730799},{"_id":"themes/next/source/css/_common/components/post/post-nav.styl","hash":"27deb3d3a243d30022055dac7dad851024099a8b","modified":1567532730799},{"_id":"themes/next/source/css/_common/components/post/post-rtl.styl","hash":"b2495ae5e04dcca610aacadc47881d9e716cd440","modified":1567532730800},{"_id":"themes/next/source/css/_common/components/post/post-tags.styl","hash":"5a982d8ef3b3623ea5f59e63728990f5623c1b57","modified":1567532730800},{"_id":"themes/next/source/css/_common/components/post/post-title.styl","hash":"ccb34c52be8adba5996c6b94f9e723bd07d34c16","modified":1567532730800},{"_id":"themes/next/source/css/_common/components/post/post-type.styl","hash":"01567edaea6978628aa5521a122a85434c418bfd","modified":1567532730800},{"_id":"themes/next/source/css/_common/components/post/post-widgets.styl","hash":"7968343e41f8b94b318c36289dff1196c3eb1791","modified":1567532730801},{"_id":"themes/next/source/css/_common/components/post/post.styl","hash":"89d6c3b697efc63de42afd2e89194b1be14152af","modified":1567532730801},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author-links.styl","hash":"39f04c4c7237a4e10acd3002331992b79945d241","modified":1567532730801},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author.styl","hash":"761eba9811b050b25d548cc0854de4824b41eb08","modified":1567532730802},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-blogroll.styl","hash":"8dd9a1c6f4f6baa00c2cf01837e7617120cf9660","modified":1567532730802},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-feed-link.styl","hash":"61f8cea3c01acd600e90e1bc2a07def405503748","modified":1567532730802},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-dimmer.styl","hash":"11c22f0fb3f6beb13e5a425ec064a4ff974c13b7","modified":1567532730802},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toc.styl","hash":"c8fe49a4bc014c24dead05b782a7082411a4abc5","modified":1567532730803},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toggle.styl","hash":"a1521d48bb06d8d703753f52a198baa197af7da2","modified":1567532730803},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-nav.styl","hash":"1153bb71edf253765145559674390e16dd67c633","modified":1567532730803},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar.styl","hash":"5ef6343835f484a2c0770bd1eb9cc443609e4c39","modified":1567532730804},{"_id":"themes/next/source/css/_common/components/sidebar/site-state.styl","hash":"e71652d3216e289c8548b1ea2357822c1476a425","modified":1567532730804},{"_id":"themes/next/source/css/_common/components/tags/exturl.styl","hash":"a3bdd71237afc112b2aa255f278cab6baeb25351","modified":1567532730805},{"_id":"themes/next/source/css/_common/components/tags/full-image.styl","hash":"f825da191816eef69ea8efb498a7f756d5ebb498","modified":1567532730805},{"_id":"themes/next/source/css/_common/components/tags/blockquote-center.styl","hash":"2fe76476432b31993338cb45cdb3b29a518b6379","modified":1567532730804},{"_id":"themes/next/source/css/_common/components/tags/group-pictures.styl","hash":"2ad1a2a9bbf6742d1b0762c4c623b68113d1e0fe","modified":1567532730805},{"_id":"themes/next/source/css/_common/components/tags/label.styl","hash":"2ab1322fe52ab5aafd49e68f5bd890e8380ee927","modified":1567532730805},{"_id":"themes/next/source/css/_common/components/tags/note.styl","hash":"9a409b798decdefdaf7a23f0b11004a8c27e82f3","modified":1567532730806},{"_id":"themes/next/source/css/_common/components/tags/tags.styl","hash":"b80604868e4f5cf20fccafd7ee415c20c804f700","modified":1567532730807},{"_id":"themes/next/source/css/_common/components/tags/note-modern.styl","hash":"b7076e58d647265ee0ad2b461fe8ce72c9373bc5","modified":1567532730806},{"_id":"themes/next/source/css/_common/components/third-party/busuanzi-counter.styl","hash":"a6e7d698702c2e383dde3fde2abde27951679084","modified":1567532730807},{"_id":"themes/next/source/css/_common/components/third-party/baidushare.styl","hash":"5dbeed535d63a50265d96b396a5440f9bb31e4ba","modified":1567532730807},{"_id":"themes/next/source/css/_common/components/tags/tabs.styl","hash":"154a87a32d2fead480d5e909c37f6c476671c5e6","modified":1567532730806},{"_id":"themes/next/source/css/_common/components/third-party/algolia-search.styl","hash":"bba4f3bdb7517cd85376df3e1209b570c0548c69","modified":1567532730807},{"_id":"themes/next/source/css/_common/components/third-party/han.styl","hash":"10599e16414a8b7a76c4e79e6617b5fe3d4d1adf","modified":1567532730808},{"_id":"themes/next/source/css/_common/components/third-party/gitment.styl","hash":"874278147115601d2abf15987f5f7a84ada1ac6b","modified":1567532730808},{"_id":"themes/next/source/css/_common/components/third-party/duoshuo.styl","hash":"717cc7f82be9cc151e23a7678601ff2fd3a7fa1d","modified":1567532730808},{"_id":"themes/next/source/css/_common/components/third-party/localsearch.styl","hash":"16087276945fa038f199692e3eabb1c52b8ea633","modified":1567532730809},{"_id":"themes/next/source/css/_common/components/third-party/jiathis.styl","hash":"15975ba7456b96916b1dbac448a1a0d2c38b8f3d","modified":1567532730809},{"_id":"themes/next/source/css/_schemes/Mist/sidebar/sidebar-blogroll.styl","hash":"1f09be9bb38411f0629b58c3b23873589a6dbcaa","modified":1567532730816},{"_id":"themes/next/source/css/_common/components/third-party/third-party.styl","hash":"9c8196394a89dfa40b87bf0019e80144365a9c93","modified":1567532730809},{"_id":"themes/next/source/css/_common/components/third-party/needsharebutton.styl","hash":"28825ae15fa20ae3942cdaa7bcc1f3523ce59acc","modified":1567532730809},{"_id":"themes/next/source/css/_schemes/Muse/sidebar/sidebar-blogroll.styl","hash":"1f09be9bb38411f0629b58c3b23873589a6dbcaa","modified":1567532730818},{"_id":"themes/next/source/css/_schemes/Mist/outline/outline.styl","hash":"a07aa12cc36ac5c819670c2a3c17d07ed7a08986","modified":1567532730816},{"_id":"themes/next/source/lib/Han/dist/font/han-space.otf","hash":"07436f011b44051f61b8329c99de4bec64e86f4b","modified":1567532730831},{"_id":"themes/next/source/lib/Han/dist/font/han-space.woff","hash":"7a635062b10bf5662ae1d218ba0980171005d060","modified":1567532730831},{"_id":"themes/next/source/lib/Han/dist/font/han.woff","hash":"f38ff9b2eecaa17b50b66aa2dae87e9e7436d195","modified":1567532730831},{"_id":"themes/next/source/lib/Han/dist/font/han.otf","hash":"f1f6bb8f461f5672e000380195d3d2358a28494c","modified":1567532730831},{"_id":"themes/next/source/lib/fancybox/source/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1567532730845},{"_id":"themes/next/source/lib/Han/dist/font/han.woff2","hash":"623af3ed5423371ac136a4fe0e8cc7bb7396037a","modified":1567532730831},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","hash":"6394c48092085788a8c0ef72670b0652006231a1","modified":1567532730845},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","hash":"b88b589f5f1aa1b3d87cc7eef34c281ff749b1ae","modified":1567532730846},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.ttf","hash":"13b1eab65a983c7a73bc7997c479d66943f7c6cb","modified":1567532730862},{"_id":"themes/next/source/lib/font-awesome/fonts/FontAwesome.otf","hash":"048707bc52ac4b6563aaa383bfe8660a0ddc908c","modified":1567532730854},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","hash":"ee948b4489aedeb548a77c9e45d8c7c5732fd62d","modified":1567532730845},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-media.js","hash":"51139a4c79573d372a347ef01a493222a1eaf10a","modified":1567532730845},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","hash":"d22b1629cb23a6181bebb70d0cf653ffe4b835c8","modified":1567532730846},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1567532730856},{"_id":"themes/next/.git/objects/pack/pack-2094ec0f6437d1788a13f0aec9c47f4ed1a77de3.idx","hash":"6507e0cdf986f371d6d304387f789444a7663c56","modified":1567532730635},{"_id":"source/png/netty/netty线程模型.png","hash":"f918fa34bfc5639aa3e32558dac06711380c88f5","modified":1567698072022},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.js","hash":"90a1b22129efc172e2dfcceeeb76bff58bc3192f","modified":1567532730840},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.svg","hash":"b5483b11f8ba213e733b5b8af9927a04fec996f6","modified":1567532730860},{"_id":"themes/next/source/lib/three/three.min.js","hash":"26273b1cb4914850a89529b48091dc584f2c57b8","modified":1567532730879},{"_id":"themes/next/.git/objects/pack/pack-2094ec0f6437d1788a13f0aec9c47f4ed1a77de3.pack","hash":"2ab7a76d496119b851249983db6b500a45c77c47","modified":1567532730630},{"_id":"public/categories/index.html","hash":"fe89d77e22fa131697d3515995cf13fd023ff607","modified":1568130666614},{"_id":"public/tags/index.html","hash":"a89f1997e2a9fd4af45c570d5c3be70ec4c48d87","modified":1568130666614},{"_id":"public/archives/index.html","hash":"6742d3ac83c793e9b066d4fdecef23b49f3bb6c9","modified":1568130666615},{"_id":"public/archives/2019/index.html","hash":"ff49adddf0d98479205b049e0e10e408832bdae5","modified":1568130666615},{"_id":"public/tags/Netty/index.html","hash":"47e232a6eab5f6fba1fc8e76aaa4c9e82180aec8","modified":1568130666615},{"_id":"public/archives/2019/09/index.html","hash":"285541e593e3802956d6fb365dd5d6e837b28f12","modified":1568130666615},{"_id":"public/Netty浅析/index.html","hash":"742a524e9e758c1bfe46ca40f55faa18666f63d3","modified":1568134181761},{"_id":"public/index.html","hash":"18e24b51a2f71e02f2a4a093d6510a5acb54a61f","modified":1568134181760},{"_id":"public/tags/NIO/index.html","hash":"e3b8d0ddfee0f68d3399facbf6ac465890d9bdc2","modified":1568130666623},{"_id":"public/DirectBuffer垃圾回收/index.html","hash":"3925a9a5047c3556ab75959a07712809a5ea3818","modified":1568134181760},{"_id":"public/png/netty/channel&eventLoop.jpg","hash":"fe45f794698f2a887463c5c79032a8ec85b302b7","modified":1568130666623},{"_id":"public/png/netty/netty.png","hash":"ad6b3b294ac4485dc6c72ae4755fa73fb8b3516b","modified":1568130666623},{"_id":"public/png/netty/reactor模式.png","hash":"b3296b5a0ac09337dc5c264ec60b189353d4b3fb","modified":1568130666624},{"_id":"public/png/netty/主从模式reactor多线程模型.jpg","hash":"901c589ad67aa3dcd36f2058f57ec808251ce16a","modified":1568130666624},{"_id":"public/png/netty/单线程reactor模型.jpg","hash":"ca05fb6343b8f587aa20ba4c1e8677efe01816c1","modified":1568130666624},{"_id":"public/png/netty/ByteBuffer.png","hash":"68dec4a916987e5d0f042a1bd149a1afae81a272","modified":1568130666624},{"_id":"public/png/netty/多线程reactor模型.jpg","hash":"f5012c8d928989860a1ff734dfa96d50e067bd6c","modified":1568130666624},{"_id":"public/png/netty/discardReadBytes.png","hash":"b59b5db33799ea479b2f373e3c84f7b7136941c3","modified":1568130666624},{"_id":"public/png/netty/流-粘包.png","hash":"cbf461b16f7e4d8be2104abebf81c8c4ef8e95df","modified":1568130666624},{"_id":"public/png/netty/clear后的Buffer.png","hash":"5c1d2f643f5cd158bbf50f468a6e817b421a3581","modified":1568130666624},{"_id":"public/png/netty/流-拆包.png","hash":"6074251aed7623f2f074a403559229a21aea83a7","modified":1568130666624},{"_id":"public/png/netty/读写中间状态的Buffer.png","hash":"3a34f013db392abf98d2411d693854dd4501937b","modified":1568130666625},{"_id":"public/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1568130666625},{"_id":"public/images/cc-by-nc-nd.svg","hash":"bc3588c9b2d7c68830524783120ff6cf957cf668","modified":1568130666625},{"_id":"public/images/algolia_logo.svg","hash":"45eeea0b5fba833e21e38ea10ed5ab385ceb4f01","modified":1568130666625},{"_id":"public/images/cc-by-nc.svg","hash":"6f076713fb9bf934aa2c1046bdf2cf2e37bc1eab","modified":1568130666625},{"_id":"public/images/cc-by-nd.svg","hash":"42cd73da328077ccc92f859bb8f3cf621b3484f8","modified":1568130666625},{"_id":"public/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1568130666625},{"_id":"public/images/avatar.gif","hash":"264082bb3a1af70d5499c7d22b0902cb454b6d12","modified":1568130666625},{"_id":"public/images/loading.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1568130666625},{"_id":"public/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1568130666625},{"_id":"public/images/cc-by-sa.svg","hash":"70c1535f43e54e5ff35ca81419e77e4c0c301398","modified":1568130666625},{"_id":"public/images/cc-by-nc-sa.svg","hash":"6f55543d1fb9cbc436c101d24f802dec7b41efc3","modified":1568130666625},{"_id":"public/images/placeholder.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1568130666625},{"_id":"public/images/cc-by.svg","hash":"e92a33c32d1dac8ed94849b2b4e6456e887efe70","modified":1568130666626},{"_id":"public/images/searchicon.png","hash":"67727a6a969be0b2659b908518fa6706eed307b8","modified":1568130666626},{"_id":"public/images/quote-l.svg","hash":"cd108d6f44351cadf8e6742565217f88818a0458","modified":1568130666626},{"_id":"public/images/logo.svg","hash":"169f56fd82941591dad3abd734a50ec7259be950","modified":1568130666626},{"_id":"public/images/cc-zero.svg","hash":"9bfb52b2f63527a7049247bf00d44e6dc1170e7d","modified":1568130666626},{"_id":"public/images/quote-r.svg","hash":"2a2a250b32a87c69dcc1b1976c74b747bedbfb41","modified":1568130666626},{"_id":"public/lib/fastclick/LICENSE","hash":"6f474ea75c42442da7bbcf2e9143ce98258efd8d","modified":1568130666626},{"_id":"public/lib/font-awesome/HELP-US-OUT.txt","hash":"ee33b2798b1e714b904d663436c6b3521011d1fa","modified":1568130666626},{"_id":"public/lib/fancybox/source/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1568130666626},{"_id":"public/lib/fancybox/source/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1568130666626},{"_id":"public/lib/fancybox/source/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1568130666626},{"_id":"public/lib/fancybox/source/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1568130666626},{"_id":"public/lib/fancybox/source/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1568130666626},{"_id":"public/lib/fancybox/source/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1568130666627},{"_id":"public/lib/font-awesome/css/font-awesome.css.map","hash":"1573904b82807abbb32c97a3632c6c6808eaac50","modified":1568130667812},{"_id":"public/lib/Han/dist/font/han-space.otf","hash":"07436f011b44051f61b8329c99de4bec64e86f4b","modified":1568130667820},{"_id":"public/lib/Han/dist/font/han-space.woff","hash":"7a635062b10bf5662ae1d218ba0980171005d060","modified":1568130667823},{"_id":"public/lib/Han/dist/font/han.otf","hash":"f1f6bb8f461f5672e000380195d3d2358a28494c","modified":1568130667824},{"_id":"public/lib/Han/dist/font/han.woff","hash":"f38ff9b2eecaa17b50b66aa2dae87e9e7436d195","modified":1568130667824},{"_id":"public/lib/fancybox/source/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1568130667824},{"_id":"public/lib/Han/dist/font/han.woff2","hash":"623af3ed5423371ac136a4fe0e8cc7bb7396037a","modified":1568130667824},{"_id":"public/png/netty/channelPipeline.jpg","hash":"9da7a12635677014babd7c67effced6b7315dbb2","modified":1568130667824},{"_id":"public/js/src/bootstrap.js","hash":"034bc8113e0966fe2096ba5b56061bbf10ef0512","modified":1568130667840},{"_id":"public/js/src/affix.js","hash":"978e0422b5bf1b560236d8d10ebc1adcf66392e3","modified":1568130667841},{"_id":"public/js/src/exturl.js","hash":"e42e2aaab7bf4c19a0c8e779140e079c6aa5c0b1","modified":1568130667842},{"_id":"public/js/src/algolia-search.js","hash":"b172f697ed339a24b1e80261075232978d164c35","modified":1568130667842},{"_id":"public/js/src/js.cookie.js","hash":"9b37973a90fd50e71ea91682265715e45ae82c75","modified":1568130667842},{"_id":"public/js/src/post-details.js","hash":"a13f45f7aa8291cf7244ec5ba93907d119c5dbdd","modified":1568130667842},{"_id":"public/js/src/scrollspy.js","hash":"fe4da1b9fe73518226446f5f27d2831e4426fc35","modified":1568130667843},{"_id":"public/js/src/hook-duoshuo.js","hash":"a6119070c0119f33e08b29da7d2cce2635eb40a0","modified":1568130667843},{"_id":"public/lib/canvas-nest/canvas-nest.min.js","hash":"0387e75e23b1db108a755073fe52a0d03eb391a7","modified":1568130667843},{"_id":"public/js/src/scroll-cookie.js","hash":"09dc828cbf5f31158ff6250d2bf7c3cde6365c67","modified":1568130667843},{"_id":"public/lib/fastclick/bower.json","hash":"4dcecf83afddba148464d5339c93f6d0aa9f42e9","modified":1568130667843},{"_id":"public/lib/jquery_lazyload/bower.json","hash":"ae3c3b61e6e7f9e1d7e3585ad854380ecc04cf53","modified":1568130667843},{"_id":"public/lib/algolia-instant-search/instantsearch.min.css","hash":"90ef19edc982645b118b095615838d9c5eaba0de","modified":1568130667843},{"_id":"public/lib/font-awesome/bower.json","hash":"64394a2a9aa00f8e321d8daa5e51a420f0e96dad","modified":1568130667843},{"_id":"public/lib/canvas-ribbon/canvas-ribbon.js","hash":"ff5915eb2596e890a2fc6697c864f861a1995ec0","modified":1568130667843},{"_id":"public/lib/jquery_lazyload/jquery.scrollstop.js","hash":"0e9a81785a011c98be5ea821a8ed7d411818cfd1","modified":1568130667843},{"_id":"public/lib/pace/pace-theme-barber-shop.min.css","hash":"ee0d51446cb4ffe1bb96bd7bc8c8e046dddfcf46","modified":1568130667843},{"_id":"public/lib/pace/pace-theme-big-counter.min.css","hash":"5b561dc328af4c4d512e20a76fe964d113a32ba8","modified":1568130667843},{"_id":"public/lib/pace/pace-theme-center-atom.min.css","hash":"dcf79c24fe5350fb73d8038573a104e73639e9d3","modified":1568130667844},{"_id":"public/lib/needsharebutton/needsharebutton.css","hash":"3ef0020a1815ca6151ea4886cd0d37421ae3695c","modified":1568130667844},{"_id":"public/lib/pace/pace-theme-bounce.min.css","hash":"f6bdb9a785b7979dd8ec5c60e278af955ef1e585","modified":1568130667844},{"_id":"public/lib/pace/pace-theme-center-simple.min.css","hash":"67f44c947548bd4d77e7590d3f59e236cbf9e98a","modified":1568130667844},{"_id":"public/lib/pace/pace-theme-center-radar.min.css","hash":"ab7cba998bf4c03b13df342bf43647fa4f419783","modified":1568130667844},{"_id":"public/lib/pace/pace-theme-fill-left.min.css","hash":"0bec1e235a4a2cccda3f993b205424e1441a44ae","modified":1568130667844},{"_id":"public/lib/pace/pace-theme-center-circle.min.css","hash":"a4066769c78affbfbc5e30a600e2c7862cd532e0","modified":1568130667844},{"_id":"public/lib/pace/pace-theme-corner-indicator.min.css","hash":"b3c64c973f31884e3d8145989476707333406b9a","modified":1568130667844},{"_id":"public/lib/pace/pace-theme-flash.min.css","hash":"13ace22c40312d7bbd8d9c1e50eff897a7a497d8","modified":1568130667844},{"_id":"public/lib/pace/pace-theme-mac-osx.min.css","hash":"9f2e7b51b084da407863826b25265b31150b3821","modified":1568130667844},{"_id":"public/lib/pace/pace-theme-minimal.min.css","hash":"9cd783cceb8a191f3c8b5d81f7a430ecc3e489d3","modified":1568130667844},{"_id":"public/lib/velocity/bower.json","hash":"0ef14e7ccdfba5db6eb3f8fc6aa3b47282c36409","modified":1568130667844},{"_id":"public/lib/fancybox/source/jquery.fancybox.css","hash":"5f163444617b6cf267342f06ac166a237bb62df9","modified":1568130667845},{"_id":"public/lib/fastclick/README.html","hash":"c5a4c05ca80132b7e343d5fd1d1d1a976b4ad151","modified":1568130667845},{"_id":"public/lib/jquery_lazyload/README.html","hash":"18a600ca1aafd3bf08af52b6a6fe5f056aeed9f4","modified":1568130667845},{"_id":"public/lib/jquery_lazyload/CONTRIBUTING.html","hash":"81057e5b518b8ab60474e1ad027e868b558f15b7","modified":1568130667845},{"_id":"public/css/main.css","hash":"b0ddd7fd1b9b4b2588388f949081684d8b66f499","modified":1568130667845},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1568130667845},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1568130667845},{"_id":"public/lib/fastclick/lib/fastclick.min.js","hash":"2cae0f5a6c5d6f3cb993015e6863f9483fc4de18","modified":1568130667848},{"_id":"public/js/src/schemes/pisces.js","hash":"8050a5b2683d1d77238c5762b6bd89c543daed6e","modified":1568130667848},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1568130667849},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1568130667849},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","hash":"91e41741c2e93f732c82aaacec4cfc6e3f3ec876","modified":1568130667850},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","hash":"53e194f4a72e649c04fb586dd57762b8c022800b","modified":1568130667850},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-media.js","hash":"3bdf69ed2469e4fb57f5a95f17300eef891ff90d","modified":1568130667850},{"_id":"public/js/src/motion.js","hash":"754b294394f102c8fd9423a1789ddb1201677898","modified":1568130667850},{"_id":"public/js/src/utils.js","hash":"9b1325801d27213083d1487a12b1a62b539ab6f8","modified":1568130667850},{"_id":"public/lib/jquery_lazyload/jquery.lazyload.js","hash":"481fd478650e12b67c201a0ea41e92743f8b45a3","modified":1568130667850},{"_id":"public/lib/pace/pace-theme-loading-bar.min.css","hash":"7ee28875dfc1230d76c537f6605766e8d4011e9f","modified":1568130667850},{"_id":"public/lib/pace/pace.min.js","hash":"9944dfb7814b911090e96446cea4d36e2b487234","modified":1568130667850},{"_id":"public/lib/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1568130667850},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.ttf","hash":"13b1eab65a983c7a73bc7997c479d66943f7c6cb","modified":1568130667850},{"_id":"public/lib/font-awesome/fonts/FontAwesome.otf","hash":"048707bc52ac4b6563aaa383bfe8660a0ddc908c","modified":1568130667850},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1568130667851},{"_id":"public/lib/ua-parser-js/dist/ua-parser.pack.js","hash":"214dad442a92d36af77ed0ca1d9092b16687f02f","modified":1568130667851},{"_id":"public/lib/ua-parser-js/dist/ua-parser.min.js","hash":"38628e75e4412cc6f11074e03e1c6d257aae495b","modified":1568130667852},{"_id":"public/lib/needsharebutton/needsharebutton.js","hash":"9885fd9bea5e7ebafc5b1de9d17be5e106248d96","modified":1568130667852},{"_id":"public/lib/fancybox/source/jquery.fancybox.pack.js","hash":"53360764b429c212f424399384417ccc233bb3be","modified":1568130667890},{"_id":"public/lib/fastclick/lib/fastclick.js","hash":"06cef196733a710e77ad7e386ced6963f092dc55","modified":1568130667984},{"_id":"public/lib/font-awesome/css/font-awesome.min.css","hash":"512c7d79033e3028a9be61b540cf1a6870c896f8","modified":1568130667984},{"_id":"public/lib/three/canvas_lines.min.js","hash":"dce4a3b65f8bf958f973690caa7ec4952f353b0c","modified":1568130667985},{"_id":"public/lib/velocity/velocity.ui.js","hash":"6a1d101eab3de87527bb54fcc8c7b36b79d8f0df","modified":1568130667986},{"_id":"public/lib/three/canvas_sphere.min.js","hash":"d8ea241a53c135a650f7335d2b6982b899fd58a9","modified":1568130667986},{"_id":"public/lib/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1568130667986},{"_id":"public/lib/three/three-waves.min.js","hash":"d968cba6b3a50b3626a02d67b544f349d83b147c","modified":1568130667986},{"_id":"public/lib/Han/dist/han.min.js","hash":"f559c68a25065a14f47da954a7617d87263e409d","modified":1568130667987},{"_id":"public/lib/font-awesome/css/font-awesome.css","hash":"0140952c64e3f2b74ef64e050f2fe86eab6624c8","modified":1568130667987},{"_id":"public/lib/needsharebutton/font-embedded.css","hash":"c39d37278c1e178838732af21bd26cd0baeddfe0","modified":1568130667988},{"_id":"public/lib/Han/dist/han.min.css","hash":"a0c9e32549a8b8cf327ab9227b037f323cdb60ee","modified":1568130667988},{"_id":"public/lib/Han/dist/han.css","hash":"bd40da3fba8735df5850956814e312bd7b3193d7","modified":1568130668070},{"_id":"public/lib/fancybox/source/jquery.fancybox.js","hash":"1cf3d47b5ccb7cb6e9019c64f2a88d03a64853e4","modified":1568130668071},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.svg","hash":"b5483b11f8ba213e733b5b8af9927a04fec996f6","modified":1568130668136},{"_id":"public/lib/jquery/index.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1568130668206},{"_id":"public/png/netty/netty线程模型.png","hash":"f918fa34bfc5639aa3e32558dac06711380c88f5","modified":1568130668212},{"_id":"public/lib/Han/dist/han.js","hash":"e345397e0585c9fed1449e614ec13e0224acf2ab","modified":1568130668214},{"_id":"public/lib/velocity/velocity.js","hash":"9f08181baea0cc0e906703b7e5df9111b9ef3373","modified":1568130668231},{"_id":"public/lib/algolia-instant-search/instantsearch.min.js","hash":"9ccc6f8144f54e86df9a3fd33a18368d81cf3a4f","modified":1568130668246},{"_id":"public/lib/three/three.min.js","hash":"73f4cdc17e51a72b9bf5b9291f65386d615c483b","modified":1568130668259}],"Category":[],"Data":[],"Page":[{"title":"categories","date":"2019-09-05T17:05:15.000Z","comments":0,"_content":"","source":"categories/index.md","raw":"---\ntitle: categories\ndate: 2019-09-06 01:05:15\ncomments: false\n---\n","updated":"2019-09-05T17:05:42.794Z","path":"categories/index.html","layout":"page","_id":"ck0e0ico200008wudgboel1ue","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"标签","date":"2019-09-05T17:04:50.000Z","comments":0,"type":"tags","_content":"","source":"tags/index.md","raw":"---\ntitle: 标签\ndate: 2019-09-06 01:04:50\ncomments: false\ntype: \"tags\"\n---\n","updated":"2019-09-05T17:18:58.082Z","path":"tags/index.html","layout":"page","_id":"ck0e0ico700018wudhg5vjjt9","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"DirectBuffer垃圾回收","date":"2019-09-10T15:48:49.000Z","author":"Chopin","_content":"\n## 前言\n\n本文是笔者在研究DirectByteBuffer垃圾回收过程中引发的学习与探索。众所周知，DirectByteBuffer是一个管理直接内存的引用对象，直接内存不能通过JVM进行垃圾回收，只能通过DirectByteBuffer被回收时，调用相应的JNI方法来释放直接内存。\n\n由于垃圾回收本身成本较高，一般JVM在堆内存未耗尽时，不会进行垃圾回收操作。如果不断分配本地内存，堆内存很少使用，那么JVM就不需要执行GC，DirectByteBuffer对象们就不会被回收，这时候堆内存充足，但本地内存可能已经使用光了，再次尝试分配本地内存就会出现OutOfMemoryError，那程序就直接崩溃了。因此我们希望能够手工回收直接内存，于是对DirectByteBuffer被回收时如何释放直接内存进行研究。\n\n<!-- more -->\n\n```java\n    DirectByteBuffer(int cap) {                   // package-private\n        super(-1, 0, cap, cap);\n        boolean pa = VM.isDirectMemoryPageAligned();\n        int ps = Bits.pageSize();\n        long size = Math.max(1L, (long)cap + (pa ? ps : 0));\n        Bits.reserveMemory(size, cap);\n\n        long base = 0;\n        try {\n            base = unsafe.allocateMemory(size);\n        } catch (OutOfMemoryError x) {\n            Bits.unreserveMemory(size, cap);\n            throw x;\n        }\n        unsafe.setMemory(base, size, (byte) 0);\n        if (pa && (base % ps != 0)) {\n            // Round up to page boundary\n            address = base + ps - (base & (ps - 1));\n        } else {\n            address = base;\n        }\n    \n        cleaner = Cleaner.create(this, new Deallocator(base, size, cap));\n        att = null;\n    }\n```\n\n前面部分为分配内存地址，回收直接内存的关键在于\n\n```java\ncleaner = Cleaner.create(this, new Deallocator(base, size, cap));\n```\n\n## Cleaner\n\n我们看一下Cleaner这个类的源码\n\n```java\npublic class Cleaner extends PhantomReference<Object> {\n    private static final ReferenceQueue<Object> dummyQueue = new ReferenceQueue();\n    \n    /**\n     * 所有的cleaner都会被加到一个双向链表中去，这样做是为了保证在referent被回收之前\n     * 这些Cleaner都是存活的。\n     */\n    private static Cleaner first = null;\n    private Cleaner next = null;\n    private Cleaner prev = null;\n    \n    // 用户自定义的一个Runnable对象，\n    private final Runnable thunk;\n\n    // 构造的时候把自己加到双向链表中去\n    private static synchronized Cleaner add(Cleaner var0) {\n        if (first != null) {\n            var0.next = first;\n            first.prev = var0;\n        }\n\n        first = var0;\n        return var0;\n    }\n\n    // clean方法会调用remove把当前的cleaner从链表中删除。\n    private static synchronized boolean remove(Cleaner var0) {\n        if (var0.next == var0) {\n            return false;\n        } else {\n            if (first == var0) {\n                if (var0.next != null) {\n                    first = var0.next;\n                } else {\n                    first = var0.prev;\n                }\n            }\n\n            if (var0.next != null) {\n                var0.next.prev = var0.prev;\n            }\n\n            if (var0.prev != null) {\n                var0.prev.next = var0.next;\n            }\n\n            var0.next = var0;\n            var0.prev = var0;\n            return true;\n        }\n    }\n\n    // 私有有构造函数，保证了用户无法单独地使用new来创建Cleaner。\t\n    private Cleaner(Object var1, Runnable var2) {\n        super(var1, dummyQueue);\n        this.thunk = var2;\n    }\n\n    /**\n     * 所有的Cleaner都必须通过create方法进行创建。\n     */\n    public static Cleaner create(Object var0, Runnable var1) {\n        return var1 == null ? null : add(new Cleaner(var0, var1));\n    }\n\n    /**\n     * 这个方法会被Reference Handler线程调用，来清理资源。\n     */\n    public void clean() {\n        if (remove(this)) {\n            try {\n                this.thunk.run();\n            } catch (final Throwable var2) {\n                AccessController.doPrivileged(new PrivilegedAction<Void>() {\n                    public Void run() {\n                        if (System.err != null) {\n                            (new Error(\"Cleaner terminated abnormally\", \n                            \t\t\t\tvar2)).printStackTrace();\n                        }\n\n                        System.exit(1);\n                        return null;\n                    }\n                });\n            }\n\n        }\n    }\n}\n```\n\n1. Cleaner继承自PhantomReference（虚引用），它本质上仍然是一个Reference。所以它的处理方法与WeakReference，SoftReference十分相似。仍然是由GC标记，Reference Handler线程处理的。\n\n2. Reference的定义里新启的那个线程，它的run方法会专门判断从pending链表上取出来的那个对象是不是Cleaner，如果是就会调用它的clean方法。所以我们知道了，**Cleaner的clean方法是由Reference Handler线程调用的**。 \n\n   ```java\n   if (r instanceof Cleaner) {\n       ((Cleaner)r).clean();\n       continue;\n   }\n   ```\n\n3. Cleaner本身不带有清理逻辑，所有的逻辑都封装在thunk中，因此thunk是怎么实现的才是最关键。\n\n因此我们接着看DirectByteBuffer自定义的thunk方法 **Deallocator**\n\n```java\n    private static class Deallocator implements Runnable {\n\n        private static Unsafe unsafe = Unsafe.getUnsafe();\n\n        private long address;\n        private long size;\n        private int capacity;\n\n        private Deallocator(long address, long size, int capacity) {\n            assert (address != 0);\n            this.address = address;\n            this.size = size;\n            this.capacity = capacity;\n        }\n\n        public void run() {\n            if (address == 0) {\n                // Paranoia\n                return;\n            }\n            unsafe.freeMemory(address);\n            address = 0;\n            Bits.unreserveMemory(size, capacity);\n        }\n    }\n```\n\n1. 使用unsafe根据堆外内存的起始地址释放堆外内存；\n2. 根据当前DirectByte的size与cap修改在Bits中的统计信息，Bits类主要就是统计当前堆外内存的分配情况。\n\n只是研究如何手工回收DirectByteBuffer引用的直接内存空间到这里就可以了，DirectByteBuffer实现了DirectBuffer，而DirectBuffer本身是public的，所以通过接口去调用内部的Cleaner对象来做clean方法。\n\n```java\nif (byteBuffer.isDirect()) {\n    ((DirectBuffer)byteBuffer).cleaner().clean();\n}\n```\n\nNetty通过引用计数和池化来回收空间以及减少性能消耗，为不同类型的ByteBuf实现了不同的release方法，底层也是unsafe方法，对直接内存进行回收。\n\n**那JVM是如何自动回收直接内存的呢？**\n\n## PhantomReference\n\n上文提到\n\n> Cleaner继承自PhantomReference（虚引用），它本质上仍然是一个Reference。所以它的处理方法与WeakReference，SoftReference十分相似。仍然是由GC标记，Reference Handler线程处理的。\n\n### 引用类型\n\n这里比较一下Java的引用类型：强引用、软引用、弱引用、虚引用。\n\n引用对象是对JVM内存heap中Java对象的引用，通过软引用、弱引用、虚引用可以和GC做简单的交互。\n\nheap中对象有强可及对象、软可及对象、弱可及对象、虚可及对象和不可到达对象。引用的强弱顺序是强、软、弱、虚。对于对象是属于哪种可及的对象，由他的最强的引用决定。如下：\n\n```java\nString str = new String(\"abc\"); //1   \nSoftReference<String> softRef = new SoftReference<String>(str); //2   \nWeakReference<String> weakRef = new WeakReference<String>(str); //3   \nstr = null; //4   \nsoftRef.clear(); //5\n```\n\n第一行在heap对中创建内容为\"abc\"的对象，并建立abc到该对象的强引用,该对象是强可及的。\n\n第二行和第三行分别建立对heap中对象的软引用和弱引用，此时heap中的对象仍是强可及的。\n\n第四行之后heap中对象不再是强可及的，变成软可及的。同样第五行执行之后变成弱可及的。\n\n#### 强引用\n\n强引用是使用最普遍的引用。如果一个对象具有强引用，那垃圾回收器绝不会回收它。当内存空间不足，Java虚拟机宁愿抛出OutOfMemoryError错误，使程序异常终止，也不会靠随意回收具有强引用的对象来解决内存不足的问题。  \n\n```java\nObject o = new Object();   \nObject o1 = o;  \n```\n\n第一句是在heap中创建新的Object对象通过o引用这个对象，第二句是通过o建立o1到new Object()这个heap堆中的对象的引用，这两个引用都是强引用。只要存在对heap中对象的强引用，GC就不会收集该对象。\n\n#### 软引用\n\n软引用主要用于内存敏感的高速缓存。在JVM报告内存不足之前会清除所有的软引用，这样以来GC就有可能收集软可及的对象，可能解决内存吃紧问题，避免内存溢出。什么时候会被收集取决于GC的算法和GC运行时可用内存的大小。 \n\n以上面的代码为例，回收软可及对象步骤如下：\n\n1. 首先将softRef的referent设置为null，不再引用heap中的new String(\"abc\")对象。\n2. 将heap中的new String(\"abc\")对象设置为可结束的(finalizable)。\n3. 当heap中的new String(\"abc\")对象的finalize()方法被运行而且该对象占用的内存被释放， softRef被添加到它的ReferenceQueue中。\n\n使用示例：\n\n```java\nObject obj = new Object();\nSoftRefenrence sr = new SoftReference(obj);\nobj = null\n\n// 如果GC还未回收软引用\nif(sr != null){\n    obj = sr.get();\n}\n// 如果GC已回收软引用\nelse {\n    obj = new A();\n    sr = new SoftReference(obj);\n}\n```\n\n#### 弱引用\n\n如果一个对象只具有弱引用，那就类似于可有可无的生活用品。弱引用与软引用的区别在于：只具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存，然后Java虚拟机会把这个弱引用加入到与之关联的引用队列中。 不过，由于垃圾回收器是一个优先级很低的线程， 因此不一定会很快发现那些只具有弱引用的对象。 \n\n使用示例：\n\n```java\nObject obj = new Object();\nWeakReference wr = new WeakReference(obj);\nobj = null;\n\n//等待一段时间，heap中new Object()对象就会被垃圾回收\n...\n\nif (wr.get() == null) { \n    System.out.println(\"obj 已经被清除了\"); \n} else { \n    System.out.println(\"obj 尚未被清除，其信息是 \" + obj.toString());\n}\n```\n\n`WeakHashMap`和`ThreadLocal`都用了弱引用\n\n#### 虚引用\n\n虚引用并不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收。虚引用主要用来跟踪对象被垃圾回收的活动。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。程序可以通过判断引用队列中是否已经加入了虚引用，来了解被引用的对象是否将要被垃圾回收。程序如果发现某个虚引用已经被加入到引用队列，那么就可以在所引用的对象的内存被回收之前采取必要的行动。\n\n与软引用和弱引用不同，回收虚可及对象时，先把PhantomRefrence对象添加到它的ReferenceQueue中，然后再释放虚可及的对象。\n\nJVM回收直接内存就用到了虚引用。\n\n### Reference\n\nCleaner继承PhantomRefrence，PhantomRefrence继承Reference，Reference类的静态方法中启动了一个handler线程，代码如下\n\n```java\n    static {\n        ThreadGroup tg = Thread.currentThread().getThreadGroup();\n        for (ThreadGroup tgn = tg;\n             tgn != null;\n             tg = tgn, tgn = tg.getParent());\n        Thread handler = new ReferenceHandler(tg, \"Reference Handler\");\n        /* If there were a special system-only priority greater than\n         * MAX_PRIORITY, it would be used here\n         */\n        handler.setPriority(Thread.MAX_PRIORITY);\n        handler.setDaemon(true);\n        handler.start();\n    }\n```\n\n首先创建handler线程类，然后设置优先级，设置为守护线程，然后启动。 ReferenceHandler源码如下：\n\n```java\n    private static class ReferenceHandler extends Thread {\n\n        ReferenceHandler(ThreadGroup g, String name) {\n            super(g, name);\n        }\n\n        public void run() {\n            for (;;) {\n                Reference<Object> r;\n                synchronized (lock) {\n                    if (pending != null) {\n                        r = pending;\n                        pending = r.discovered;\n                        r.discovered = null;\n                    } else {\n                        // The waiting on the lock may cause an OOME because it may try to allocate\n                        // exception objects, so also catch OOME here to avoid silent exit of the\n                        // reference handler thread.\n                        //\n                        // Explicitly define the order of the two exceptions we catch here\n                        // when waiting for the lock.\n                        //\n                        // We do not want to try to potentially load the InterruptedException class\n                        // (which would be done if this was its first use, and InterruptedException\n                        // were checked first) in this situation.\n                        //\n                        // This may lead to the VM not ever trying to load the InterruptedException\n                        // class again.\n                        try {\n                            try {\n                                lock.wait();\n                            } catch (OutOfMemoryError x) { }\n                        } catch (InterruptedException x) { }\n                        continue;\n                    }\n                }\n\n                // Fast path for cleaners\n                if (r instanceof Cleaner) {\n                    ((Cleaner)r).clean();\n                    continue;\n                }\n\n                ReferenceQueue<Object> q = r.queue;\n                if (q != ReferenceQueue.NULL) q.enqueue(r);\n            }\n        }\n    }\n```\n\n1. 首先看pending是否有值，pending是JVM进行赋值的，当对象可达性变为不可达时会赋值到pending上；\n2. 如果pending有值，将pending的值赋给r，discoverd是下一个不可达的对象，赋值给pending；如果pending不存在值，等待pending有值；\n3. 判断r是不是Cleaner对象，是的话执行clean方法；\n4. 再将虚引用加入引用队列。\n\n\n\n参考链接：\n\nhttps://www.jianshu.com/p/6806ad95ed14\n\nhttps://zhuanlan.zhihu.com/p/29454205\n\nhttps://www.jianshu.com/p/825cca41d962\n\nhttps://www.jianshu.com/p/f86d3a43eec5","source":"_posts/DirectBuffer垃圾回收.md","raw":"---\ntitle: DirectBuffer垃圾回收\ndate: 2019-09-10 23:48:49\nauthor: Chopin\ntags:   #标签\n    - NIO\n---\n\n## 前言\n\n本文是笔者在研究DirectByteBuffer垃圾回收过程中引发的学习与探索。众所周知，DirectByteBuffer是一个管理直接内存的引用对象，直接内存不能通过JVM进行垃圾回收，只能通过DirectByteBuffer被回收时，调用相应的JNI方法来释放直接内存。\n\n由于垃圾回收本身成本较高，一般JVM在堆内存未耗尽时，不会进行垃圾回收操作。如果不断分配本地内存，堆内存很少使用，那么JVM就不需要执行GC，DirectByteBuffer对象们就不会被回收，这时候堆内存充足，但本地内存可能已经使用光了，再次尝试分配本地内存就会出现OutOfMemoryError，那程序就直接崩溃了。因此我们希望能够手工回收直接内存，于是对DirectByteBuffer被回收时如何释放直接内存进行研究。\n\n<!-- more -->\n\n```java\n    DirectByteBuffer(int cap) {                   // package-private\n        super(-1, 0, cap, cap);\n        boolean pa = VM.isDirectMemoryPageAligned();\n        int ps = Bits.pageSize();\n        long size = Math.max(1L, (long)cap + (pa ? ps : 0));\n        Bits.reserveMemory(size, cap);\n\n        long base = 0;\n        try {\n            base = unsafe.allocateMemory(size);\n        } catch (OutOfMemoryError x) {\n            Bits.unreserveMemory(size, cap);\n            throw x;\n        }\n        unsafe.setMemory(base, size, (byte) 0);\n        if (pa && (base % ps != 0)) {\n            // Round up to page boundary\n            address = base + ps - (base & (ps - 1));\n        } else {\n            address = base;\n        }\n    \n        cleaner = Cleaner.create(this, new Deallocator(base, size, cap));\n        att = null;\n    }\n```\n\n前面部分为分配内存地址，回收直接内存的关键在于\n\n```java\ncleaner = Cleaner.create(this, new Deallocator(base, size, cap));\n```\n\n## Cleaner\n\n我们看一下Cleaner这个类的源码\n\n```java\npublic class Cleaner extends PhantomReference<Object> {\n    private static final ReferenceQueue<Object> dummyQueue = new ReferenceQueue();\n    \n    /**\n     * 所有的cleaner都会被加到一个双向链表中去，这样做是为了保证在referent被回收之前\n     * 这些Cleaner都是存活的。\n     */\n    private static Cleaner first = null;\n    private Cleaner next = null;\n    private Cleaner prev = null;\n    \n    // 用户自定义的一个Runnable对象，\n    private final Runnable thunk;\n\n    // 构造的时候把自己加到双向链表中去\n    private static synchronized Cleaner add(Cleaner var0) {\n        if (first != null) {\n            var0.next = first;\n            first.prev = var0;\n        }\n\n        first = var0;\n        return var0;\n    }\n\n    // clean方法会调用remove把当前的cleaner从链表中删除。\n    private static synchronized boolean remove(Cleaner var0) {\n        if (var0.next == var0) {\n            return false;\n        } else {\n            if (first == var0) {\n                if (var0.next != null) {\n                    first = var0.next;\n                } else {\n                    first = var0.prev;\n                }\n            }\n\n            if (var0.next != null) {\n                var0.next.prev = var0.prev;\n            }\n\n            if (var0.prev != null) {\n                var0.prev.next = var0.next;\n            }\n\n            var0.next = var0;\n            var0.prev = var0;\n            return true;\n        }\n    }\n\n    // 私有有构造函数，保证了用户无法单独地使用new来创建Cleaner。\t\n    private Cleaner(Object var1, Runnable var2) {\n        super(var1, dummyQueue);\n        this.thunk = var2;\n    }\n\n    /**\n     * 所有的Cleaner都必须通过create方法进行创建。\n     */\n    public static Cleaner create(Object var0, Runnable var1) {\n        return var1 == null ? null : add(new Cleaner(var0, var1));\n    }\n\n    /**\n     * 这个方法会被Reference Handler线程调用，来清理资源。\n     */\n    public void clean() {\n        if (remove(this)) {\n            try {\n                this.thunk.run();\n            } catch (final Throwable var2) {\n                AccessController.doPrivileged(new PrivilegedAction<Void>() {\n                    public Void run() {\n                        if (System.err != null) {\n                            (new Error(\"Cleaner terminated abnormally\", \n                            \t\t\t\tvar2)).printStackTrace();\n                        }\n\n                        System.exit(1);\n                        return null;\n                    }\n                });\n            }\n\n        }\n    }\n}\n```\n\n1. Cleaner继承自PhantomReference（虚引用），它本质上仍然是一个Reference。所以它的处理方法与WeakReference，SoftReference十分相似。仍然是由GC标记，Reference Handler线程处理的。\n\n2. Reference的定义里新启的那个线程，它的run方法会专门判断从pending链表上取出来的那个对象是不是Cleaner，如果是就会调用它的clean方法。所以我们知道了，**Cleaner的clean方法是由Reference Handler线程调用的**。 \n\n   ```java\n   if (r instanceof Cleaner) {\n       ((Cleaner)r).clean();\n       continue;\n   }\n   ```\n\n3. Cleaner本身不带有清理逻辑，所有的逻辑都封装在thunk中，因此thunk是怎么实现的才是最关键。\n\n因此我们接着看DirectByteBuffer自定义的thunk方法 **Deallocator**\n\n```java\n    private static class Deallocator implements Runnable {\n\n        private static Unsafe unsafe = Unsafe.getUnsafe();\n\n        private long address;\n        private long size;\n        private int capacity;\n\n        private Deallocator(long address, long size, int capacity) {\n            assert (address != 0);\n            this.address = address;\n            this.size = size;\n            this.capacity = capacity;\n        }\n\n        public void run() {\n            if (address == 0) {\n                // Paranoia\n                return;\n            }\n            unsafe.freeMemory(address);\n            address = 0;\n            Bits.unreserveMemory(size, capacity);\n        }\n    }\n```\n\n1. 使用unsafe根据堆外内存的起始地址释放堆外内存；\n2. 根据当前DirectByte的size与cap修改在Bits中的统计信息，Bits类主要就是统计当前堆外内存的分配情况。\n\n只是研究如何手工回收DirectByteBuffer引用的直接内存空间到这里就可以了，DirectByteBuffer实现了DirectBuffer，而DirectBuffer本身是public的，所以通过接口去调用内部的Cleaner对象来做clean方法。\n\n```java\nif (byteBuffer.isDirect()) {\n    ((DirectBuffer)byteBuffer).cleaner().clean();\n}\n```\n\nNetty通过引用计数和池化来回收空间以及减少性能消耗，为不同类型的ByteBuf实现了不同的release方法，底层也是unsafe方法，对直接内存进行回收。\n\n**那JVM是如何自动回收直接内存的呢？**\n\n## PhantomReference\n\n上文提到\n\n> Cleaner继承自PhantomReference（虚引用），它本质上仍然是一个Reference。所以它的处理方法与WeakReference，SoftReference十分相似。仍然是由GC标记，Reference Handler线程处理的。\n\n### 引用类型\n\n这里比较一下Java的引用类型：强引用、软引用、弱引用、虚引用。\n\n引用对象是对JVM内存heap中Java对象的引用，通过软引用、弱引用、虚引用可以和GC做简单的交互。\n\nheap中对象有强可及对象、软可及对象、弱可及对象、虚可及对象和不可到达对象。引用的强弱顺序是强、软、弱、虚。对于对象是属于哪种可及的对象，由他的最强的引用决定。如下：\n\n```java\nString str = new String(\"abc\"); //1   \nSoftReference<String> softRef = new SoftReference<String>(str); //2   \nWeakReference<String> weakRef = new WeakReference<String>(str); //3   \nstr = null; //4   \nsoftRef.clear(); //5\n```\n\n第一行在heap对中创建内容为\"abc\"的对象，并建立abc到该对象的强引用,该对象是强可及的。\n\n第二行和第三行分别建立对heap中对象的软引用和弱引用，此时heap中的对象仍是强可及的。\n\n第四行之后heap中对象不再是强可及的，变成软可及的。同样第五行执行之后变成弱可及的。\n\n#### 强引用\n\n强引用是使用最普遍的引用。如果一个对象具有强引用，那垃圾回收器绝不会回收它。当内存空间不足，Java虚拟机宁愿抛出OutOfMemoryError错误，使程序异常终止，也不会靠随意回收具有强引用的对象来解决内存不足的问题。  \n\n```java\nObject o = new Object();   \nObject o1 = o;  \n```\n\n第一句是在heap中创建新的Object对象通过o引用这个对象，第二句是通过o建立o1到new Object()这个heap堆中的对象的引用，这两个引用都是强引用。只要存在对heap中对象的强引用，GC就不会收集该对象。\n\n#### 软引用\n\n软引用主要用于内存敏感的高速缓存。在JVM报告内存不足之前会清除所有的软引用，这样以来GC就有可能收集软可及的对象，可能解决内存吃紧问题，避免内存溢出。什么时候会被收集取决于GC的算法和GC运行时可用内存的大小。 \n\n以上面的代码为例，回收软可及对象步骤如下：\n\n1. 首先将softRef的referent设置为null，不再引用heap中的new String(\"abc\")对象。\n2. 将heap中的new String(\"abc\")对象设置为可结束的(finalizable)。\n3. 当heap中的new String(\"abc\")对象的finalize()方法被运行而且该对象占用的内存被释放， softRef被添加到它的ReferenceQueue中。\n\n使用示例：\n\n```java\nObject obj = new Object();\nSoftRefenrence sr = new SoftReference(obj);\nobj = null\n\n// 如果GC还未回收软引用\nif(sr != null){\n    obj = sr.get();\n}\n// 如果GC已回收软引用\nelse {\n    obj = new A();\n    sr = new SoftReference(obj);\n}\n```\n\n#### 弱引用\n\n如果一个对象只具有弱引用，那就类似于可有可无的生活用品。弱引用与软引用的区别在于：只具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存，然后Java虚拟机会把这个弱引用加入到与之关联的引用队列中。 不过，由于垃圾回收器是一个优先级很低的线程， 因此不一定会很快发现那些只具有弱引用的对象。 \n\n使用示例：\n\n```java\nObject obj = new Object();\nWeakReference wr = new WeakReference(obj);\nobj = null;\n\n//等待一段时间，heap中new Object()对象就会被垃圾回收\n...\n\nif (wr.get() == null) { \n    System.out.println(\"obj 已经被清除了\"); \n} else { \n    System.out.println(\"obj 尚未被清除，其信息是 \" + obj.toString());\n}\n```\n\n`WeakHashMap`和`ThreadLocal`都用了弱引用\n\n#### 虚引用\n\n虚引用并不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收。虚引用主要用来跟踪对象被垃圾回收的活动。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。程序可以通过判断引用队列中是否已经加入了虚引用，来了解被引用的对象是否将要被垃圾回收。程序如果发现某个虚引用已经被加入到引用队列，那么就可以在所引用的对象的内存被回收之前采取必要的行动。\n\n与软引用和弱引用不同，回收虚可及对象时，先把PhantomRefrence对象添加到它的ReferenceQueue中，然后再释放虚可及的对象。\n\nJVM回收直接内存就用到了虚引用。\n\n### Reference\n\nCleaner继承PhantomRefrence，PhantomRefrence继承Reference，Reference类的静态方法中启动了一个handler线程，代码如下\n\n```java\n    static {\n        ThreadGroup tg = Thread.currentThread().getThreadGroup();\n        for (ThreadGroup tgn = tg;\n             tgn != null;\n             tg = tgn, tgn = tg.getParent());\n        Thread handler = new ReferenceHandler(tg, \"Reference Handler\");\n        /* If there were a special system-only priority greater than\n         * MAX_PRIORITY, it would be used here\n         */\n        handler.setPriority(Thread.MAX_PRIORITY);\n        handler.setDaemon(true);\n        handler.start();\n    }\n```\n\n首先创建handler线程类，然后设置优先级，设置为守护线程，然后启动。 ReferenceHandler源码如下：\n\n```java\n    private static class ReferenceHandler extends Thread {\n\n        ReferenceHandler(ThreadGroup g, String name) {\n            super(g, name);\n        }\n\n        public void run() {\n            for (;;) {\n                Reference<Object> r;\n                synchronized (lock) {\n                    if (pending != null) {\n                        r = pending;\n                        pending = r.discovered;\n                        r.discovered = null;\n                    } else {\n                        // The waiting on the lock may cause an OOME because it may try to allocate\n                        // exception objects, so also catch OOME here to avoid silent exit of the\n                        // reference handler thread.\n                        //\n                        // Explicitly define the order of the two exceptions we catch here\n                        // when waiting for the lock.\n                        //\n                        // We do not want to try to potentially load the InterruptedException class\n                        // (which would be done if this was its first use, and InterruptedException\n                        // were checked first) in this situation.\n                        //\n                        // This may lead to the VM not ever trying to load the InterruptedException\n                        // class again.\n                        try {\n                            try {\n                                lock.wait();\n                            } catch (OutOfMemoryError x) { }\n                        } catch (InterruptedException x) { }\n                        continue;\n                    }\n                }\n\n                // Fast path for cleaners\n                if (r instanceof Cleaner) {\n                    ((Cleaner)r).clean();\n                    continue;\n                }\n\n                ReferenceQueue<Object> q = r.queue;\n                if (q != ReferenceQueue.NULL) q.enqueue(r);\n            }\n        }\n    }\n```\n\n1. 首先看pending是否有值，pending是JVM进行赋值的，当对象可达性变为不可达时会赋值到pending上；\n2. 如果pending有值，将pending的值赋给r，discoverd是下一个不可达的对象，赋值给pending；如果pending不存在值，等待pending有值；\n3. 判断r是不是Cleaner对象，是的话执行clean方法；\n4. 再将虚引用加入引用队列。\n\n\n\n参考链接：\n\nhttps://www.jianshu.com/p/6806ad95ed14\n\nhttps://zhuanlan.zhihu.com/p/29454205\n\nhttps://www.jianshu.com/p/825cca41d962\n\nhttps://www.jianshu.com/p/f86d3a43eec5","slug":"DirectBuffer垃圾回收","published":1,"updated":"2019-09-10T16:49:34.756Z","_id":"ck0e0icq800028wudm3q01bqn","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>本文是笔者在研究DirectByteBuffer垃圾回收过程中引发的学习与探索。众所周知，DirectByteBuffer是一个管理直接内存的引用对象，直接内存不能通过JVM进行垃圾回收，只能通过DirectByteBuffer被回收时，调用相应的JNI方法来释放直接内存。</p>\n<p>由于垃圾回收本身成本较高，一般JVM在堆内存未耗尽时，不会进行垃圾回收操作。如果不断分配本地内存，堆内存很少使用，那么JVM就不需要执行GC，DirectByteBuffer对象们就不会被回收，这时候堆内存充足，但本地内存可能已经使用光了，再次尝试分配本地内存就会出现OutOfMemoryError，那程序就直接崩溃了。因此我们希望能够手工回收直接内存，于是对DirectByteBuffer被回收时如何释放直接内存进行研究。</p>\n<a id=\"more\"></a>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">DirectByteBuffer(<span class=\"keyword\">int</span> cap) &#123;                   <span class=\"comment\">// package-private</span></span><br><span class=\"line\">    <span class=\"keyword\">super</span>(-<span class=\"number\">1</span>, <span class=\"number\">0</span>, cap, cap);</span><br><span class=\"line\">    <span class=\"keyword\">boolean</span> pa = VM.isDirectMemoryPageAligned();</span><br><span class=\"line\">    <span class=\"keyword\">int</span> ps = Bits.pageSize();</span><br><span class=\"line\">    <span class=\"keyword\">long</span> size = Math.max(<span class=\"number\">1L</span>, (<span class=\"keyword\">long</span>)cap + (pa ? ps : <span class=\"number\">0</span>));</span><br><span class=\"line\">    Bits.reserveMemory(size, cap);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">long</span> base = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        base = unsafe.allocateMemory(size);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (OutOfMemoryError x) &#123;</span><br><span class=\"line\">        Bits.unreserveMemory(size, cap);</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> x;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    unsafe.setMemory(base, size, (<span class=\"keyword\">byte</span>) <span class=\"number\">0</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (pa &amp;&amp; (base % ps != <span class=\"number\">0</span>)) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// Round up to page boundary</span></span><br><span class=\"line\">        address = base + ps - (base &amp; (ps - <span class=\"number\">1</span>));</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        address = base;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    cleaner = Cleaner.create(<span class=\"keyword\">this</span>, <span class=\"keyword\">new</span> Deallocator(base, size, cap));</span><br><span class=\"line\">    att = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>前面部分为分配内存地址，回收直接内存的关键在于</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cleaner = Cleaner.create(<span class=\"keyword\">this</span>, <span class=\"keyword\">new</span> Deallocator(base, size, cap));</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Cleaner\"><a href=\"#Cleaner\" class=\"headerlink\" title=\"Cleaner\"></a>Cleaner</h2><p>我们看一下Cleaner这个类的源码</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Cleaner</span> <span class=\"keyword\">extends</span> <span class=\"title\">PhantomReference</span>&lt;<span class=\"title\">Object</span>&gt; </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> ReferenceQueue&lt;Object&gt; dummyQueue = <span class=\"keyword\">new</span> ReferenceQueue();</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 所有的cleaner都会被加到一个双向链表中去，这样做是为了保证在referent被回收之前</span></span><br><span class=\"line\"><span class=\"comment\">     * 这些Cleaner都是存活的。</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Cleaner first = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Cleaner next = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Cleaner prev = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 用户自定义的一个Runnable对象，</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Runnable thunk;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 构造的时候把自己加到双向链表中去</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">synchronized</span> Cleaner <span class=\"title\">add</span><span class=\"params\">(Cleaner var0)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (first != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            var0.next = first;</span><br><span class=\"line\">            first.prev = var0;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        first = var0;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> var0;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// clean方法会调用remove把当前的cleaner从链表中删除。</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">boolean</span> <span class=\"title\">remove</span><span class=\"params\">(Cleaner var0)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (var0.next == var0) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (first == var0) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (var0.next != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                    first = var0.next;</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    first = var0.prev;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (var0.next != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                var0.next.prev = var0.prev;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (var0.prev != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                var0.prev.next = var0.next;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            var0.next = var0;</span><br><span class=\"line\">            var0.prev = var0;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 私有有构造函数，保证了用户无法单独地使用new来创建Cleaner。\t</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">Cleaner</span><span class=\"params\">(Object var1, Runnable var2)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>(var1, dummyQueue);</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.thunk = var2;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 所有的Cleaner都必须通过create方法进行创建。</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Cleaner <span class=\"title\">create</span><span class=\"params\">(Object var0, Runnable var1)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> var1 == <span class=\"keyword\">null</span> ? <span class=\"keyword\">null</span> : add(<span class=\"keyword\">new</span> Cleaner(var0, var1));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 这个方法会被Reference Handler线程调用，来清理资源。</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">clean</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (remove(<span class=\"keyword\">this</span>)) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">this</span>.thunk.run();</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (<span class=\"keyword\">final</span> Throwable var2) &#123;</span><br><span class=\"line\">                AccessController.doPrivileged(<span class=\"keyword\">new</span> PrivilegedAction&lt;Void&gt;() &#123;</span><br><span class=\"line\">                    <span class=\"function\"><span class=\"keyword\">public</span> Void <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">                        <span class=\"keyword\">if</span> (System.err != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                            (<span class=\"keyword\">new</span> Error(<span class=\"string\">\"Cleaner terminated abnormally\"</span>, </span><br><span class=\"line\">                            \t\t\t\tvar2)).printStackTrace();</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                        System.exit(<span class=\"number\">1</span>);</span><br><span class=\"line\">                        <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol>\n<li><p>Cleaner继承自PhantomReference（虚引用），它本质上仍然是一个Reference。所以它的处理方法与WeakReference，SoftReference十分相似。仍然是由GC标记，Reference Handler线程处理的。</p>\n</li>\n<li><p>Reference的定义里新启的那个线程，它的run方法会专门判断从pending链表上取出来的那个对象是不是Cleaner，如果是就会调用它的clean方法。所以我们知道了，<strong>Cleaner的clean方法是由Reference Handler线程调用的</strong>。 </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (r <span class=\"keyword\">instanceof</span> Cleaner) &#123;</span><br><span class=\"line\">    ((Cleaner)r).clean();</span><br><span class=\"line\">    <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>Cleaner本身不带有清理逻辑，所有的逻辑都封装在thunk中，因此thunk是怎么实现的才是最关键。</p>\n</li>\n</ol>\n<p>因此我们接着看DirectByteBuffer自定义的thunk方法 <strong>Deallocator</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Deallocator</span> <span class=\"keyword\">implements</span> <span class=\"title\">Runnable</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Unsafe unsafe = Unsafe.getUnsafe();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">long</span> address;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">long</span> size;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> capacity;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">Deallocator</span><span class=\"params\">(<span class=\"keyword\">long</span> address, <span class=\"keyword\">long</span> size, <span class=\"keyword\">int</span> capacity)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">assert</span> (address != <span class=\"number\">0</span>);</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.address = address;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.size = size;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.capacity = capacity;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (address == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// Paranoia</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        unsafe.freeMemory(address);</span><br><span class=\"line\">        address = <span class=\"number\">0</span>;</span><br><span class=\"line\">        Bits.unreserveMemory(size, capacity);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol>\n<li>使用unsafe根据堆外内存的起始地址释放堆外内存；</li>\n<li>根据当前DirectByte的size与cap修改在Bits中的统计信息，Bits类主要就是统计当前堆外内存的分配情况。</li>\n</ol>\n<p>只是研究如何手工回收DirectByteBuffer引用的直接内存空间到这里就可以了，DirectByteBuffer实现了DirectBuffer，而DirectBuffer本身是public的，所以通过接口去调用内部的Cleaner对象来做clean方法。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (byteBuffer.isDirect()) &#123;</span><br><span class=\"line\">    ((DirectBuffer)byteBuffer).cleaner().clean();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>Netty通过引用计数和池化来回收空间以及减少性能消耗，为不同类型的ByteBuf实现了不同的release方法，底层也是unsafe方法，对直接内存进行回收。</p>\n<p><strong>那JVM是如何自动回收直接内存的呢？</strong></p>\n<h2 id=\"PhantomReference\"><a href=\"#PhantomReference\" class=\"headerlink\" title=\"PhantomReference\"></a>PhantomReference</h2><p>上文提到</p>\n<blockquote>\n<p>Cleaner继承自PhantomReference（虚引用），它本质上仍然是一个Reference。所以它的处理方法与WeakReference，SoftReference十分相似。仍然是由GC标记，Reference Handler线程处理的。</p>\n</blockquote>\n<h3 id=\"引用类型\"><a href=\"#引用类型\" class=\"headerlink\" title=\"引用类型\"></a>引用类型</h3><p>这里比较一下Java的引用类型：强引用、软引用、弱引用、虚引用。</p>\n<p>引用对象是对JVM内存heap中Java对象的引用，通过软引用、弱引用、虚引用可以和GC做简单的交互。</p>\n<p>heap中对象有强可及对象、软可及对象、弱可及对象、虚可及对象和不可到达对象。引用的强弱顺序是强、软、弱、虚。对于对象是属于哪种可及的对象，由他的最强的引用决定。如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">String str = <span class=\"keyword\">new</span> String(<span class=\"string\">\"abc\"</span>); <span class=\"comment\">//1   </span></span><br><span class=\"line\">SoftReference&lt;String&gt; softRef = <span class=\"keyword\">new</span> SoftReference&lt;String&gt;(str); <span class=\"comment\">//2   </span></span><br><span class=\"line\">WeakReference&lt;String&gt; weakRef = <span class=\"keyword\">new</span> WeakReference&lt;String&gt;(str); <span class=\"comment\">//3   </span></span><br><span class=\"line\">str = <span class=\"keyword\">null</span>; <span class=\"comment\">//4   </span></span><br><span class=\"line\">softRef.clear(); <span class=\"comment\">//5</span></span><br></pre></td></tr></table></figure>\n\n<p>第一行在heap对中创建内容为”abc”的对象，并建立abc到该对象的强引用,该对象是强可及的。</p>\n<p>第二行和第三行分别建立对heap中对象的软引用和弱引用，此时heap中的对象仍是强可及的。</p>\n<p>第四行之后heap中对象不再是强可及的，变成软可及的。同样第五行执行之后变成弱可及的。</p>\n<h4 id=\"强引用\"><a href=\"#强引用\" class=\"headerlink\" title=\"强引用\"></a>强引用</h4><p>强引用是使用最普遍的引用。如果一个对象具有强引用，那垃圾回收器绝不会回收它。当内存空间不足，Java虚拟机宁愿抛出OutOfMemoryError错误，使程序异常终止，也不会靠随意回收具有强引用的对象来解决内存不足的问题。  </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Object o = <span class=\"keyword\">new</span> Object();   </span><br><span class=\"line\">Object o1 = o;</span><br></pre></td></tr></table></figure>\n\n<p>第一句是在heap中创建新的Object对象通过o引用这个对象，第二句是通过o建立o1到new Object()这个heap堆中的对象的引用，这两个引用都是强引用。只要存在对heap中对象的强引用，GC就不会收集该对象。</p>\n<h4 id=\"软引用\"><a href=\"#软引用\" class=\"headerlink\" title=\"软引用\"></a>软引用</h4><p>软引用主要用于内存敏感的高速缓存。在JVM报告内存不足之前会清除所有的软引用，这样以来GC就有可能收集软可及的对象，可能解决内存吃紧问题，避免内存溢出。什么时候会被收集取决于GC的算法和GC运行时可用内存的大小。 </p>\n<p>以上面的代码为例，回收软可及对象步骤如下：</p>\n<ol>\n<li>首先将softRef的referent设置为null，不再引用heap中的new String(“abc”)对象。</li>\n<li>将heap中的new String(“abc”)对象设置为可结束的(finalizable)。</li>\n<li>当heap中的new String(“abc”)对象的finalize()方法被运行而且该对象占用的内存被释放， softRef被添加到它的ReferenceQueue中。</li>\n</ol>\n<p>使用示例：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Object obj = <span class=\"keyword\">new</span> Object();</span><br><span class=\"line\">SoftRefenrence sr = <span class=\"keyword\">new</span> SoftReference(obj);</span><br><span class=\"line\">obj = <span class=\"keyword\">null</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 如果GC还未回收软引用</span></span><br><span class=\"line\"><span class=\"keyword\">if</span>(sr != <span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">    obj = sr.get();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 如果GC已回收软引用</span></span><br><span class=\"line\"><span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    obj = <span class=\"keyword\">new</span> A();</span><br><span class=\"line\">    sr = <span class=\"keyword\">new</span> SoftReference(obj);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"弱引用\"><a href=\"#弱引用\" class=\"headerlink\" title=\"弱引用\"></a>弱引用</h4><p>如果一个对象只具有弱引用，那就类似于可有可无的生活用品。弱引用与软引用的区别在于：只具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存，然后Java虚拟机会把这个弱引用加入到与之关联的引用队列中。 不过，由于垃圾回收器是一个优先级很低的线程， 因此不一定会很快发现那些只具有弱引用的对象。 </p>\n<p>使用示例：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Object obj = <span class=\"keyword\">new</span> Object();</span><br><span class=\"line\">WeakReference wr = <span class=\"keyword\">new</span> WeakReference(obj);</span><br><span class=\"line\">obj = <span class=\"keyword\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//等待一段时间，heap中new Object()对象就会被垃圾回收</span></span><br><span class=\"line\">...</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> (wr.get() == <span class=\"keyword\">null</span>) &#123; </span><br><span class=\"line\">    System.out.println(<span class=\"string\">\"obj 已经被清除了\"</span>); </span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> &#123; </span><br><span class=\"line\">    System.out.println(<span class=\"string\">\"obj 尚未被清除，其信息是 \"</span> + obj.toString());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>WeakHashMap</code>和<code>ThreadLocal</code>都用了弱引用</p>\n<h4 id=\"虚引用\"><a href=\"#虚引用\" class=\"headerlink\" title=\"虚引用\"></a>虚引用</h4><p>虚引用并不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收。虚引用主要用来跟踪对象被垃圾回收的活动。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。程序可以通过判断引用队列中是否已经加入了虚引用，来了解被引用的对象是否将要被垃圾回收。程序如果发现某个虚引用已经被加入到引用队列，那么就可以在所引用的对象的内存被回收之前采取必要的行动。</p>\n<p>与软引用和弱引用不同，回收虚可及对象时，先把PhantomRefrence对象添加到它的ReferenceQueue中，然后再释放虚可及的对象。</p>\n<p>JVM回收直接内存就用到了虚引用。</p>\n<h3 id=\"Reference\"><a href=\"#Reference\" class=\"headerlink\" title=\"Reference\"></a>Reference</h3><p>Cleaner继承PhantomRefrence，PhantomRefrence继承Reference，Reference类的静态方法中启动了一个handler线程，代码如下</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> &#123;</span><br><span class=\"line\">    ThreadGroup tg = Thread.currentThread().getThreadGroup();</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (ThreadGroup tgn = tg;</span><br><span class=\"line\">         tgn != <span class=\"keyword\">null</span>;</span><br><span class=\"line\">         tg = tgn, tgn = tg.getParent());</span><br><span class=\"line\">    Thread handler = <span class=\"keyword\">new</span> ReferenceHandler(tg, <span class=\"string\">\"Reference Handler\"</span>);</span><br><span class=\"line\">    <span class=\"comment\">/* If there were a special system-only priority greater than</span></span><br><span class=\"line\"><span class=\"comment\">     * MAX_PRIORITY, it would be used here</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    handler.setPriority(Thread.MAX_PRIORITY);</span><br><span class=\"line\">    handler.setDaemon(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">    handler.start();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>首先创建handler线程类，然后设置优先级，设置为守护线程，然后启动。 ReferenceHandler源码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ReferenceHandler</span> <span class=\"keyword\">extends</span> <span class=\"title\">Thread</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    ReferenceHandler(ThreadGroup g, String name) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>(g, name);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (;;) &#123;</span><br><span class=\"line\">            Reference&lt;Object&gt; r;</span><br><span class=\"line\">            <span class=\"keyword\">synchronized</span> (lock) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (pending != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                    r = pending;</span><br><span class=\"line\">                    pending = r.discovered;</span><br><span class=\"line\">                    r.discovered = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// The waiting on the lock may cause an OOME because it may try to allocate</span></span><br><span class=\"line\">                    <span class=\"comment\">// exception objects, so also catch OOME here to avoid silent exit of the</span></span><br><span class=\"line\">                    <span class=\"comment\">// reference handler thread.</span></span><br><span class=\"line\">                    <span class=\"comment\">//</span></span><br><span class=\"line\">                    <span class=\"comment\">// Explicitly define the order of the two exceptions we catch here</span></span><br><span class=\"line\">                    <span class=\"comment\">// when waiting for the lock.</span></span><br><span class=\"line\">                    <span class=\"comment\">//</span></span><br><span class=\"line\">                    <span class=\"comment\">// We do not want to try to potentially load the InterruptedException class</span></span><br><span class=\"line\">                    <span class=\"comment\">// (which would be done if this was its first use, and InterruptedException</span></span><br><span class=\"line\">                    <span class=\"comment\">// were checked first) in this situation.</span></span><br><span class=\"line\">                    <span class=\"comment\">//</span></span><br><span class=\"line\">                    <span class=\"comment\">// This may lead to the VM not ever trying to load the InterruptedException</span></span><br><span class=\"line\">                    <span class=\"comment\">// class again.</span></span><br><span class=\"line\">                    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                            lock.wait();</span><br><span class=\"line\">                        &#125; <span class=\"keyword\">catch</span> (OutOfMemoryError x) &#123; &#125;</span><br><span class=\"line\">                    &#125; <span class=\"keyword\">catch</span> (InterruptedException x) &#123; &#125;</span><br><span class=\"line\">                    <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// Fast path for cleaners</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (r <span class=\"keyword\">instanceof</span> Cleaner) &#123;</span><br><span class=\"line\">                ((Cleaner)r).clean();</span><br><span class=\"line\">                <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            ReferenceQueue&lt;Object&gt; q = r.queue;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (q != ReferenceQueue.NULL) q.enqueue(r);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol>\n<li>首先看pending是否有值，pending是JVM进行赋值的，当对象可达性变为不可达时会赋值到pending上；</li>\n<li>如果pending有值，将pending的值赋给r，discoverd是下一个不可达的对象，赋值给pending；如果pending不存在值，等待pending有值；</li>\n<li>判断r是不是Cleaner对象，是的话执行clean方法；</li>\n<li>再将虚引用加入引用队列。</li>\n</ol>\n<p>参考链接：</p>\n<p><a href=\"https://www.jianshu.com/p/6806ad95ed14\" target=\"_blank\" rel=\"noopener\">https://www.jianshu.com/p/6806ad95ed14</a></p>\n<p><a href=\"https://zhuanlan.zhihu.com/p/29454205\" target=\"_blank\" rel=\"noopener\">https://zhuanlan.zhihu.com/p/29454205</a></p>\n<p><a href=\"https://www.jianshu.com/p/825cca41d962\" target=\"_blank\" rel=\"noopener\">https://www.jianshu.com/p/825cca41d962</a></p>\n<p><a href=\"https://www.jianshu.com/p/f86d3a43eec5\" target=\"_blank\" rel=\"noopener\">https://www.jianshu.com/p/f86d3a43eec5</a></p>\n","site":{"data":{}},"excerpt":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>本文是笔者在研究DirectByteBuffer垃圾回收过程中引发的学习与探索。众所周知，DirectByteBuffer是一个管理直接内存的引用对象，直接内存不能通过JVM进行垃圾回收，只能通过DirectByteBuffer被回收时，调用相应的JNI方法来释放直接内存。</p>\n<p>由于垃圾回收本身成本较高，一般JVM在堆内存未耗尽时，不会进行垃圾回收操作。如果不断分配本地内存，堆内存很少使用，那么JVM就不需要执行GC，DirectByteBuffer对象们就不会被回收，这时候堆内存充足，但本地内存可能已经使用光了，再次尝试分配本地内存就会出现OutOfMemoryError，那程序就直接崩溃了。因此我们希望能够手工回收直接内存，于是对DirectByteBuffer被回收时如何释放直接内存进行研究。</p>","more":"<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">DirectByteBuffer(<span class=\"keyword\">int</span> cap) &#123;                   <span class=\"comment\">// package-private</span></span><br><span class=\"line\">    <span class=\"keyword\">super</span>(-<span class=\"number\">1</span>, <span class=\"number\">0</span>, cap, cap);</span><br><span class=\"line\">    <span class=\"keyword\">boolean</span> pa = VM.isDirectMemoryPageAligned();</span><br><span class=\"line\">    <span class=\"keyword\">int</span> ps = Bits.pageSize();</span><br><span class=\"line\">    <span class=\"keyword\">long</span> size = Math.max(<span class=\"number\">1L</span>, (<span class=\"keyword\">long</span>)cap + (pa ? ps : <span class=\"number\">0</span>));</span><br><span class=\"line\">    Bits.reserveMemory(size, cap);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">long</span> base = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        base = unsafe.allocateMemory(size);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (OutOfMemoryError x) &#123;</span><br><span class=\"line\">        Bits.unreserveMemory(size, cap);</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> x;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    unsafe.setMemory(base, size, (<span class=\"keyword\">byte</span>) <span class=\"number\">0</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (pa &amp;&amp; (base % ps != <span class=\"number\">0</span>)) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// Round up to page boundary</span></span><br><span class=\"line\">        address = base + ps - (base &amp; (ps - <span class=\"number\">1</span>));</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        address = base;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    cleaner = Cleaner.create(<span class=\"keyword\">this</span>, <span class=\"keyword\">new</span> Deallocator(base, size, cap));</span><br><span class=\"line\">    att = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>前面部分为分配内存地址，回收直接内存的关键在于</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cleaner = Cleaner.create(<span class=\"keyword\">this</span>, <span class=\"keyword\">new</span> Deallocator(base, size, cap));</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Cleaner\"><a href=\"#Cleaner\" class=\"headerlink\" title=\"Cleaner\"></a>Cleaner</h2><p>我们看一下Cleaner这个类的源码</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Cleaner</span> <span class=\"keyword\">extends</span> <span class=\"title\">PhantomReference</span>&lt;<span class=\"title\">Object</span>&gt; </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> ReferenceQueue&lt;Object&gt; dummyQueue = <span class=\"keyword\">new</span> ReferenceQueue();</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 所有的cleaner都会被加到一个双向链表中去，这样做是为了保证在referent被回收之前</span></span><br><span class=\"line\"><span class=\"comment\">     * 这些Cleaner都是存活的。</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Cleaner first = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Cleaner next = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Cleaner prev = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 用户自定义的一个Runnable对象，</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Runnable thunk;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 构造的时候把自己加到双向链表中去</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">synchronized</span> Cleaner <span class=\"title\">add</span><span class=\"params\">(Cleaner var0)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (first != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            var0.next = first;</span><br><span class=\"line\">            first.prev = var0;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        first = var0;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> var0;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// clean方法会调用remove把当前的cleaner从链表中删除。</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">boolean</span> <span class=\"title\">remove</span><span class=\"params\">(Cleaner var0)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (var0.next == var0) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (first == var0) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (var0.next != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                    first = var0.next;</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    first = var0.prev;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (var0.next != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                var0.next.prev = var0.prev;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (var0.prev != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                var0.prev.next = var0.next;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            var0.next = var0;</span><br><span class=\"line\">            var0.prev = var0;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 私有有构造函数，保证了用户无法单独地使用new来创建Cleaner。\t</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">Cleaner</span><span class=\"params\">(Object var1, Runnable var2)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>(var1, dummyQueue);</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.thunk = var2;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 所有的Cleaner都必须通过create方法进行创建。</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Cleaner <span class=\"title\">create</span><span class=\"params\">(Object var0, Runnable var1)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> var1 == <span class=\"keyword\">null</span> ? <span class=\"keyword\">null</span> : add(<span class=\"keyword\">new</span> Cleaner(var0, var1));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 这个方法会被Reference Handler线程调用，来清理资源。</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">clean</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (remove(<span class=\"keyword\">this</span>)) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">this</span>.thunk.run();</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (<span class=\"keyword\">final</span> Throwable var2) &#123;</span><br><span class=\"line\">                AccessController.doPrivileged(<span class=\"keyword\">new</span> PrivilegedAction&lt;Void&gt;() &#123;</span><br><span class=\"line\">                    <span class=\"function\"><span class=\"keyword\">public</span> Void <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">                        <span class=\"keyword\">if</span> (System.err != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                            (<span class=\"keyword\">new</span> Error(<span class=\"string\">\"Cleaner terminated abnormally\"</span>, </span><br><span class=\"line\">                            \t\t\t\tvar2)).printStackTrace();</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                        System.exit(<span class=\"number\">1</span>);</span><br><span class=\"line\">                        <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol>\n<li><p>Cleaner继承自PhantomReference（虚引用），它本质上仍然是一个Reference。所以它的处理方法与WeakReference，SoftReference十分相似。仍然是由GC标记，Reference Handler线程处理的。</p>\n</li>\n<li><p>Reference的定义里新启的那个线程，它的run方法会专门判断从pending链表上取出来的那个对象是不是Cleaner，如果是就会调用它的clean方法。所以我们知道了，<strong>Cleaner的clean方法是由Reference Handler线程调用的</strong>。 </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (r <span class=\"keyword\">instanceof</span> Cleaner) &#123;</span><br><span class=\"line\">    ((Cleaner)r).clean();</span><br><span class=\"line\">    <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>Cleaner本身不带有清理逻辑，所有的逻辑都封装在thunk中，因此thunk是怎么实现的才是最关键。</p>\n</li>\n</ol>\n<p>因此我们接着看DirectByteBuffer自定义的thunk方法 <strong>Deallocator</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Deallocator</span> <span class=\"keyword\">implements</span> <span class=\"title\">Runnable</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Unsafe unsafe = Unsafe.getUnsafe();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">long</span> address;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">long</span> size;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> capacity;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">Deallocator</span><span class=\"params\">(<span class=\"keyword\">long</span> address, <span class=\"keyword\">long</span> size, <span class=\"keyword\">int</span> capacity)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">assert</span> (address != <span class=\"number\">0</span>);</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.address = address;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.size = size;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.capacity = capacity;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (address == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// Paranoia</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        unsafe.freeMemory(address);</span><br><span class=\"line\">        address = <span class=\"number\">0</span>;</span><br><span class=\"line\">        Bits.unreserveMemory(size, capacity);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol>\n<li>使用unsafe根据堆外内存的起始地址释放堆外内存；</li>\n<li>根据当前DirectByte的size与cap修改在Bits中的统计信息，Bits类主要就是统计当前堆外内存的分配情况。</li>\n</ol>\n<p>只是研究如何手工回收DirectByteBuffer引用的直接内存空间到这里就可以了，DirectByteBuffer实现了DirectBuffer，而DirectBuffer本身是public的，所以通过接口去调用内部的Cleaner对象来做clean方法。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (byteBuffer.isDirect()) &#123;</span><br><span class=\"line\">    ((DirectBuffer)byteBuffer).cleaner().clean();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>Netty通过引用计数和池化来回收空间以及减少性能消耗，为不同类型的ByteBuf实现了不同的release方法，底层也是unsafe方法，对直接内存进行回收。</p>\n<p><strong>那JVM是如何自动回收直接内存的呢？</strong></p>\n<h2 id=\"PhantomReference\"><a href=\"#PhantomReference\" class=\"headerlink\" title=\"PhantomReference\"></a>PhantomReference</h2><p>上文提到</p>\n<blockquote>\n<p>Cleaner继承自PhantomReference（虚引用），它本质上仍然是一个Reference。所以它的处理方法与WeakReference，SoftReference十分相似。仍然是由GC标记，Reference Handler线程处理的。</p>\n</blockquote>\n<h3 id=\"引用类型\"><a href=\"#引用类型\" class=\"headerlink\" title=\"引用类型\"></a>引用类型</h3><p>这里比较一下Java的引用类型：强引用、软引用、弱引用、虚引用。</p>\n<p>引用对象是对JVM内存heap中Java对象的引用，通过软引用、弱引用、虚引用可以和GC做简单的交互。</p>\n<p>heap中对象有强可及对象、软可及对象、弱可及对象、虚可及对象和不可到达对象。引用的强弱顺序是强、软、弱、虚。对于对象是属于哪种可及的对象，由他的最强的引用决定。如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">String str = <span class=\"keyword\">new</span> String(<span class=\"string\">\"abc\"</span>); <span class=\"comment\">//1   </span></span><br><span class=\"line\">SoftReference&lt;String&gt; softRef = <span class=\"keyword\">new</span> SoftReference&lt;String&gt;(str); <span class=\"comment\">//2   </span></span><br><span class=\"line\">WeakReference&lt;String&gt; weakRef = <span class=\"keyword\">new</span> WeakReference&lt;String&gt;(str); <span class=\"comment\">//3   </span></span><br><span class=\"line\">str = <span class=\"keyword\">null</span>; <span class=\"comment\">//4   </span></span><br><span class=\"line\">softRef.clear(); <span class=\"comment\">//5</span></span><br></pre></td></tr></table></figure>\n\n<p>第一行在heap对中创建内容为”abc”的对象，并建立abc到该对象的强引用,该对象是强可及的。</p>\n<p>第二行和第三行分别建立对heap中对象的软引用和弱引用，此时heap中的对象仍是强可及的。</p>\n<p>第四行之后heap中对象不再是强可及的，变成软可及的。同样第五行执行之后变成弱可及的。</p>\n<h4 id=\"强引用\"><a href=\"#强引用\" class=\"headerlink\" title=\"强引用\"></a>强引用</h4><p>强引用是使用最普遍的引用。如果一个对象具有强引用，那垃圾回收器绝不会回收它。当内存空间不足，Java虚拟机宁愿抛出OutOfMemoryError错误，使程序异常终止，也不会靠随意回收具有强引用的对象来解决内存不足的问题。  </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Object o = <span class=\"keyword\">new</span> Object();   </span><br><span class=\"line\">Object o1 = o;</span><br></pre></td></tr></table></figure>\n\n<p>第一句是在heap中创建新的Object对象通过o引用这个对象，第二句是通过o建立o1到new Object()这个heap堆中的对象的引用，这两个引用都是强引用。只要存在对heap中对象的强引用，GC就不会收集该对象。</p>\n<h4 id=\"软引用\"><a href=\"#软引用\" class=\"headerlink\" title=\"软引用\"></a>软引用</h4><p>软引用主要用于内存敏感的高速缓存。在JVM报告内存不足之前会清除所有的软引用，这样以来GC就有可能收集软可及的对象，可能解决内存吃紧问题，避免内存溢出。什么时候会被收集取决于GC的算法和GC运行时可用内存的大小。 </p>\n<p>以上面的代码为例，回收软可及对象步骤如下：</p>\n<ol>\n<li>首先将softRef的referent设置为null，不再引用heap中的new String(“abc”)对象。</li>\n<li>将heap中的new String(“abc”)对象设置为可结束的(finalizable)。</li>\n<li>当heap中的new String(“abc”)对象的finalize()方法被运行而且该对象占用的内存被释放， softRef被添加到它的ReferenceQueue中。</li>\n</ol>\n<p>使用示例：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Object obj = <span class=\"keyword\">new</span> Object();</span><br><span class=\"line\">SoftRefenrence sr = <span class=\"keyword\">new</span> SoftReference(obj);</span><br><span class=\"line\">obj = <span class=\"keyword\">null</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 如果GC还未回收软引用</span></span><br><span class=\"line\"><span class=\"keyword\">if</span>(sr != <span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">    obj = sr.get();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 如果GC已回收软引用</span></span><br><span class=\"line\"><span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    obj = <span class=\"keyword\">new</span> A();</span><br><span class=\"line\">    sr = <span class=\"keyword\">new</span> SoftReference(obj);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"弱引用\"><a href=\"#弱引用\" class=\"headerlink\" title=\"弱引用\"></a>弱引用</h4><p>如果一个对象只具有弱引用，那就类似于可有可无的生活用品。弱引用与软引用的区别在于：只具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存，然后Java虚拟机会把这个弱引用加入到与之关联的引用队列中。 不过，由于垃圾回收器是一个优先级很低的线程， 因此不一定会很快发现那些只具有弱引用的对象。 </p>\n<p>使用示例：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Object obj = <span class=\"keyword\">new</span> Object();</span><br><span class=\"line\">WeakReference wr = <span class=\"keyword\">new</span> WeakReference(obj);</span><br><span class=\"line\">obj = <span class=\"keyword\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//等待一段时间，heap中new Object()对象就会被垃圾回收</span></span><br><span class=\"line\">...</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> (wr.get() == <span class=\"keyword\">null</span>) &#123; </span><br><span class=\"line\">    System.out.println(<span class=\"string\">\"obj 已经被清除了\"</span>); </span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> &#123; </span><br><span class=\"line\">    System.out.println(<span class=\"string\">\"obj 尚未被清除，其信息是 \"</span> + obj.toString());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>WeakHashMap</code>和<code>ThreadLocal</code>都用了弱引用</p>\n<h4 id=\"虚引用\"><a href=\"#虚引用\" class=\"headerlink\" title=\"虚引用\"></a>虚引用</h4><p>虚引用并不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收。虚引用主要用来跟踪对象被垃圾回收的活动。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。程序可以通过判断引用队列中是否已经加入了虚引用，来了解被引用的对象是否将要被垃圾回收。程序如果发现某个虚引用已经被加入到引用队列，那么就可以在所引用的对象的内存被回收之前采取必要的行动。</p>\n<p>与软引用和弱引用不同，回收虚可及对象时，先把PhantomRefrence对象添加到它的ReferenceQueue中，然后再释放虚可及的对象。</p>\n<p>JVM回收直接内存就用到了虚引用。</p>\n<h3 id=\"Reference\"><a href=\"#Reference\" class=\"headerlink\" title=\"Reference\"></a>Reference</h3><p>Cleaner继承PhantomRefrence，PhantomRefrence继承Reference，Reference类的静态方法中启动了一个handler线程，代码如下</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> &#123;</span><br><span class=\"line\">    ThreadGroup tg = Thread.currentThread().getThreadGroup();</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (ThreadGroup tgn = tg;</span><br><span class=\"line\">         tgn != <span class=\"keyword\">null</span>;</span><br><span class=\"line\">         tg = tgn, tgn = tg.getParent());</span><br><span class=\"line\">    Thread handler = <span class=\"keyword\">new</span> ReferenceHandler(tg, <span class=\"string\">\"Reference Handler\"</span>);</span><br><span class=\"line\">    <span class=\"comment\">/* If there were a special system-only priority greater than</span></span><br><span class=\"line\"><span class=\"comment\">     * MAX_PRIORITY, it would be used here</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    handler.setPriority(Thread.MAX_PRIORITY);</span><br><span class=\"line\">    handler.setDaemon(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">    handler.start();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>首先创建handler线程类，然后设置优先级，设置为守护线程，然后启动。 ReferenceHandler源码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ReferenceHandler</span> <span class=\"keyword\">extends</span> <span class=\"title\">Thread</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    ReferenceHandler(ThreadGroup g, String name) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>(g, name);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (;;) &#123;</span><br><span class=\"line\">            Reference&lt;Object&gt; r;</span><br><span class=\"line\">            <span class=\"keyword\">synchronized</span> (lock) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (pending != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                    r = pending;</span><br><span class=\"line\">                    pending = r.discovered;</span><br><span class=\"line\">                    r.discovered = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// The waiting on the lock may cause an OOME because it may try to allocate</span></span><br><span class=\"line\">                    <span class=\"comment\">// exception objects, so also catch OOME here to avoid silent exit of the</span></span><br><span class=\"line\">                    <span class=\"comment\">// reference handler thread.</span></span><br><span class=\"line\">                    <span class=\"comment\">//</span></span><br><span class=\"line\">                    <span class=\"comment\">// Explicitly define the order of the two exceptions we catch here</span></span><br><span class=\"line\">                    <span class=\"comment\">// when waiting for the lock.</span></span><br><span class=\"line\">                    <span class=\"comment\">//</span></span><br><span class=\"line\">                    <span class=\"comment\">// We do not want to try to potentially load the InterruptedException class</span></span><br><span class=\"line\">                    <span class=\"comment\">// (which would be done if this was its first use, and InterruptedException</span></span><br><span class=\"line\">                    <span class=\"comment\">// were checked first) in this situation.</span></span><br><span class=\"line\">                    <span class=\"comment\">//</span></span><br><span class=\"line\">                    <span class=\"comment\">// This may lead to the VM not ever trying to load the InterruptedException</span></span><br><span class=\"line\">                    <span class=\"comment\">// class again.</span></span><br><span class=\"line\">                    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                            lock.wait();</span><br><span class=\"line\">                        &#125; <span class=\"keyword\">catch</span> (OutOfMemoryError x) &#123; &#125;</span><br><span class=\"line\">                    &#125; <span class=\"keyword\">catch</span> (InterruptedException x) &#123; &#125;</span><br><span class=\"line\">                    <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// Fast path for cleaners</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (r <span class=\"keyword\">instanceof</span> Cleaner) &#123;</span><br><span class=\"line\">                ((Cleaner)r).clean();</span><br><span class=\"line\">                <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            ReferenceQueue&lt;Object&gt; q = r.queue;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (q != ReferenceQueue.NULL) q.enqueue(r);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol>\n<li>首先看pending是否有值，pending是JVM进行赋值的，当对象可达性变为不可达时会赋值到pending上；</li>\n<li>如果pending有值，将pending的值赋给r，discoverd是下一个不可达的对象，赋值给pending；如果pending不存在值，等待pending有值；</li>\n<li>判断r是不是Cleaner对象，是的话执行clean方法；</li>\n<li>再将虚引用加入引用队列。</li>\n</ol>\n<p>参考链接：</p>\n<p><a href=\"https://www.jianshu.com/p/6806ad95ed14\" target=\"_blank\" rel=\"noopener\">https://www.jianshu.com/p/6806ad95ed14</a></p>\n<p><a href=\"https://zhuanlan.zhihu.com/p/29454205\" target=\"_blank\" rel=\"noopener\">https://zhuanlan.zhihu.com/p/29454205</a></p>\n<p><a href=\"https://www.jianshu.com/p/825cca41d962\" target=\"_blank\" rel=\"noopener\">https://www.jianshu.com/p/825cca41d962</a></p>\n<p><a href=\"https://www.jianshu.com/p/f86d3a43eec5\" target=\"_blank\" rel=\"noopener\">https://www.jianshu.com/p/f86d3a43eec5</a></p>"},{"title":"Netty浅析","date":"2019-09-05T16:49:55.000Z","author":"Chopin","_content":"\n##  简介\n\nNetty是一款异步的事件驱动的网络应用程序框架，支持快速地开发可维护的高性能的面向协议的服务器和客户端。它提供了对TCP、UDP和文件传输的支持，作为一个异步NIO框架，Netty的所有IO操作都是异步非阻塞的，通过Future-Listener机制，用户可以方便的主动获取或者通过通知机制获得IO操作结果。\n\n<!-- more -->\n\n![](/png/netty/netty.png)\n\n为什么用Netty不用NIO\n\n1. NIO的类库和API繁杂，使用麻烦，你需要熟练掌握Selector、ServerSocketChannel、SocketChannel、ByteBuffer等；\n2. 需要具备其它的额外技能做铺垫，例如熟悉Java多线程编程，因为NIO编程涉及到Reactor模式，你必须对多线程和网路编程非常熟悉，才能编写出高质量的NIO程序；\n3. 可靠性能力补齐，工作量和难度都非常大。例如客户端面临断连重连、网络闪断、半包读写、失败缓存、网络拥塞和异常码流的处理等等，NIO编程的特点是功能开发相对容易，但是可靠性能力补齐工作量和难度都非常大；\n4. JDK NIO的BUG，例如epoll bug，它会导致Selector空轮询，最终导致CPU 100%。官方声称在JDK1.6版本的update18修复了该问题，但是直到JDK1.7版本该问题仍旧存在，只不过该bug发生概率降低了一些而已，它并没有被根本解决。\n\n##  Reactor模式和Netty线程模型\n\n###  什么是reactor模式\n\nReactor模式是**事件驱动的，有一个或多个并发输入源，有一个Service Handler，有多个Request Handlers**；这个Service Handler会同步的将输入的请求多路复用的分发给相应的Request Handler。 \n\n![](/png/netty/reactor模式.png)\n\n###  3种reactor模式\n\n####  单线程的reactor模式\n\n![](/png/netty/单线程reactor模型.jpg)\n\nReactor线程是个多面手，负责多路分离套接字，Accept新连接，并分派请求到处理器链中。该模型适用于处理器链中业务处理组件能快速完成的场景。不过，这种单线程模型不能充分利用多核资源，所以实际使用的不多。 \n\n性能缺陷：\n\n1. 一个NIO线程同时处理成百上千的链路，性能上无法支撑。即便NIO线程的CPU负荷达到100%，也无法满足海量消息的编码、解码、读取和发送；\n2. 当NIO线程负载过重之后，处理速度将变慢，这会导致大量客户端连接超时，超时之后往往进行重发，这更加重了NIO线程的负载，最终导致大量消息积压和处理超时，NIO线程会成为系统的性能瓶颈；\n3. 可靠性问题。一旦NIO线程出现错误，或者进入死循环，会导致整个系统通讯模块不可用，不能接收和处理外部信息，造成节点故障。\n\n####  多线程的reactor模式\n\n![](/png/netty/多线程reactor模型.jpg)\n\nReactor多线程模型的特点：\n\n1. 有专门一个NIO线程-Acceptor线程用于监听服务端，接收客户端的TCP连接请求； \n2. 网络IO操作-读、写等由一个NIO线程池负责，线程池可以采用标准的JDK线程池实现，它包含一个任务队列和N个可用的线程，由这些NIO线程负责消息的读取、解码、编码和发送； \n3. 1个NIO线程可以同时处理N条链路，但是1个链路只对应1个NIO线程，防止发生并发操作问题。\n\n在绝大多数场景下，Reactor多线程模型都可以满足性能需求；但是，当用户进一步增加的时候，一个NIO线程负责监听和处理所有的客户端连接可能会存在性能问题。例如并发百万客户端连接，或者服务端需要对客户端握手进行安全认证，但是认证本身非常损耗性能。在这类场景下，单独一个Acceptor线程可能会存在性能不足问题。\n\n####  主从reactor多线程模型\n\n![](/png/netty/主从模式reactor多线程模型.jpg)\n\n注册accepter事件处理器到mainReactor线程池中，这样mainReactor会监听客户端向服务端发起的连接请求\n\n当客户端向服务端发起连接请求时，mainReactor监听到了该请求将事件派发给acceptor事件处理器进行处理，可通过accept方法获得连接socketChannel，然后将socketChannel传递给subReactor线程池\n\nsubReactor线程池分配一个subReactor线程给这个SocketChannel，监听I/O的read、write操作，相关业务逻辑的处理交给工作线程池来完成\n\n###  Netty的线程模型\n\n![](/png/netty/netty线程模型.png)\n\n当NettyServer启动时候会创建两个NioEventLoopGroup线程池组。\n\nboss组用来接受客户端发来的连接，在监听一个端口的情况下，一个NioEventLoop通过一个NioServerSocketChannel监听端口，处理TCP连接。worker组则负责对完成TCP三次握手的连接进行处理。\n\n如上图每个NioEventLoopGroup里面包含了多个NioEventLoop，每个NioEventLoop中包含了一个NIO Selector、一个队列、一个线程；其中线程用来做轮询注册到Selector上的Channel的读写事件和对投递到队列里面的事件进行处理。 \n\n##  核心组件\n\n###  Channel接口、EventLoop接口\n\nChannel 是 Netty 网络操作抽象类，它除了包括基本的 I/O 操作，如 bind、connect、read、write 之外，还包括了 Netty 框架相关的一些功能，如获取该 Channe l的 EventLoop。 \n\n在传统的网络编程中，作为核心类的 Socket ，它对程序员来说并不是那么友好，直接使用其成本还是稍微高了点。而Netty 的 Channel 则提供的一系列的 API ，它大大降低了直接与 Socket 进行操作的复杂性。 \n\nNetty 基于事件驱动模型，使用不同的事件来通知我们状态的改变或者操作状态的改变。它定义了在整个连接的生命周期里当有事件发生的时候处理的核心抽象。\n\nChannel 为Netty 网络操作抽象类，EventLoop 主要是为Channel 处理 I/O 操作，两者配合参与 I/O 操作。\n\n![](/png/netty/channel&eventLoop.jpg)\n\n- 一个EventLoopGroup包含一个或者多个EventLoop\n- 一个EventLoop在他的生命周期只和一个线程绑定\n- 所有由EventLoop处理的I/O事件都将在它专有的线程上被处理\n- 一个Channel在它的生命周期内只注册于一个EventLoop\n- 一个EventLoop可能会被分配给一个或多个Channel\n\n###  ChannelFuture接口\n\nNetty 为异步非阻塞，即所有的 I/O 操作都为异步的，因此，我们不能立刻得知消息是否已经被处理了。Netty 提供了 ChannelFuture 接口，通过该接口的 addListener() 方法注册一个 ChannelFutureListener，当操作执行完成（成功或者失败）时，监听就会自动触发返回结果。\n\n###  ChannelHandler、ChannelPipeline\n\n####  ChannelHandler\n\nChannelHandler 为 Netty 中最核心的组件，它充当了所有处理入站和出站数据的应用程序逻辑的容器。ChannelHandler 主要用来处理各种事件，这里的事件很广泛，比如可以是连接、数据接收、异常、数据转换等。\n\nChannelHandler 有两个核心子类 ChannelInboundHandler 和 ChannelOutboundHandler，其中 ChannelInboundHandler 用于接收、处理入站数据和事件，而 ChannelOutboundHandler 则相反。我们经常通过一个ChannelInboundHandler的实现类来实现业务逻辑的处理。\n\n####  ChannelPipeline\n\nChannelPipeline 为 ChannelHandler 链提供了一个容器并定义了用于沿着链传播入站和出站事件流的 API。一个数据或者事件可能会被多个 Handler 处理，在这个过程中，数据或者事件经流 ChannelPipeline，由 ChannelHandler 处理。在这个处理过程中，一个 ChannelHandler 接收数据后处理完成后交给下一个 ChannelHandler，或者什么都不做直接交给下一个 ChannelHandler。 \n\n![](/png/netty/channelPipeline.jpg)\n\n当一个数据流进入 ChannlePipeline 时，它会从 ChannelPipeline 头部开始传给第一个 ChannelInboundHandler ，当第一个处理完后再传给下一个，一直传递到管道的尾部。与之相对应的是，当数据被写出时，它会从管道的尾部开始，先经过管道尾部的 “最后” 一个ChannelOutboundHandler，当它处理完成后会传递给前一个 ChannelOutboundHandler 。\n\n当ChannelHandler被添加到ChannelPipeline时，它将会被分配一个ChannelHandlerContext，代表了ChannelHandler和ChannelPipeline之间的绑定。\n\n####  编码器和解码器\n\n由于网络数据总是一系列的字节，通过Netty发送或者接受消息时，将会发生一次数据转换：入站消息会被解码，由字节转换为另一种格式，通常是一个Java对象；出站消息会被编码，从当前格式转换为字节。\n\nNetty提供了编码器的基类MessageToByteEncoder以及解码器的基类ByteToMessageDecoder，Netty提供的所有解码器/编码器适配器类都实现了ChannelInboundHandler或者ChannelOutboundHandler接口。如果我们要自定义的编码/解码规则，只需要继承基类，实现encode()/decode()方法。\n\n```java\n\t@Override\n    protected void encode(ChannelHandlerContext channelHandlerContext, Object iotPacketRequest, \n                            ByteBuf out) {\n        if (null == iotPacketRequest) {\n            return;\n        }\n        String body = JsonUtils.bean2Json(iotPacketRequest);\n        byte[] bodyBytes = body.getBytes(Charset.forName(\"utf-8\"));\n        out.writeShort(IotConnectProperties.MAGIC_CODE);\n        out.writeShort(bodyBytes.length);\n        out.writeBytes(bodyBytes);\n    }\n```\n\n###  服务端启动分析\n\n以创建一个Netty服务端为例\n\n```java\npublic class NettyServer {\n\n    public void bind(int port){\n        // 创建EventLoopGroup\n        EventLoopGroup bossGroup = new NioEventLoopGroup();\n        EventLoopGroup workerGroup = new NioEventLoopGroup();\n\n        try {\n            // 创建ServerBootStrap实例\n            // ServerBootstrap 用于启动NIO服务端的辅助启动类，目的是降低服务端的开发复杂度\n            ServerBootstrap b = new ServerBootstrap();\n            // 绑定Reactor线程池\n            b.group(bossGroup, workerGroup)\n                    // 设置并绑定服务端Channel\n                    // 指定所使用的NIO传输的Channel\n                    .channel(NioServerSocketChannel.class)\n                    .option(ChannelOption.SO_BACKLOG, 1024)\n                    .handler(new LoggingServerHandler())\n                    .childHandler(new ChannelInitializer(){\n                        @Override\n                        protected void initChannel(Channel ch) throws Exception {\n                            ch.pipeline().addLast(\"decoder\", new HttpRequestDecoder());\n                            ch.pipeline().addLast(\"encoder\", new HttpResponseEncoder());\n                            ch.pipeline().addLast(\"httpServerHandler\", new HttpServerHandler());\n                        }\n                    });\n\n            // 绑定端口，同步等待成功\n            ChannelFuture future = b.bind(port).sync();\n            // 等待服务端监听端口关闭\n            future.channel().closeFuture().sync();\n\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        } finally {\n            // 优雅地关闭\n            bossGroup.shutdownGracefully();\n            workerGroup.shutdownGracefully();\n        }\n    }\n}\n```\n\n服务端的创建主要步骤为：\n\n1. 创建 ServerBootstrap 实例\n2. 设置并绑定 Reactor 线程池\n3. 设置服务端 Channel\n4. 添加并设置 ChannelHandler\n5. 绑定并启动监听端口\n\n####  创建EventLoopGroup\n\n```java\nEventLoopGroup bossGroup = new NioEventLoopGroup();\nEventLoopGroup workerGroup = new NioEventLoopGroup();\n```\n\nbossGroup 为 BOSS 线程组，用于服务端接受客户端的连接, workerGroup 为 worker 线程组，用于进行 SocketChannel 的网络读写。 \n\n####  **创建ServerBootstrap实例**\n\n```java\nServerBootstrap b = new ServerBootstrap();\n```\n\nServerBootStrap为Netty服务端的启动引导类，用于帮助用户快速配置、启动服务端服务。 客户端的引导类是Bootstrap。ServerBootStrap 提供了如下一些方法\n\n| 方法名称  | 方法描述                                   |\n| --------- | ------------------------------------------ |\n| `group`   | 设置 ServerBootstrap 要用的 EventLoopGroup |\n| `channel` | 设置将要被实例化的 ServerChannel 类        |\n| `option`  | 实例化的 ServerChannel 的配置项            |\n| `Handler` | 设置并添加 Handler                         |\n| `bind`    | 绑定 ServerChannel                         |\n\n####  设置并绑定线程池\n\n```java\nb.group(bossGroup, workerGroup)\n```\n\n调用group()方法，为ServerBootstrap实例设置绑定reactor线程池\n\n```java\n\tpublic ServerBootstrap group(EventLoopGroup parentGroup, EventLoopGroup childGroup) {\n        super.group(parentGroup);        // 绑定boosGroup\n        if (childGroup == null) {\n            throw new NullPointerException(\"childGroup\");\n        }\n        if (this.childGroup != null) {\n            throw new IllegalStateException(\"childGroup set already\");\n        }\n        this.childGroup = childGroup;    // 绑定workerGroup\n        return this;\n    }\n```\n\n####  设置服务端Channel\n\n```\n.channel(NioServerSocketChannel.class)\n```\n\n调用channel()方法设置服务端Channel类型，注意这里参数是Class对象，Netty通过工厂类，利用反射来创建NioServerSocketChannel对象\n\n```java\n\tpublic B channel(Class<? extends C> channelClass) {\n        if (channelClass == null) {\n            throw new NullPointerException(\"channelClass\");\n        }\n        return channelFactory(new ReflectiveChannelFactory<C>(channelClass));\n    }\n```\n\n这里传递的是 ReflectiveChannelFactory，其源代码如下： \n\n```java\n\tpublic class ReflectiveChannelFactory<T extends Channel> implements ChannelFactory<T> {\n\n    private final Class<? extends T> clazz;\n\n    public ReflectiveChannelFactory(Class<? extends T> clazz) {\n        if (clazz == null) {\n            throw new NullPointerException(\"clazz\");\n        }\n        this.clazz = clazz;\n    }\n    //需要创建 channel 的时候，该方法将被调用\n    @Override\n    public T newChannel() {\n        try {\n            // 反射创建对应 channel\n            return clazz.newInstance();\n        } catch (Throwable t) {\n            throw new ChannelException(\"Unable to create Channel from class \" + clazz, t);\n        }\n    }\n\n    @Override\n    public String toString() {\n        return StringUtil.simpleClassName(clazz) + \".class\";\n    }\n}\n\n```\n\n####  添加并设置ChannelHandler\n\n```java\n \t.handler(new LoggingServerHandler())\n\t.childHandler(new ChannelInitializer(){\n\t\t@Override\n\t\tprotected void initChannel(Channel ch) throws Exception {\n\t\t\tch.pipeline().addLast(\"decoder\", new HttpRequestDecoder());\n\t\t\tch.pipeline().addLast(\"encoder\", new HttpResponseEncoder());\n\t\t\tch.pipeline().addLast(\"httpServerHandler\", new HttpServerHandler());\n\t\t}\n\t})\n\n```\n\n`handler()`设置的 Handler 是服务端 NioServerSocketChannel的，childHandler()`设置的 Handler 是属于每一个新建的 NioSocketChannel 的\n\n####  绑定端口，启动服务端\n\n绑定端口并启动服务，如下： \n\n```java\nChannelFuture future = b.bind(port).sync();\n\n```\n\n深入源码我们发现核心方法有两个`initAndRegister()`， `doBind0()`\n\n#####  initAndRegister()\n\n```java\nfinal ChannelFuture initAndRegister() {\n    Channel channel = null;\n    // ...\n    channel = channelFactory.newChannel();\n    //...\n    init(channel);\n    //...\n    ChannelFuture regFuture = config().group().register(channel);\n    //...\n    return regFuture;\n}\n\n```\n\ninitAndRegister做了3件事：\n\n1.**new一个Channel**\n\n```java\nchannel = channelFactory.newChannel();\n\n```\n\n前面在ServerBootstrap实例设置服务端Channel时，设置了这个Channel的类型，这里就通过工厂类的方法生成NioServerSocketChannel对象。\n\n追溯NioServerSocketChannel的默认构造函数，我们可以发现在构造该实例时，设置了channel为非阻塞模式、SelectionKey.OP_ACCEPT事件、channelId 、NioMessageUnsafe(封装了用于数据传输操作的函数)、DefaultChannelPipeline和 NioServerSocketChannelConfig 属性。 \n\n2.**init这个Channel**\n\n```java\nvoid init(Channel channel) throws Exception {\n         // 设置配置的option参数\n        final Map<ChannelOption<?>, Object> options = options0();\n        synchronized (options) {\n            channel.config().setOptions(options);\n        }\n\n        final Map<AttributeKey<?>, Object> attrs = attrs0();\n        synchronized (attrs) {\n            for (Entry<AttributeKey<?>, Object> e: attrs.entrySet()) {\n                @SuppressWarnings(\"unchecked\")\n                AttributeKey<Object> key = (AttributeKey<Object>) e.getKey();\n                channel.attr(key).set(e.getValue());\n            }\n        }\n\n        // 获取绑定的pipeline\n        ChannelPipeline p = channel.pipeline();\n\n        // 准备child用到的4个part\n        final EventLoopGroup currentChildGroup = childGroup;\n        final ChannelHandler currentChildHandler = childHandler;\n        final Entry<ChannelOption<?>, Object>[] currentChildOptions;\n        final Entry<AttributeKey<?>, Object>[] currentChildAttrs;\n        synchronized (childOptions) {\n            currentChildOptions = childOptions.entrySet().toArray(newOptionArray(childOptions.size()));\n        }\n        synchronized (childAttrs) {\n            currentChildAttrs = childAttrs.entrySet().toArray(newAttrArray(childAttrs.size()));\n        }\n\n        // 为NioServerSocketChannel的pipeline添加一个初始化Handler,\n        // 当NioServerSocketChannel在EventLoop注册成功时，该handler的init方法将被调用\n        p.addLast(new ChannelInitializer<Channel>() {\n            @Override\n            public void initChannel(Channel ch) throws Exception {\n                final ChannelPipeline pipeline = ch.pipeline();\n                ChannelHandler handler = config.handler();\n                //如果用户配置过Handler\n                if (handler != null) {\n                    pipeline.addLast(handler);\n                }\n\n                ch.eventLoop().execute(new Runnable() {\n                    @Override\n                    public void run() {\n                        // 为NioServerSocketChannel的pipeline添加ServerBootstrapAcceptor处理器\n                        // 该Handler主要用来将新创建的NioSocketChannel注册到EventLoopGroup中\n                        pipeline.addLast(new ServerBootstrapAcceptor(\n                                currentChildGroup, currentChildHandler, currentChildOptions, currentChildAttrs));\n                    }\n                });\n            }\n        });\n    }\n\n```\n\n我们发现init其实就做了三件事：\n\n- 设置options、attrs\n- 设置新接入Channel的options、attrs\n- 将用于服务端注册的 Handler ServerBootstrapAcceptor 添加到 ServerChannel的ChannelPipeline 中。ServerBootstrapAcceptor 为一个接入器，专门接受新请求。\n\n3.**向EventLoopGroup中注册这个Channel**\n\n```java\n\tChannelFuture regFuture = config().group().register(channel);\n\n```\n\n通过追溯我们发现过程如下：\n\n```java\n\tpublic ChannelFuture register(Channel channel) {\n        return next().register(channel);\n    }\n\n```\n\n调用 `next()` 方法从 EventLoopGroup 中获取下一个 EventLoop，调用 `register()` 方法注册： \n\n```java\n\tpublic ChannelFuture register(Channel channel) {\n        return register(new DefaultChannelPromise(channel, this));\n    }\n\n```\n\n将Channel和EventLoop封装成一个DefaultChannelPromise对象，然后调用register()方法。DefaultChannelPromis为ChannelPromise的默认实现，而ChannelPromisee继承Future，具备异步执行结构，绑定Channel，所以又具备了监听的能力，故而ChannelPromis是Netty异步执行的核心接口。 \n\n```java\n\tpublic ChannelFuture register(ChannelPromise promise) {\n        ObjectUtil.checkNotNull(promise, \"promise\");\n        promise.channel().unsafe().register(this, promise);\n        return promise;\n    }\n\n```\n\nunsafe就是我们之前构造NioServerSocketChannel时new的对象，这里调用register方法过程如下：\n\n```java\n\t\tpublic final void register(EventLoop eventLoop, final ChannelPromise promise) {\n            if (eventLoop == null) {\n                throw new NullPointerException(\"eventLoop\");\n            }\n            if (isRegistered()) {\n                promise.setFailure(new IllegalStateException(\"registered to an event loop already\"));\n                return;\n            }\n            if (!isCompatible(eventLoop)) {\n                promise.setFailure(\n                        new IllegalStateException(\"incompatible event loop type: \" + eventLoop.getClass().getName()));\n                return;\n            }\n\n            AbstractChannel.this.eventLoop = eventLoop;\n\n            // 必须要保证注册是由该EventLoop发起的\n            if (eventLoop.inEventLoop()) {\n                register0(promise);        // 注册\n            } else {\n                // 如果不是单独封装成一个task异步执行\n                try {\n                    eventLoop.execute(new Runnable() {\n                        @Override\n                        public void run() {\n                            register0(promise);\n                        }\n                    });\n                } catch (Throwable t) {\n                    logger.warn(\n                            \"Force-closing a channel whose registration task was not accepted by an event loop: {}\",\n                            AbstractChannel.this, t);\n                    closeForcibly();\n                    closeFuture.setClosed();\n                    safeSetFailure(promise, t);\n                }\n            }\n        }\t\n\n```\n\n首先通过`isRegistered()` 判断该 Channel 是否已经注册到 EventLoop 中；  \n\n通过 `eventLoop.inEventLoop()` 来判断当前线程是否为该 EventLoop 自身发起的，如果是，则调用 `register0()` 直接注册;\n\n如果不是，说明该 EventLoop 中的线程此时没有执行权，则需要新建一个线程，单独封装一个 Task，而该 Task 的主要任务则是执行`register0()`。 \n\n```java\n\t\tprivate void register0(ChannelPromise promise) {\n            try {\n                // 确保 Channel 处于 open\n                if (!promise.setUncancellable() || !ensureOpen(promise)) {\n                    return;\n                }\n                boolean firstRegistration = neverRegistered;\n\n                // 真正的注册动作\n                doRegister();\n\n                neverRegistered = false;\n                registered = true;        \n\n                pipeline.invokeHandlerAddedIfNeeded();    \n                safeSetSuccess(promise);        //设置注册结果为成功\n\n                pipeline.fireChannelRegistered();\n\n                if (isActive()) { \n                    //如果是首次注册,发起 pipeline 的 fireChannelActive\n                    if (firstRegistration) {\n                        pipeline.fireChannelActive();\n                    } else if (config().isAutoRead()) {\n                        beginRead();\n                    }\n                }\n            } catch (Throwable t) {\n                closeForcibly();\n                closeFuture.setClosed();\n                safeSetFailure(promise, t);\n            }\n        }\n\n```\n\n如果 Channel 处于 open 状态，则调用 `doRegister()` 方法完成注册，然后将注册结果设置为成功。最后判断如果是首次注册且处于激活状态，则发起 pipeline 的 `fireChannelActive()`。\n\n```java\n\tprotected void doRegister() throws Exception {\n        boolean selected = false;\n        for (;;) {\n            try {\n                // 注册到NIOEventLoop的Selector上\n                selectionKey = javaChannel().register(eventLoop().selector, 0, this);\n                return;\n            } catch (CancelledKeyException e) {\n                if (!selected) {\n                    eventLoop().selectNow();\n                    selected = true;\n                } else {\n                    throw e;\n                }\n            }\n        }\n    }\n\n```\n\n因为当前没有将一个ServerSocket绑定到一个address\n\n```java\n\tif (isActive()) { \n\t\t//如果是首次注册,发起 pipeline 的 fireChannelActive\n\t\tif (firstRegistration) {\n\t\t\tpipeline.fireChannelActive();\n\t\t} else if (config().isAutoRead()) {\n\t\t\tbeginRead();\n\t\t}\n\t}\n\n```\n\n```java\n\tpublic boolean isActive() {\n        return this.javaChannel().socket().isBound();\n    }\n\n```\n\n```java\n\tprotected void doBeginRead() throws Exception {\n        SelectionKey selectionKey = this.selectionKey;\n        if (selectionKey.isValid()) {\n            this.readPending = true;\n            int interestOps = selectionKey.interestOps();\n            if ((interestOps & this.readInterestOp) == 0) {\n                selectionKey.interestOps(interestOps | this.readInterestOp);\n            }\n\n        }\n    }\n\n```\n\n这里将selectionKey的监听操作设置为之前构造NioServerSocketChannel设置的SelectionKey.OP_ACCEPT\n\n##### he doBind0()\n\n追溯doBind0()的实现，我们可以发现会调用初始化时NioMessageUnsafe的bind方法\n\n```java\n@Override\npublic final void bind(final SocketAddress localAddress, final ChannelPromise promise) {\n    // ...\n    boolean wasActive = isActive();\n    // ...\n    doBind(localAddress);\n\n    if (!wasActive && isActive()) {\n        invokeLater(new Runnable() {\n            @Override\n            public void run() {\n                pipeline.fireChannelActive();\n            }\n        });\n    }\n    safeSetSuccess(promise);\n}\n\n```\n\ndoBind(localAddress) 调用JDK的代码，实现了端口绑定\n\n```\nprotected void doBind(SocketAddress localAddress) throws Exception {\n    if (PlatformDependent.javaVersion() >= 7) {\n        //noinspection Since15\n        javaChannel().bind(localAddress, config.getBacklog());\n    } else {\n        javaChannel().socket().bind(localAddress, config.getBacklog());\n    }\n}\n\n```\n\n绑定后isActice()返回true，fireChannelActive() 被调用。\n\n## 4 内存管理\n\n### 4.1 ByteBuffer、ByteBuf\n\n为了减少频繁I/O操作，引进了Buffer的概念，把突发的大数量较小规模的 I/O 整理成平稳的小数量较大规模的 I/O 。Java NIO封装了ByteBuffer组件。ByteBuffer具有4个重要的属性：mark、position、limit、capacity ，以及两个重要的方法clear()、flip()\n\n1. position:读写指针，代表当前读或写操作的位置，这个值总是小于等于limit的。\n2. mark：在使用ByteBuffer的过程中，如果想要记住当前的position，则会将当前的position值给mark，需要恢复的时候，再将mark的值给position。\n3. capacity：代表这块内存区域的大小。\n4. limit：初始的Buffer中，limit和capacity的值是相等的，通常在clear操作和flip操作的时候会对这个值进行操作，在clear操作的时候会将这个值和capacity的值设置为相等，当flip的时候会将当前的position的值给limit，我们可以总结在写的时候，limit的值代表最大的可写位置，在读的时候，limit的值代表最大的可读位置。\n\n![](/png/netty/ByteBuffer.png)\n\n在写操作之前调用clear()\n\n```java\npublic final Buffer clear() { \n\tposition = 0; //设置当前下标为0\n\tlimit = capacity; //设置写越界位置与和Buffer容量相同\n\tmark = -1; //取消标记\n\treturn this; \n} \n\n```\n\n在读操作之前调用flip()\n\n```java\npublic final Buffer flip() { \n\tlimit = position; \n\tposition = 0; \n\tmark = -1; \n\treturn this; \n }  \n\n```\n\nByteBuffer具有以下缺陷\n\n- ByteBuffer长度固定，一旦分配完成，它的容量不能动态扩展和收缩，当需要编码的POJO对象大于ByteBuffer的容量时，会发生索引越界异常；\n- ByteBuffer只有一个标识位控的指针position，读写的时候需要手工调用 flip() 和 clear() 等；\n- ByteBuffer的API功能有限，一些高级和实用的特性它不支持，需要使用者自己编程实现。\n\nNetty为了解决ByteBuffer的缺陷，重写了一个新的数据接口ByteBuf。 与ByteBuffer相比，ByteBuf提供了两个指针 readerIndex 和 writeIndex 来分别指向读的位置和写的位置，不需要每次为读写做准备，直接设置读写指针进行读写操作即可。 \n\n![](/png/netty/读写中间状态的Buffer.png)\n\n这是中间状态的Buffer，可以通过调用discardReadBytes方法来回收已读区域\n\n![](/png/netty/discardReadBytes.png)\n\n通过clear方法清楚指针状态\n\n![](/png/netty/clear后的Buffer.png)\n\n对比ByteBuffer，使用ByteBuf读的时候仅仅依赖readerIndex指针，写的时候仅仅依赖writerIndex指针，不需每次读写之前调用对应的方法，而且没有必须一次读完的限制。 \n\n### 4.2 内存管理\n\n#### 4.2.1 零拷贝\n\n当JVM堆内存上的数据需要和IO设备进行I/O操作时，会将JVM堆上所维护的byte[]拷贝至堆外内存（一般是通过C/C++分配的内存），然后堆外内存直接和IO设备交互。这是因为**JVM需要进行GC，如果IO设备直接和JVM堆上的数据进行交互，这个时候JVM进行了GC，那么有可能会导致没有被回收的数据进行了压缩，位置被移动到了连续的存储区域，这样会导致正在进行的IO操作相关的数据全部乱套**。\n\nNIO可以使用native 函数库直接分配堆外内存，然后通过一个存储在堆上的DirectByteBuffer 对象作为这块内存的引用进行操作，避免了在Java堆和Native堆中来回复制数据。 \n\n#### 4.2.2 内存泄漏\n\n从堆中分配的缓冲区HeapByteBuffer为普通的Java对象，生命周期与普通的Java对象一样，当不再被引用时，Buffer对象会被回收。而直接缓冲区（DirectByteBuffer）为堆外内存，并不在Java堆中，也不能被JVM垃圾回收。由于直接缓冲区在JVM里被包装进Java对象DirectByteBuffer中，当它的包装类被垃圾回收时，会调用相应的JNI方法释放堆外内存，所以堆外内存的释放也依赖于JVM中DirectByteBuffer对象的回收。\n\n由于垃圾回收本身成本较高，一般JVM在堆内存未耗尽时，不会进行垃圾回收操作。如果不断分配本地内存，堆内存很少使用，那么JVM就不需要执行GC，DirectByteBuffer对象们就不会被回收，这时候堆内存充足，但本地内存可能已经使用光了，再次尝试分配本地内存就会出现OutOfMemoryError，那程序就直接崩溃了。\n\n#### 4.2.3 ByteBuf引用计数\n\n```java\npublic interface ReferenceCounted {\n    int refCnt();\n\n    ReferenceCounted retain();\n\n    ReferenceCounted retain(int var1);\n\n    ReferenceCounted touch();\n\n    ReferenceCounted touch(Object var1);\n\n    boolean release();\n\n    boolean release(int var1);\n}\n\n```\n\nByteBuf扩展了ReferenceCountered接口 ，这个接口定义的功能主要是引用计数。\n\n当 ByteBuf 引用+1的时候，需要调用 retain() 来让refCnt + 1，当Buffer引用数-1的时候需要调用 release() 来让 refCnt - 1。当refCnt变为0的时候Netty为pooled和unpooled的不同buffer提供了不同的实现，通常对于非内存池的用法，Netty把Buffer的内存回收交给了垃圾回收器，对于内存池的用法，Netty对内存的回收实际上是回收到内存池内，以提供下一次的申请所使用。\n\n#### 4.2.4 池化\n\n如果对于Buffer的使用都基于直接内存实现的话，将会大大提高I/O效率，然而直接内存空间的申请比堆内存要消耗更高的性能。\n\n因此Netty结合引用计数实现了PolledBuffer，即池化的用法，当引用计数等于0的时候，Netty将Buffer回收至池中，在下一次申请Buffer的时刻会被复用。 \n\n堆内存和直接内存的池化实现分别是PooledHeapByteBuf和PooledDirectByteBuf，在各自的实现中都维护着一个Recycler 。Recycler是一个抽象类，向外部提供了两个公共方法get和recycle分别用于从对象池中获取对象和回收对象。\n\n以PooledHeapByteBuf为例，新建PooledHeapByteBuf对象时\n\n```java\n\tstatic PooledHeapByteBuf newInstance(int maxCapacity) {\n        PooledHeapByteBuf buf = (PooledHeapByteBuf)RECYCLER.get();\n        buf.reuse(maxCapacity);\n        return buf;\n    }\n\n```\n\n当Buffer引用数 -1时\n\n```java\n\tpublic boolean release(int decrement) {\n        return this.release0(ObjectUtil.checkPositive(decrement, \"decrement\"));\n    }\n\n    private boolean release0(int decrement) {\n        int oldRef = refCntUpdater.getAndAdd(this, -decrement);\n        if (oldRef == decrement) {\n            this.deallocate();\n            return true;\n        } else if (oldRef >= decrement && oldRef - decrement <= oldRef) {\n            return false;\n        } else {\n            refCntUpdater.getAndAdd(this, decrement);\n            throw new IllegalReferenceCountException(oldRef, -decrement);\n        }\n    }\n\n```\n\nPooledByteBuf.class\n\n```java\nprotected final void deallocate() {\n    if (this.handle >= 0L) {\n        long handle = this.handle;\n        this.handle = -1L;\n        this.memory = null;\n        this.tmpNioBuf = null;\n        this.chunk.arena.free(this.chunk, handle, this.maxLength, this.cache);\n        this.chunk = null;\n        this.recycle();\n    }\n\n}\n\nprivate void recycle() {\n    this.recyclerHandle.recycle(this);\n}\n\n```\n\n### 4.3 半包读写\n\nTCP是个\"流\"协议，所谓流，就是没有界限没有分割的一串数据。TCP会根据缓冲区的实际情况进行包划分，一个完整的包可能会拆分成多个包进行发送，也用可能把多个小包封装成一个大的数据包发送。这就是TCP粘包/拆包。\n\n举个例子：假设操作系统已经接收到了三个包，如下：\n\n![](/png/netty/流-拆包.png)\n\n由于流传输的这个普通属性，在读取他们的时候将会存在很大的几率，这些数据会被分段成下面的几部分：\n\n![](/png/netty/流-粘包.png)\n\n也就是读取的数据有可能超过一个完整的数据包或者过多或者过少的半包。\n\n因此，作为一个接收方，不管它是服务端还是客户端，都需要把接收到的数据整理成一个或多个有意义的并且能够被应用程序容易理解的数据。\n\n**拆包方案：**\n\n- **消息定长**，固定报文长度，不够空格补全，发送和接收方遵循相同的约定，这样即使粘包了通过接收方编程实现获取定长报文也能区分。\n- **包尾添加特殊分隔符**，例如每条报文结束都添加回车换行符（例如FTP协议）或者指定特殊字符作为报文分隔符，接收方通过特殊分隔符切分报文区分。\n- **将消息分为消息头和消息体**，消息头中包含表示信息的总长度（或者消息体长度）的字段\n\n**Netty提供了几种解码器：**\n\n- 定长解码器：FixedLengthFrameDecoder\n\n```\nch.pipeline().addLast(new FixedLengthFrameDecoder(30));//设置定长解码器\n\n```\n\n- 特殊分隔符解码器：DelimiterBasedFrameDecoder\n\n```\nByteBuf delimiter = Unpooled.copiedBuffer(\"&\".getBytes());\n//1024表示单条消息的最大长度，解码器在查找分隔符的时候，达到该长度还没找到的话会抛异常\nch.pipeline().addLast(new DelimiterBasedFrameDecoder(1024,delimiter));\n\n```\n\n- 基于包头不固定长度的解码器：LengthFieldBasedFrameDecoder\n\n```java\n/**\n * maxFrameLength：解码的帧的最大长度\n * lengthFieldOffset：长度属性的起始位（偏移位），包中存放有整个大数据包长度的字节，这段字节的其实位置\n * lengthFieldLength：长度属性的长度，即存放整个大数据包长度的字节所占的长度\n * lengthAdjustmen：长度调节值，在总长被定义为包含包头长度时，修正信息长度。\n * initialBytesToStrip：跳过的字节数，根据需要我们跳过lengthFieldLength个字节，以便接收端直接接受到不\n                        含“长度属性”的内容\n */\nch.pipeline().addLast(\"decoder\", new LengthFieldBasedFrameDecoder(MAX_FRAME_LENGTH, LENGTH_OFFSET, \n                                    LENGTH_LEN, LENGTH_ADJUGEMENT, INIT_BYTE_TO_STRIP));\n\n```\n\n**参考资料**\n\n| 资料名称           | 来源                                        |\n| ------------------ | ------------------------------------------- |\n| 《Netty实战》      | 图书                                        |\n| 《Netty权威指南》  | 图书                                        |\n| Netty官网wiki      | https://netty.io/wiki/related-articles.html |\n| 其他互联网资料链接 | 见最后                                      |\n\n\n**参考链接：**\n\nhttps://netty.io/index.html\nhttps://blog.csdn.net/syc001/article/details/72841945\nhttp://ifeve.com/%E8%B0%88%E8%B0%88netty%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/\nhttps://www.cnblogs.com/wxd0108/p/6681627.html\nhttps://my.oschina.net/plucury/blog/192577\nhttps://blog.csdn.net/chenssy/article/details/78714003","source":"_posts/Netty浅析.md","raw":"---\ntitle: Netty浅析\ndate: 2019-09-06 00:49:55\nauthor: Chopin\ntags:   #标签\n    - Netty\n---\n\n##  简介\n\nNetty是一款异步的事件驱动的网络应用程序框架，支持快速地开发可维护的高性能的面向协议的服务器和客户端。它提供了对TCP、UDP和文件传输的支持，作为一个异步NIO框架，Netty的所有IO操作都是异步非阻塞的，通过Future-Listener机制，用户可以方便的主动获取或者通过通知机制获得IO操作结果。\n\n<!-- more -->\n\n![](/png/netty/netty.png)\n\n为什么用Netty不用NIO\n\n1. NIO的类库和API繁杂，使用麻烦，你需要熟练掌握Selector、ServerSocketChannel、SocketChannel、ByteBuffer等；\n2. 需要具备其它的额外技能做铺垫，例如熟悉Java多线程编程，因为NIO编程涉及到Reactor模式，你必须对多线程和网路编程非常熟悉，才能编写出高质量的NIO程序；\n3. 可靠性能力补齐，工作量和难度都非常大。例如客户端面临断连重连、网络闪断、半包读写、失败缓存、网络拥塞和异常码流的处理等等，NIO编程的特点是功能开发相对容易，但是可靠性能力补齐工作量和难度都非常大；\n4. JDK NIO的BUG，例如epoll bug，它会导致Selector空轮询，最终导致CPU 100%。官方声称在JDK1.6版本的update18修复了该问题，但是直到JDK1.7版本该问题仍旧存在，只不过该bug发生概率降低了一些而已，它并没有被根本解决。\n\n##  Reactor模式和Netty线程模型\n\n###  什么是reactor模式\n\nReactor模式是**事件驱动的，有一个或多个并发输入源，有一个Service Handler，有多个Request Handlers**；这个Service Handler会同步的将输入的请求多路复用的分发给相应的Request Handler。 \n\n![](/png/netty/reactor模式.png)\n\n###  3种reactor模式\n\n####  单线程的reactor模式\n\n![](/png/netty/单线程reactor模型.jpg)\n\nReactor线程是个多面手，负责多路分离套接字，Accept新连接，并分派请求到处理器链中。该模型适用于处理器链中业务处理组件能快速完成的场景。不过，这种单线程模型不能充分利用多核资源，所以实际使用的不多。 \n\n性能缺陷：\n\n1. 一个NIO线程同时处理成百上千的链路，性能上无法支撑。即便NIO线程的CPU负荷达到100%，也无法满足海量消息的编码、解码、读取和发送；\n2. 当NIO线程负载过重之后，处理速度将变慢，这会导致大量客户端连接超时，超时之后往往进行重发，这更加重了NIO线程的负载，最终导致大量消息积压和处理超时，NIO线程会成为系统的性能瓶颈；\n3. 可靠性问题。一旦NIO线程出现错误，或者进入死循环，会导致整个系统通讯模块不可用，不能接收和处理外部信息，造成节点故障。\n\n####  多线程的reactor模式\n\n![](/png/netty/多线程reactor模型.jpg)\n\nReactor多线程模型的特点：\n\n1. 有专门一个NIO线程-Acceptor线程用于监听服务端，接收客户端的TCP连接请求； \n2. 网络IO操作-读、写等由一个NIO线程池负责，线程池可以采用标准的JDK线程池实现，它包含一个任务队列和N个可用的线程，由这些NIO线程负责消息的读取、解码、编码和发送； \n3. 1个NIO线程可以同时处理N条链路，但是1个链路只对应1个NIO线程，防止发生并发操作问题。\n\n在绝大多数场景下，Reactor多线程模型都可以满足性能需求；但是，当用户进一步增加的时候，一个NIO线程负责监听和处理所有的客户端连接可能会存在性能问题。例如并发百万客户端连接，或者服务端需要对客户端握手进行安全认证，但是认证本身非常损耗性能。在这类场景下，单独一个Acceptor线程可能会存在性能不足问题。\n\n####  主从reactor多线程模型\n\n![](/png/netty/主从模式reactor多线程模型.jpg)\n\n注册accepter事件处理器到mainReactor线程池中，这样mainReactor会监听客户端向服务端发起的连接请求\n\n当客户端向服务端发起连接请求时，mainReactor监听到了该请求将事件派发给acceptor事件处理器进行处理，可通过accept方法获得连接socketChannel，然后将socketChannel传递给subReactor线程池\n\nsubReactor线程池分配一个subReactor线程给这个SocketChannel，监听I/O的read、write操作，相关业务逻辑的处理交给工作线程池来完成\n\n###  Netty的线程模型\n\n![](/png/netty/netty线程模型.png)\n\n当NettyServer启动时候会创建两个NioEventLoopGroup线程池组。\n\nboss组用来接受客户端发来的连接，在监听一个端口的情况下，一个NioEventLoop通过一个NioServerSocketChannel监听端口，处理TCP连接。worker组则负责对完成TCP三次握手的连接进行处理。\n\n如上图每个NioEventLoopGroup里面包含了多个NioEventLoop，每个NioEventLoop中包含了一个NIO Selector、一个队列、一个线程；其中线程用来做轮询注册到Selector上的Channel的读写事件和对投递到队列里面的事件进行处理。 \n\n##  核心组件\n\n###  Channel接口、EventLoop接口\n\nChannel 是 Netty 网络操作抽象类，它除了包括基本的 I/O 操作，如 bind、connect、read、write 之外，还包括了 Netty 框架相关的一些功能，如获取该 Channe l的 EventLoop。 \n\n在传统的网络编程中，作为核心类的 Socket ，它对程序员来说并不是那么友好，直接使用其成本还是稍微高了点。而Netty 的 Channel 则提供的一系列的 API ，它大大降低了直接与 Socket 进行操作的复杂性。 \n\nNetty 基于事件驱动模型，使用不同的事件来通知我们状态的改变或者操作状态的改变。它定义了在整个连接的生命周期里当有事件发生的时候处理的核心抽象。\n\nChannel 为Netty 网络操作抽象类，EventLoop 主要是为Channel 处理 I/O 操作，两者配合参与 I/O 操作。\n\n![](/png/netty/channel&eventLoop.jpg)\n\n- 一个EventLoopGroup包含一个或者多个EventLoop\n- 一个EventLoop在他的生命周期只和一个线程绑定\n- 所有由EventLoop处理的I/O事件都将在它专有的线程上被处理\n- 一个Channel在它的生命周期内只注册于一个EventLoop\n- 一个EventLoop可能会被分配给一个或多个Channel\n\n###  ChannelFuture接口\n\nNetty 为异步非阻塞，即所有的 I/O 操作都为异步的，因此，我们不能立刻得知消息是否已经被处理了。Netty 提供了 ChannelFuture 接口，通过该接口的 addListener() 方法注册一个 ChannelFutureListener，当操作执行完成（成功或者失败）时，监听就会自动触发返回结果。\n\n###  ChannelHandler、ChannelPipeline\n\n####  ChannelHandler\n\nChannelHandler 为 Netty 中最核心的组件，它充当了所有处理入站和出站数据的应用程序逻辑的容器。ChannelHandler 主要用来处理各种事件，这里的事件很广泛，比如可以是连接、数据接收、异常、数据转换等。\n\nChannelHandler 有两个核心子类 ChannelInboundHandler 和 ChannelOutboundHandler，其中 ChannelInboundHandler 用于接收、处理入站数据和事件，而 ChannelOutboundHandler 则相反。我们经常通过一个ChannelInboundHandler的实现类来实现业务逻辑的处理。\n\n####  ChannelPipeline\n\nChannelPipeline 为 ChannelHandler 链提供了一个容器并定义了用于沿着链传播入站和出站事件流的 API。一个数据或者事件可能会被多个 Handler 处理，在这个过程中，数据或者事件经流 ChannelPipeline，由 ChannelHandler 处理。在这个处理过程中，一个 ChannelHandler 接收数据后处理完成后交给下一个 ChannelHandler，或者什么都不做直接交给下一个 ChannelHandler。 \n\n![](/png/netty/channelPipeline.jpg)\n\n当一个数据流进入 ChannlePipeline 时，它会从 ChannelPipeline 头部开始传给第一个 ChannelInboundHandler ，当第一个处理完后再传给下一个，一直传递到管道的尾部。与之相对应的是，当数据被写出时，它会从管道的尾部开始，先经过管道尾部的 “最后” 一个ChannelOutboundHandler，当它处理完成后会传递给前一个 ChannelOutboundHandler 。\n\n当ChannelHandler被添加到ChannelPipeline时，它将会被分配一个ChannelHandlerContext，代表了ChannelHandler和ChannelPipeline之间的绑定。\n\n####  编码器和解码器\n\n由于网络数据总是一系列的字节，通过Netty发送或者接受消息时，将会发生一次数据转换：入站消息会被解码，由字节转换为另一种格式，通常是一个Java对象；出站消息会被编码，从当前格式转换为字节。\n\nNetty提供了编码器的基类MessageToByteEncoder以及解码器的基类ByteToMessageDecoder，Netty提供的所有解码器/编码器适配器类都实现了ChannelInboundHandler或者ChannelOutboundHandler接口。如果我们要自定义的编码/解码规则，只需要继承基类，实现encode()/decode()方法。\n\n```java\n\t@Override\n    protected void encode(ChannelHandlerContext channelHandlerContext, Object iotPacketRequest, \n                            ByteBuf out) {\n        if (null == iotPacketRequest) {\n            return;\n        }\n        String body = JsonUtils.bean2Json(iotPacketRequest);\n        byte[] bodyBytes = body.getBytes(Charset.forName(\"utf-8\"));\n        out.writeShort(IotConnectProperties.MAGIC_CODE);\n        out.writeShort(bodyBytes.length);\n        out.writeBytes(bodyBytes);\n    }\n```\n\n###  服务端启动分析\n\n以创建一个Netty服务端为例\n\n```java\npublic class NettyServer {\n\n    public void bind(int port){\n        // 创建EventLoopGroup\n        EventLoopGroup bossGroup = new NioEventLoopGroup();\n        EventLoopGroup workerGroup = new NioEventLoopGroup();\n\n        try {\n            // 创建ServerBootStrap实例\n            // ServerBootstrap 用于启动NIO服务端的辅助启动类，目的是降低服务端的开发复杂度\n            ServerBootstrap b = new ServerBootstrap();\n            // 绑定Reactor线程池\n            b.group(bossGroup, workerGroup)\n                    // 设置并绑定服务端Channel\n                    // 指定所使用的NIO传输的Channel\n                    .channel(NioServerSocketChannel.class)\n                    .option(ChannelOption.SO_BACKLOG, 1024)\n                    .handler(new LoggingServerHandler())\n                    .childHandler(new ChannelInitializer(){\n                        @Override\n                        protected void initChannel(Channel ch) throws Exception {\n                            ch.pipeline().addLast(\"decoder\", new HttpRequestDecoder());\n                            ch.pipeline().addLast(\"encoder\", new HttpResponseEncoder());\n                            ch.pipeline().addLast(\"httpServerHandler\", new HttpServerHandler());\n                        }\n                    });\n\n            // 绑定端口，同步等待成功\n            ChannelFuture future = b.bind(port).sync();\n            // 等待服务端监听端口关闭\n            future.channel().closeFuture().sync();\n\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        } finally {\n            // 优雅地关闭\n            bossGroup.shutdownGracefully();\n            workerGroup.shutdownGracefully();\n        }\n    }\n}\n```\n\n服务端的创建主要步骤为：\n\n1. 创建 ServerBootstrap 实例\n2. 设置并绑定 Reactor 线程池\n3. 设置服务端 Channel\n4. 添加并设置 ChannelHandler\n5. 绑定并启动监听端口\n\n####  创建EventLoopGroup\n\n```java\nEventLoopGroup bossGroup = new NioEventLoopGroup();\nEventLoopGroup workerGroup = new NioEventLoopGroup();\n```\n\nbossGroup 为 BOSS 线程组，用于服务端接受客户端的连接, workerGroup 为 worker 线程组，用于进行 SocketChannel 的网络读写。 \n\n####  **创建ServerBootstrap实例**\n\n```java\nServerBootstrap b = new ServerBootstrap();\n```\n\nServerBootStrap为Netty服务端的启动引导类，用于帮助用户快速配置、启动服务端服务。 客户端的引导类是Bootstrap。ServerBootStrap 提供了如下一些方法\n\n| 方法名称  | 方法描述                                   |\n| --------- | ------------------------------------------ |\n| `group`   | 设置 ServerBootstrap 要用的 EventLoopGroup |\n| `channel` | 设置将要被实例化的 ServerChannel 类        |\n| `option`  | 实例化的 ServerChannel 的配置项            |\n| `Handler` | 设置并添加 Handler                         |\n| `bind`    | 绑定 ServerChannel                         |\n\n####  设置并绑定线程池\n\n```java\nb.group(bossGroup, workerGroup)\n```\n\n调用group()方法，为ServerBootstrap实例设置绑定reactor线程池\n\n```java\n\tpublic ServerBootstrap group(EventLoopGroup parentGroup, EventLoopGroup childGroup) {\n        super.group(parentGroup);        // 绑定boosGroup\n        if (childGroup == null) {\n            throw new NullPointerException(\"childGroup\");\n        }\n        if (this.childGroup != null) {\n            throw new IllegalStateException(\"childGroup set already\");\n        }\n        this.childGroup = childGroup;    // 绑定workerGroup\n        return this;\n    }\n```\n\n####  设置服务端Channel\n\n```\n.channel(NioServerSocketChannel.class)\n```\n\n调用channel()方法设置服务端Channel类型，注意这里参数是Class对象，Netty通过工厂类，利用反射来创建NioServerSocketChannel对象\n\n```java\n\tpublic B channel(Class<? extends C> channelClass) {\n        if (channelClass == null) {\n            throw new NullPointerException(\"channelClass\");\n        }\n        return channelFactory(new ReflectiveChannelFactory<C>(channelClass));\n    }\n```\n\n这里传递的是 ReflectiveChannelFactory，其源代码如下： \n\n```java\n\tpublic class ReflectiveChannelFactory<T extends Channel> implements ChannelFactory<T> {\n\n    private final Class<? extends T> clazz;\n\n    public ReflectiveChannelFactory(Class<? extends T> clazz) {\n        if (clazz == null) {\n            throw new NullPointerException(\"clazz\");\n        }\n        this.clazz = clazz;\n    }\n    //需要创建 channel 的时候，该方法将被调用\n    @Override\n    public T newChannel() {\n        try {\n            // 反射创建对应 channel\n            return clazz.newInstance();\n        } catch (Throwable t) {\n            throw new ChannelException(\"Unable to create Channel from class \" + clazz, t);\n        }\n    }\n\n    @Override\n    public String toString() {\n        return StringUtil.simpleClassName(clazz) + \".class\";\n    }\n}\n\n```\n\n####  添加并设置ChannelHandler\n\n```java\n \t.handler(new LoggingServerHandler())\n\t.childHandler(new ChannelInitializer(){\n\t\t@Override\n\t\tprotected void initChannel(Channel ch) throws Exception {\n\t\t\tch.pipeline().addLast(\"decoder\", new HttpRequestDecoder());\n\t\t\tch.pipeline().addLast(\"encoder\", new HttpResponseEncoder());\n\t\t\tch.pipeline().addLast(\"httpServerHandler\", new HttpServerHandler());\n\t\t}\n\t})\n\n```\n\n`handler()`设置的 Handler 是服务端 NioServerSocketChannel的，childHandler()`设置的 Handler 是属于每一个新建的 NioSocketChannel 的\n\n####  绑定端口，启动服务端\n\n绑定端口并启动服务，如下： \n\n```java\nChannelFuture future = b.bind(port).sync();\n\n```\n\n深入源码我们发现核心方法有两个`initAndRegister()`， `doBind0()`\n\n#####  initAndRegister()\n\n```java\nfinal ChannelFuture initAndRegister() {\n    Channel channel = null;\n    // ...\n    channel = channelFactory.newChannel();\n    //...\n    init(channel);\n    //...\n    ChannelFuture regFuture = config().group().register(channel);\n    //...\n    return regFuture;\n}\n\n```\n\ninitAndRegister做了3件事：\n\n1.**new一个Channel**\n\n```java\nchannel = channelFactory.newChannel();\n\n```\n\n前面在ServerBootstrap实例设置服务端Channel时，设置了这个Channel的类型，这里就通过工厂类的方法生成NioServerSocketChannel对象。\n\n追溯NioServerSocketChannel的默认构造函数，我们可以发现在构造该实例时，设置了channel为非阻塞模式、SelectionKey.OP_ACCEPT事件、channelId 、NioMessageUnsafe(封装了用于数据传输操作的函数)、DefaultChannelPipeline和 NioServerSocketChannelConfig 属性。 \n\n2.**init这个Channel**\n\n```java\nvoid init(Channel channel) throws Exception {\n         // 设置配置的option参数\n        final Map<ChannelOption<?>, Object> options = options0();\n        synchronized (options) {\n            channel.config().setOptions(options);\n        }\n\n        final Map<AttributeKey<?>, Object> attrs = attrs0();\n        synchronized (attrs) {\n            for (Entry<AttributeKey<?>, Object> e: attrs.entrySet()) {\n                @SuppressWarnings(\"unchecked\")\n                AttributeKey<Object> key = (AttributeKey<Object>) e.getKey();\n                channel.attr(key).set(e.getValue());\n            }\n        }\n\n        // 获取绑定的pipeline\n        ChannelPipeline p = channel.pipeline();\n\n        // 准备child用到的4个part\n        final EventLoopGroup currentChildGroup = childGroup;\n        final ChannelHandler currentChildHandler = childHandler;\n        final Entry<ChannelOption<?>, Object>[] currentChildOptions;\n        final Entry<AttributeKey<?>, Object>[] currentChildAttrs;\n        synchronized (childOptions) {\n            currentChildOptions = childOptions.entrySet().toArray(newOptionArray(childOptions.size()));\n        }\n        synchronized (childAttrs) {\n            currentChildAttrs = childAttrs.entrySet().toArray(newAttrArray(childAttrs.size()));\n        }\n\n        // 为NioServerSocketChannel的pipeline添加一个初始化Handler,\n        // 当NioServerSocketChannel在EventLoop注册成功时，该handler的init方法将被调用\n        p.addLast(new ChannelInitializer<Channel>() {\n            @Override\n            public void initChannel(Channel ch) throws Exception {\n                final ChannelPipeline pipeline = ch.pipeline();\n                ChannelHandler handler = config.handler();\n                //如果用户配置过Handler\n                if (handler != null) {\n                    pipeline.addLast(handler);\n                }\n\n                ch.eventLoop().execute(new Runnable() {\n                    @Override\n                    public void run() {\n                        // 为NioServerSocketChannel的pipeline添加ServerBootstrapAcceptor处理器\n                        // 该Handler主要用来将新创建的NioSocketChannel注册到EventLoopGroup中\n                        pipeline.addLast(new ServerBootstrapAcceptor(\n                                currentChildGroup, currentChildHandler, currentChildOptions, currentChildAttrs));\n                    }\n                });\n            }\n        });\n    }\n\n```\n\n我们发现init其实就做了三件事：\n\n- 设置options、attrs\n- 设置新接入Channel的options、attrs\n- 将用于服务端注册的 Handler ServerBootstrapAcceptor 添加到 ServerChannel的ChannelPipeline 中。ServerBootstrapAcceptor 为一个接入器，专门接受新请求。\n\n3.**向EventLoopGroup中注册这个Channel**\n\n```java\n\tChannelFuture regFuture = config().group().register(channel);\n\n```\n\n通过追溯我们发现过程如下：\n\n```java\n\tpublic ChannelFuture register(Channel channel) {\n        return next().register(channel);\n    }\n\n```\n\n调用 `next()` 方法从 EventLoopGroup 中获取下一个 EventLoop，调用 `register()` 方法注册： \n\n```java\n\tpublic ChannelFuture register(Channel channel) {\n        return register(new DefaultChannelPromise(channel, this));\n    }\n\n```\n\n将Channel和EventLoop封装成一个DefaultChannelPromise对象，然后调用register()方法。DefaultChannelPromis为ChannelPromise的默认实现，而ChannelPromisee继承Future，具备异步执行结构，绑定Channel，所以又具备了监听的能力，故而ChannelPromis是Netty异步执行的核心接口。 \n\n```java\n\tpublic ChannelFuture register(ChannelPromise promise) {\n        ObjectUtil.checkNotNull(promise, \"promise\");\n        promise.channel().unsafe().register(this, promise);\n        return promise;\n    }\n\n```\n\nunsafe就是我们之前构造NioServerSocketChannel时new的对象，这里调用register方法过程如下：\n\n```java\n\t\tpublic final void register(EventLoop eventLoop, final ChannelPromise promise) {\n            if (eventLoop == null) {\n                throw new NullPointerException(\"eventLoop\");\n            }\n            if (isRegistered()) {\n                promise.setFailure(new IllegalStateException(\"registered to an event loop already\"));\n                return;\n            }\n            if (!isCompatible(eventLoop)) {\n                promise.setFailure(\n                        new IllegalStateException(\"incompatible event loop type: \" + eventLoop.getClass().getName()));\n                return;\n            }\n\n            AbstractChannel.this.eventLoop = eventLoop;\n\n            // 必须要保证注册是由该EventLoop发起的\n            if (eventLoop.inEventLoop()) {\n                register0(promise);        // 注册\n            } else {\n                // 如果不是单独封装成一个task异步执行\n                try {\n                    eventLoop.execute(new Runnable() {\n                        @Override\n                        public void run() {\n                            register0(promise);\n                        }\n                    });\n                } catch (Throwable t) {\n                    logger.warn(\n                            \"Force-closing a channel whose registration task was not accepted by an event loop: {}\",\n                            AbstractChannel.this, t);\n                    closeForcibly();\n                    closeFuture.setClosed();\n                    safeSetFailure(promise, t);\n                }\n            }\n        }\t\n\n```\n\n首先通过`isRegistered()` 判断该 Channel 是否已经注册到 EventLoop 中；  \n\n通过 `eventLoop.inEventLoop()` 来判断当前线程是否为该 EventLoop 自身发起的，如果是，则调用 `register0()` 直接注册;\n\n如果不是，说明该 EventLoop 中的线程此时没有执行权，则需要新建一个线程，单独封装一个 Task，而该 Task 的主要任务则是执行`register0()`。 \n\n```java\n\t\tprivate void register0(ChannelPromise promise) {\n            try {\n                // 确保 Channel 处于 open\n                if (!promise.setUncancellable() || !ensureOpen(promise)) {\n                    return;\n                }\n                boolean firstRegistration = neverRegistered;\n\n                // 真正的注册动作\n                doRegister();\n\n                neverRegistered = false;\n                registered = true;        \n\n                pipeline.invokeHandlerAddedIfNeeded();    \n                safeSetSuccess(promise);        //设置注册结果为成功\n\n                pipeline.fireChannelRegistered();\n\n                if (isActive()) { \n                    //如果是首次注册,发起 pipeline 的 fireChannelActive\n                    if (firstRegistration) {\n                        pipeline.fireChannelActive();\n                    } else if (config().isAutoRead()) {\n                        beginRead();\n                    }\n                }\n            } catch (Throwable t) {\n                closeForcibly();\n                closeFuture.setClosed();\n                safeSetFailure(promise, t);\n            }\n        }\n\n```\n\n如果 Channel 处于 open 状态，则调用 `doRegister()` 方法完成注册，然后将注册结果设置为成功。最后判断如果是首次注册且处于激活状态，则发起 pipeline 的 `fireChannelActive()`。\n\n```java\n\tprotected void doRegister() throws Exception {\n        boolean selected = false;\n        for (;;) {\n            try {\n                // 注册到NIOEventLoop的Selector上\n                selectionKey = javaChannel().register(eventLoop().selector, 0, this);\n                return;\n            } catch (CancelledKeyException e) {\n                if (!selected) {\n                    eventLoop().selectNow();\n                    selected = true;\n                } else {\n                    throw e;\n                }\n            }\n        }\n    }\n\n```\n\n因为当前没有将一个ServerSocket绑定到一个address\n\n```java\n\tif (isActive()) { \n\t\t//如果是首次注册,发起 pipeline 的 fireChannelActive\n\t\tif (firstRegistration) {\n\t\t\tpipeline.fireChannelActive();\n\t\t} else if (config().isAutoRead()) {\n\t\t\tbeginRead();\n\t\t}\n\t}\n\n```\n\n```java\n\tpublic boolean isActive() {\n        return this.javaChannel().socket().isBound();\n    }\n\n```\n\n```java\n\tprotected void doBeginRead() throws Exception {\n        SelectionKey selectionKey = this.selectionKey;\n        if (selectionKey.isValid()) {\n            this.readPending = true;\n            int interestOps = selectionKey.interestOps();\n            if ((interestOps & this.readInterestOp) == 0) {\n                selectionKey.interestOps(interestOps | this.readInterestOp);\n            }\n\n        }\n    }\n\n```\n\n这里将selectionKey的监听操作设置为之前构造NioServerSocketChannel设置的SelectionKey.OP_ACCEPT\n\n##### he doBind0()\n\n追溯doBind0()的实现，我们可以发现会调用初始化时NioMessageUnsafe的bind方法\n\n```java\n@Override\npublic final void bind(final SocketAddress localAddress, final ChannelPromise promise) {\n    // ...\n    boolean wasActive = isActive();\n    // ...\n    doBind(localAddress);\n\n    if (!wasActive && isActive()) {\n        invokeLater(new Runnable() {\n            @Override\n            public void run() {\n                pipeline.fireChannelActive();\n            }\n        });\n    }\n    safeSetSuccess(promise);\n}\n\n```\n\ndoBind(localAddress) 调用JDK的代码，实现了端口绑定\n\n```\nprotected void doBind(SocketAddress localAddress) throws Exception {\n    if (PlatformDependent.javaVersion() >= 7) {\n        //noinspection Since15\n        javaChannel().bind(localAddress, config.getBacklog());\n    } else {\n        javaChannel().socket().bind(localAddress, config.getBacklog());\n    }\n}\n\n```\n\n绑定后isActice()返回true，fireChannelActive() 被调用。\n\n## 4 内存管理\n\n### 4.1 ByteBuffer、ByteBuf\n\n为了减少频繁I/O操作，引进了Buffer的概念，把突发的大数量较小规模的 I/O 整理成平稳的小数量较大规模的 I/O 。Java NIO封装了ByteBuffer组件。ByteBuffer具有4个重要的属性：mark、position、limit、capacity ，以及两个重要的方法clear()、flip()\n\n1. position:读写指针，代表当前读或写操作的位置，这个值总是小于等于limit的。\n2. mark：在使用ByteBuffer的过程中，如果想要记住当前的position，则会将当前的position值给mark，需要恢复的时候，再将mark的值给position。\n3. capacity：代表这块内存区域的大小。\n4. limit：初始的Buffer中，limit和capacity的值是相等的，通常在clear操作和flip操作的时候会对这个值进行操作，在clear操作的时候会将这个值和capacity的值设置为相等，当flip的时候会将当前的position的值给limit，我们可以总结在写的时候，limit的值代表最大的可写位置，在读的时候，limit的值代表最大的可读位置。\n\n![](/png/netty/ByteBuffer.png)\n\n在写操作之前调用clear()\n\n```java\npublic final Buffer clear() { \n\tposition = 0; //设置当前下标为0\n\tlimit = capacity; //设置写越界位置与和Buffer容量相同\n\tmark = -1; //取消标记\n\treturn this; \n} \n\n```\n\n在读操作之前调用flip()\n\n```java\npublic final Buffer flip() { \n\tlimit = position; \n\tposition = 0; \n\tmark = -1; \n\treturn this; \n }  \n\n```\n\nByteBuffer具有以下缺陷\n\n- ByteBuffer长度固定，一旦分配完成，它的容量不能动态扩展和收缩，当需要编码的POJO对象大于ByteBuffer的容量时，会发生索引越界异常；\n- ByteBuffer只有一个标识位控的指针position，读写的时候需要手工调用 flip() 和 clear() 等；\n- ByteBuffer的API功能有限，一些高级和实用的特性它不支持，需要使用者自己编程实现。\n\nNetty为了解决ByteBuffer的缺陷，重写了一个新的数据接口ByteBuf。 与ByteBuffer相比，ByteBuf提供了两个指针 readerIndex 和 writeIndex 来分别指向读的位置和写的位置，不需要每次为读写做准备，直接设置读写指针进行读写操作即可。 \n\n![](/png/netty/读写中间状态的Buffer.png)\n\n这是中间状态的Buffer，可以通过调用discardReadBytes方法来回收已读区域\n\n![](/png/netty/discardReadBytes.png)\n\n通过clear方法清楚指针状态\n\n![](/png/netty/clear后的Buffer.png)\n\n对比ByteBuffer，使用ByteBuf读的时候仅仅依赖readerIndex指针，写的时候仅仅依赖writerIndex指针，不需每次读写之前调用对应的方法，而且没有必须一次读完的限制。 \n\n### 4.2 内存管理\n\n#### 4.2.1 零拷贝\n\n当JVM堆内存上的数据需要和IO设备进行I/O操作时，会将JVM堆上所维护的byte[]拷贝至堆外内存（一般是通过C/C++分配的内存），然后堆外内存直接和IO设备交互。这是因为**JVM需要进行GC，如果IO设备直接和JVM堆上的数据进行交互，这个时候JVM进行了GC，那么有可能会导致没有被回收的数据进行了压缩，位置被移动到了连续的存储区域，这样会导致正在进行的IO操作相关的数据全部乱套**。\n\nNIO可以使用native 函数库直接分配堆外内存，然后通过一个存储在堆上的DirectByteBuffer 对象作为这块内存的引用进行操作，避免了在Java堆和Native堆中来回复制数据。 \n\n#### 4.2.2 内存泄漏\n\n从堆中分配的缓冲区HeapByteBuffer为普通的Java对象，生命周期与普通的Java对象一样，当不再被引用时，Buffer对象会被回收。而直接缓冲区（DirectByteBuffer）为堆外内存，并不在Java堆中，也不能被JVM垃圾回收。由于直接缓冲区在JVM里被包装进Java对象DirectByteBuffer中，当它的包装类被垃圾回收时，会调用相应的JNI方法释放堆外内存，所以堆外内存的释放也依赖于JVM中DirectByteBuffer对象的回收。\n\n由于垃圾回收本身成本较高，一般JVM在堆内存未耗尽时，不会进行垃圾回收操作。如果不断分配本地内存，堆内存很少使用，那么JVM就不需要执行GC，DirectByteBuffer对象们就不会被回收，这时候堆内存充足，但本地内存可能已经使用光了，再次尝试分配本地内存就会出现OutOfMemoryError，那程序就直接崩溃了。\n\n#### 4.2.3 ByteBuf引用计数\n\n```java\npublic interface ReferenceCounted {\n    int refCnt();\n\n    ReferenceCounted retain();\n\n    ReferenceCounted retain(int var1);\n\n    ReferenceCounted touch();\n\n    ReferenceCounted touch(Object var1);\n\n    boolean release();\n\n    boolean release(int var1);\n}\n\n```\n\nByteBuf扩展了ReferenceCountered接口 ，这个接口定义的功能主要是引用计数。\n\n当 ByteBuf 引用+1的时候，需要调用 retain() 来让refCnt + 1，当Buffer引用数-1的时候需要调用 release() 来让 refCnt - 1。当refCnt变为0的时候Netty为pooled和unpooled的不同buffer提供了不同的实现，通常对于非内存池的用法，Netty把Buffer的内存回收交给了垃圾回收器，对于内存池的用法，Netty对内存的回收实际上是回收到内存池内，以提供下一次的申请所使用。\n\n#### 4.2.4 池化\n\n如果对于Buffer的使用都基于直接内存实现的话，将会大大提高I/O效率，然而直接内存空间的申请比堆内存要消耗更高的性能。\n\n因此Netty结合引用计数实现了PolledBuffer，即池化的用法，当引用计数等于0的时候，Netty将Buffer回收至池中，在下一次申请Buffer的时刻会被复用。 \n\n堆内存和直接内存的池化实现分别是PooledHeapByteBuf和PooledDirectByteBuf，在各自的实现中都维护着一个Recycler 。Recycler是一个抽象类，向外部提供了两个公共方法get和recycle分别用于从对象池中获取对象和回收对象。\n\n以PooledHeapByteBuf为例，新建PooledHeapByteBuf对象时\n\n```java\n\tstatic PooledHeapByteBuf newInstance(int maxCapacity) {\n        PooledHeapByteBuf buf = (PooledHeapByteBuf)RECYCLER.get();\n        buf.reuse(maxCapacity);\n        return buf;\n    }\n\n```\n\n当Buffer引用数 -1时\n\n```java\n\tpublic boolean release(int decrement) {\n        return this.release0(ObjectUtil.checkPositive(decrement, \"decrement\"));\n    }\n\n    private boolean release0(int decrement) {\n        int oldRef = refCntUpdater.getAndAdd(this, -decrement);\n        if (oldRef == decrement) {\n            this.deallocate();\n            return true;\n        } else if (oldRef >= decrement && oldRef - decrement <= oldRef) {\n            return false;\n        } else {\n            refCntUpdater.getAndAdd(this, decrement);\n            throw new IllegalReferenceCountException(oldRef, -decrement);\n        }\n    }\n\n```\n\nPooledByteBuf.class\n\n```java\nprotected final void deallocate() {\n    if (this.handle >= 0L) {\n        long handle = this.handle;\n        this.handle = -1L;\n        this.memory = null;\n        this.tmpNioBuf = null;\n        this.chunk.arena.free(this.chunk, handle, this.maxLength, this.cache);\n        this.chunk = null;\n        this.recycle();\n    }\n\n}\n\nprivate void recycle() {\n    this.recyclerHandle.recycle(this);\n}\n\n```\n\n### 4.3 半包读写\n\nTCP是个\"流\"协议，所谓流，就是没有界限没有分割的一串数据。TCP会根据缓冲区的实际情况进行包划分，一个完整的包可能会拆分成多个包进行发送，也用可能把多个小包封装成一个大的数据包发送。这就是TCP粘包/拆包。\n\n举个例子：假设操作系统已经接收到了三个包，如下：\n\n![](/png/netty/流-拆包.png)\n\n由于流传输的这个普通属性，在读取他们的时候将会存在很大的几率，这些数据会被分段成下面的几部分：\n\n![](/png/netty/流-粘包.png)\n\n也就是读取的数据有可能超过一个完整的数据包或者过多或者过少的半包。\n\n因此，作为一个接收方，不管它是服务端还是客户端，都需要把接收到的数据整理成一个或多个有意义的并且能够被应用程序容易理解的数据。\n\n**拆包方案：**\n\n- **消息定长**，固定报文长度，不够空格补全，发送和接收方遵循相同的约定，这样即使粘包了通过接收方编程实现获取定长报文也能区分。\n- **包尾添加特殊分隔符**，例如每条报文结束都添加回车换行符（例如FTP协议）或者指定特殊字符作为报文分隔符，接收方通过特殊分隔符切分报文区分。\n- **将消息分为消息头和消息体**，消息头中包含表示信息的总长度（或者消息体长度）的字段\n\n**Netty提供了几种解码器：**\n\n- 定长解码器：FixedLengthFrameDecoder\n\n```\nch.pipeline().addLast(new FixedLengthFrameDecoder(30));//设置定长解码器\n\n```\n\n- 特殊分隔符解码器：DelimiterBasedFrameDecoder\n\n```\nByteBuf delimiter = Unpooled.copiedBuffer(\"&\".getBytes());\n//1024表示单条消息的最大长度，解码器在查找分隔符的时候，达到该长度还没找到的话会抛异常\nch.pipeline().addLast(new DelimiterBasedFrameDecoder(1024,delimiter));\n\n```\n\n- 基于包头不固定长度的解码器：LengthFieldBasedFrameDecoder\n\n```java\n/**\n * maxFrameLength：解码的帧的最大长度\n * lengthFieldOffset：长度属性的起始位（偏移位），包中存放有整个大数据包长度的字节，这段字节的其实位置\n * lengthFieldLength：长度属性的长度，即存放整个大数据包长度的字节所占的长度\n * lengthAdjustmen：长度调节值，在总长被定义为包含包头长度时，修正信息长度。\n * initialBytesToStrip：跳过的字节数，根据需要我们跳过lengthFieldLength个字节，以便接收端直接接受到不\n                        含“长度属性”的内容\n */\nch.pipeline().addLast(\"decoder\", new LengthFieldBasedFrameDecoder(MAX_FRAME_LENGTH, LENGTH_OFFSET, \n                                    LENGTH_LEN, LENGTH_ADJUGEMENT, INIT_BYTE_TO_STRIP));\n\n```\n\n**参考资料**\n\n| 资料名称           | 来源                                        |\n| ------------------ | ------------------------------------------- |\n| 《Netty实战》      | 图书                                        |\n| 《Netty权威指南》  | 图书                                        |\n| Netty官网wiki      | https://netty.io/wiki/related-articles.html |\n| 其他互联网资料链接 | 见最后                                      |\n\n\n**参考链接：**\n\nhttps://netty.io/index.html\nhttps://blog.csdn.net/syc001/article/details/72841945\nhttp://ifeve.com/%E8%B0%88%E8%B0%88netty%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/\nhttps://www.cnblogs.com/wxd0108/p/6681627.html\nhttps://my.oschina.net/plucury/blog/192577\nhttps://blog.csdn.net/chenssy/article/details/78714003","slug":"Netty浅析","published":1,"updated":"2019-09-10T16:49:02.875Z","_id":"ck0e0icv100058wudqj6z5jxa","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h2><p>Netty是一款异步的事件驱动的网络应用程序框架，支持快速地开发可维护的高性能的面向协议的服务器和客户端。它提供了对TCP、UDP和文件传输的支持，作为一个异步NIO框架，Netty的所有IO操作都是异步非阻塞的，通过Future-Listener机制，用户可以方便的主动获取或者通过通知机制获得IO操作结果。</p>\n<a id=\"more\"></a>\n\n<p><img src=\"/png/netty/netty.png\" alt></p>\n<p>为什么用Netty不用NIO</p>\n<ol>\n<li>NIO的类库和API繁杂，使用麻烦，你需要熟练掌握Selector、ServerSocketChannel、SocketChannel、ByteBuffer等；</li>\n<li>需要具备其它的额外技能做铺垫，例如熟悉Java多线程编程，因为NIO编程涉及到Reactor模式，你必须对多线程和网路编程非常熟悉，才能编写出高质量的NIO程序；</li>\n<li>可靠性能力补齐，工作量和难度都非常大。例如客户端面临断连重连、网络闪断、半包读写、失败缓存、网络拥塞和异常码流的处理等等，NIO编程的特点是功能开发相对容易，但是可靠性能力补齐工作量和难度都非常大；</li>\n<li>JDK NIO的BUG，例如epoll bug，它会导致Selector空轮询，最终导致CPU 100%。官方声称在JDK1.6版本的update18修复了该问题，但是直到JDK1.7版本该问题仍旧存在，只不过该bug发生概率降低了一些而已，它并没有被根本解决。</li>\n</ol>\n<h2 id=\"Reactor模式和Netty线程模型\"><a href=\"#Reactor模式和Netty线程模型\" class=\"headerlink\" title=\"Reactor模式和Netty线程模型\"></a>Reactor模式和Netty线程模型</h2><h3 id=\"什么是reactor模式\"><a href=\"#什么是reactor模式\" class=\"headerlink\" title=\"什么是reactor模式\"></a>什么是reactor模式</h3><p>Reactor模式是<strong>事件驱动的，有一个或多个并发输入源，有一个Service Handler，有多个Request Handlers</strong>；这个Service Handler会同步的将输入的请求多路复用的分发给相应的Request Handler。 </p>\n<p><img src=\"/png/netty/reactor%E6%A8%A1%E5%BC%8F.png\" alt></p>\n<h3 id=\"3种reactor模式\"><a href=\"#3种reactor模式\" class=\"headerlink\" title=\"3种reactor模式\"></a>3种reactor模式</h3><h4 id=\"单线程的reactor模式\"><a href=\"#单线程的reactor模式\" class=\"headerlink\" title=\"单线程的reactor模式\"></a>单线程的reactor模式</h4><p><img src=\"/png/netty/%E5%8D%95%E7%BA%BF%E7%A8%8Breactor%E6%A8%A1%E5%9E%8B.jpg\" alt></p>\n<p>Reactor线程是个多面手，负责多路分离套接字，Accept新连接，并分派请求到处理器链中。该模型适用于处理器链中业务处理组件能快速完成的场景。不过，这种单线程模型不能充分利用多核资源，所以实际使用的不多。 </p>\n<p>性能缺陷：</p>\n<ol>\n<li>一个NIO线程同时处理成百上千的链路，性能上无法支撑。即便NIO线程的CPU负荷达到100%，也无法满足海量消息的编码、解码、读取和发送；</li>\n<li>当NIO线程负载过重之后，处理速度将变慢，这会导致大量客户端连接超时，超时之后往往进行重发，这更加重了NIO线程的负载，最终导致大量消息积压和处理超时，NIO线程会成为系统的性能瓶颈；</li>\n<li>可靠性问题。一旦NIO线程出现错误，或者进入死循环，会导致整个系统通讯模块不可用，不能接收和处理外部信息，造成节点故障。</li>\n</ol>\n<h4 id=\"多线程的reactor模式\"><a href=\"#多线程的reactor模式\" class=\"headerlink\" title=\"多线程的reactor模式\"></a>多线程的reactor模式</h4><p><img src=\"/png/netty/%E5%A4%9A%E7%BA%BF%E7%A8%8Breactor%E6%A8%A1%E5%9E%8B.jpg\" alt></p>\n<p>Reactor多线程模型的特点：</p>\n<ol>\n<li>有专门一个NIO线程-Acceptor线程用于监听服务端，接收客户端的TCP连接请求； </li>\n<li>网络IO操作-读、写等由一个NIO线程池负责，线程池可以采用标准的JDK线程池实现，它包含一个任务队列和N个可用的线程，由这些NIO线程负责消息的读取、解码、编码和发送； </li>\n<li>1个NIO线程可以同时处理N条链路，但是1个链路只对应1个NIO线程，防止发生并发操作问题。</li>\n</ol>\n<p>在绝大多数场景下，Reactor多线程模型都可以满足性能需求；但是，当用户进一步增加的时候，一个NIO线程负责监听和处理所有的客户端连接可能会存在性能问题。例如并发百万客户端连接，或者服务端需要对客户端握手进行安全认证，但是认证本身非常损耗性能。在这类场景下，单独一个Acceptor线程可能会存在性能不足问题。</p>\n<h4 id=\"主从reactor多线程模型\"><a href=\"#主从reactor多线程模型\" class=\"headerlink\" title=\"主从reactor多线程模型\"></a>主从reactor多线程模型</h4><p><img src=\"/png/netty/%E4%B8%BB%E4%BB%8E%E6%A8%A1%E5%BC%8Freactor%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B.jpg\" alt></p>\n<p>注册accepter事件处理器到mainReactor线程池中，这样mainReactor会监听客户端向服务端发起的连接请求</p>\n<p>当客户端向服务端发起连接请求时，mainReactor监听到了该请求将事件派发给acceptor事件处理器进行处理，可通过accept方法获得连接socketChannel，然后将socketChannel传递给subReactor线程池</p>\n<p>subReactor线程池分配一个subReactor线程给这个SocketChannel，监听I/O的read、write操作，相关业务逻辑的处理交给工作线程池来完成</p>\n<h3 id=\"Netty的线程模型\"><a href=\"#Netty的线程模型\" class=\"headerlink\" title=\"Netty的线程模型\"></a>Netty的线程模型</h3><p><img src=\"/png/netty/netty%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B.png\" alt></p>\n<p>当NettyServer启动时候会创建两个NioEventLoopGroup线程池组。</p>\n<p>boss组用来接受客户端发来的连接，在监听一个端口的情况下，一个NioEventLoop通过一个NioServerSocketChannel监听端口，处理TCP连接。worker组则负责对完成TCP三次握手的连接进行处理。</p>\n<p>如上图每个NioEventLoopGroup里面包含了多个NioEventLoop，每个NioEventLoop中包含了一个NIO Selector、一个队列、一个线程；其中线程用来做轮询注册到Selector上的Channel的读写事件和对投递到队列里面的事件进行处理。 </p>\n<h2 id=\"核心组件\"><a href=\"#核心组件\" class=\"headerlink\" title=\"核心组件\"></a>核心组件</h2><h3 id=\"Channel接口、EventLoop接口\"><a href=\"#Channel接口、EventLoop接口\" class=\"headerlink\" title=\"Channel接口、EventLoop接口\"></a>Channel接口、EventLoop接口</h3><p>Channel 是 Netty 网络操作抽象类，它除了包括基本的 I/O 操作，如 bind、connect、read、write 之外，还包括了 Netty 框架相关的一些功能，如获取该 Channe l的 EventLoop。 </p>\n<p>在传统的网络编程中，作为核心类的 Socket ，它对程序员来说并不是那么友好，直接使用其成本还是稍微高了点。而Netty 的 Channel 则提供的一系列的 API ，它大大降低了直接与 Socket 进行操作的复杂性。 </p>\n<p>Netty 基于事件驱动模型，使用不同的事件来通知我们状态的改变或者操作状态的改变。它定义了在整个连接的生命周期里当有事件发生的时候处理的核心抽象。</p>\n<p>Channel 为Netty 网络操作抽象类，EventLoop 主要是为Channel 处理 I/O 操作，两者配合参与 I/O 操作。</p>\n<p><img src=\"/png/netty/channel&eventLoop.jpg\" alt></p>\n<ul>\n<li>一个EventLoopGroup包含一个或者多个EventLoop</li>\n<li>一个EventLoop在他的生命周期只和一个线程绑定</li>\n<li>所有由EventLoop处理的I/O事件都将在它专有的线程上被处理</li>\n<li>一个Channel在它的生命周期内只注册于一个EventLoop</li>\n<li>一个EventLoop可能会被分配给一个或多个Channel</li>\n</ul>\n<h3 id=\"ChannelFuture接口\"><a href=\"#ChannelFuture接口\" class=\"headerlink\" title=\"ChannelFuture接口\"></a>ChannelFuture接口</h3><p>Netty 为异步非阻塞，即所有的 I/O 操作都为异步的，因此，我们不能立刻得知消息是否已经被处理了。Netty 提供了 ChannelFuture 接口，通过该接口的 addListener() 方法注册一个 ChannelFutureListener，当操作执行完成（成功或者失败）时，监听就会自动触发返回结果。</p>\n<h3 id=\"ChannelHandler、ChannelPipeline\"><a href=\"#ChannelHandler、ChannelPipeline\" class=\"headerlink\" title=\"ChannelHandler、ChannelPipeline\"></a>ChannelHandler、ChannelPipeline</h3><h4 id=\"ChannelHandler\"><a href=\"#ChannelHandler\" class=\"headerlink\" title=\"ChannelHandler\"></a>ChannelHandler</h4><p>ChannelHandler 为 Netty 中最核心的组件，它充当了所有处理入站和出站数据的应用程序逻辑的容器。ChannelHandler 主要用来处理各种事件，这里的事件很广泛，比如可以是连接、数据接收、异常、数据转换等。</p>\n<p>ChannelHandler 有两个核心子类 ChannelInboundHandler 和 ChannelOutboundHandler，其中 ChannelInboundHandler 用于接收、处理入站数据和事件，而 ChannelOutboundHandler 则相反。我们经常通过一个ChannelInboundHandler的实现类来实现业务逻辑的处理。</p>\n<h4 id=\"ChannelPipeline\"><a href=\"#ChannelPipeline\" class=\"headerlink\" title=\"ChannelPipeline\"></a>ChannelPipeline</h4><p>ChannelPipeline 为 ChannelHandler 链提供了一个容器并定义了用于沿着链传播入站和出站事件流的 API。一个数据或者事件可能会被多个 Handler 处理，在这个过程中，数据或者事件经流 ChannelPipeline，由 ChannelHandler 处理。在这个处理过程中，一个 ChannelHandler 接收数据后处理完成后交给下一个 ChannelHandler，或者什么都不做直接交给下一个 ChannelHandler。 </p>\n<p><img src=\"/png/netty/channelPipeline.jpg\" alt></p>\n<p>当一个数据流进入 ChannlePipeline 时，它会从 ChannelPipeline 头部开始传给第一个 ChannelInboundHandler ，当第一个处理完后再传给下一个，一直传递到管道的尾部。与之相对应的是，当数据被写出时，它会从管道的尾部开始，先经过管道尾部的 “最后” 一个ChannelOutboundHandler，当它处理完成后会传递给前一个 ChannelOutboundHandler 。</p>\n<p>当ChannelHandler被添加到ChannelPipeline时，它将会被分配一个ChannelHandlerContext，代表了ChannelHandler和ChannelPipeline之间的绑定。</p>\n<h4 id=\"编码器和解码器\"><a href=\"#编码器和解码器\" class=\"headerlink\" title=\"编码器和解码器\"></a>编码器和解码器</h4><p>由于网络数据总是一系列的字节，通过Netty发送或者接受消息时，将会发生一次数据转换：入站消息会被解码，由字节转换为另一种格式，通常是一个Java对象；出站消息会被编码，从当前格式转换为字节。</p>\n<p>Netty提供了编码器的基类MessageToByteEncoder以及解码器的基类ByteToMessageDecoder，Netty提供的所有解码器/编码器适配器类都实现了ChannelInboundHandler或者ChannelOutboundHandler接口。如果我们要自定义的编码/解码规则，只需要继承基类，实现encode()/decode()方法。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">encode</span><span class=\"params\">(ChannelHandlerContext channelHandlerContext, Object iotPacketRequest, </span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                           ByteBuf out)</span> </span>&#123;</span><br><span class=\"line\">       <span class=\"keyword\">if</span> (<span class=\"keyword\">null</span> == iotPacketRequest) &#123;</span><br><span class=\"line\">           <span class=\"keyword\">return</span>;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">       String body = JsonUtils.bean2Json(iotPacketRequest);</span><br><span class=\"line\">       <span class=\"keyword\">byte</span>[] bodyBytes = body.getBytes(Charset.forName(<span class=\"string\">\"utf-8\"</span>));</span><br><span class=\"line\">       out.writeShort(IotConnectProperties.MAGIC_CODE);</span><br><span class=\"line\">       out.writeShort(bodyBytes.length);</span><br><span class=\"line\">       out.writeBytes(bodyBytes);</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"服务端启动分析\"><a href=\"#服务端启动分析\" class=\"headerlink\" title=\"服务端启动分析\"></a>服务端启动分析</h3><p>以创建一个Netty服务端为例</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">NettyServer</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">bind</span><span class=\"params\">(<span class=\"keyword\">int</span> port)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 创建EventLoopGroup</span></span><br><span class=\"line\">        EventLoopGroup bossGroup = <span class=\"keyword\">new</span> NioEventLoopGroup();</span><br><span class=\"line\">        EventLoopGroup workerGroup = <span class=\"keyword\">new</span> NioEventLoopGroup();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 创建ServerBootStrap实例</span></span><br><span class=\"line\">            <span class=\"comment\">// ServerBootstrap 用于启动NIO服务端的辅助启动类，目的是降低服务端的开发复杂度</span></span><br><span class=\"line\">            ServerBootstrap b = <span class=\"keyword\">new</span> ServerBootstrap();</span><br><span class=\"line\">            <span class=\"comment\">// 绑定Reactor线程池</span></span><br><span class=\"line\">            b.group(bossGroup, workerGroup)</span><br><span class=\"line\">                    <span class=\"comment\">// 设置并绑定服务端Channel</span></span><br><span class=\"line\">                    <span class=\"comment\">// 指定所使用的NIO传输的Channel</span></span><br><span class=\"line\">                    .channel(NioServerSocketChannel.class)</span><br><span class=\"line\">                    .option(ChannelOption.SO_BACKLOG, <span class=\"number\">1024</span>)</span><br><span class=\"line\">                    .handler(<span class=\"keyword\">new</span> LoggingServerHandler())</span><br><span class=\"line\">                    .childHandler(<span class=\"keyword\">new</span> ChannelInitializer()&#123;</span><br><span class=\"line\">                        <span class=\"meta\">@Override</span></span><br><span class=\"line\">                        <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">initChannel</span><span class=\"params\">(Channel ch)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">                            ch.pipeline().addLast(<span class=\"string\">\"decoder\"</span>, <span class=\"keyword\">new</span> HttpRequestDecoder());</span><br><span class=\"line\">                            ch.pipeline().addLast(<span class=\"string\">\"encoder\"</span>, <span class=\"keyword\">new</span> HttpResponseEncoder());</span><br><span class=\"line\">                            ch.pipeline().addLast(<span class=\"string\">\"httpServerHandler\"</span>, <span class=\"keyword\">new</span> HttpServerHandler());</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// 绑定端口，同步等待成功</span></span><br><span class=\"line\">            ChannelFuture future = b.bind(port).sync();</span><br><span class=\"line\">            <span class=\"comment\">// 等待服务端监听端口关闭</span></span><br><span class=\"line\">            future.channel().closeFuture().sync();</span><br><span class=\"line\"></span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 优雅地关闭</span></span><br><span class=\"line\">            bossGroup.shutdownGracefully();</span><br><span class=\"line\">            workerGroup.shutdownGracefully();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>服务端的创建主要步骤为：</p>\n<ol>\n<li>创建 ServerBootstrap 实例</li>\n<li>设置并绑定 Reactor 线程池</li>\n<li>设置服务端 Channel</li>\n<li>添加并设置 ChannelHandler</li>\n<li>绑定并启动监听端口</li>\n</ol>\n<h4 id=\"创建EventLoopGroup\"><a href=\"#创建EventLoopGroup\" class=\"headerlink\" title=\"创建EventLoopGroup\"></a>创建EventLoopGroup</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">EventLoopGroup bossGroup = <span class=\"keyword\">new</span> NioEventLoopGroup();</span><br><span class=\"line\">EventLoopGroup workerGroup = <span class=\"keyword\">new</span> NioEventLoopGroup();</span><br></pre></td></tr></table></figure>\n\n<p>bossGroup 为 BOSS 线程组，用于服务端接受客户端的连接, workerGroup 为 worker 线程组，用于进行 SocketChannel 的网络读写。 </p>\n<h4 id=\"创建ServerBootstrap实例\"><a href=\"#创建ServerBootstrap实例\" class=\"headerlink\" title=\"创建ServerBootstrap实例\"></a><strong>创建ServerBootstrap实例</strong></h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ServerBootstrap b = <span class=\"keyword\">new</span> ServerBootstrap();</span><br></pre></td></tr></table></figure>\n\n<p>ServerBootStrap为Netty服务端的启动引导类，用于帮助用户快速配置、启动服务端服务。 客户端的引导类是Bootstrap。ServerBootStrap 提供了如下一些方法</p>\n<table>\n<thead>\n<tr>\n<th>方法名称</th>\n<th>方法描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>group</code></td>\n<td>设置 ServerBootstrap 要用的 EventLoopGroup</td>\n</tr>\n<tr>\n<td><code>channel</code></td>\n<td>设置将要被实例化的 ServerChannel 类</td>\n</tr>\n<tr>\n<td><code>option</code></td>\n<td>实例化的 ServerChannel 的配置项</td>\n</tr>\n<tr>\n<td><code>Handler</code></td>\n<td>设置并添加 Handler</td>\n</tr>\n<tr>\n<td><code>bind</code></td>\n<td>绑定 ServerChannel</td>\n</tr>\n</tbody></table>\n<h4 id=\"设置并绑定线程池\"><a href=\"#设置并绑定线程池\" class=\"headerlink\" title=\"设置并绑定线程池\"></a>设置并绑定线程池</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">b.group(bossGroup, workerGroup)</span><br></pre></td></tr></table></figure>\n\n<p>调用group()方法，为ServerBootstrap实例设置绑定reactor线程池</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> ServerBootstrap <span class=\"title\">group</span><span class=\"params\">(EventLoopGroup parentGroup, EventLoopGroup childGroup)</span> </span>&#123;</span><br><span class=\"line\">       <span class=\"keyword\">super</span>.group(parentGroup);        <span class=\"comment\">// 绑定boosGroup</span></span><br><span class=\"line\">       <span class=\"keyword\">if</span> (childGroup == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">           <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> NullPointerException(<span class=\"string\">\"childGroup\"</span>);</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">       <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.childGroup != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">           <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException(<span class=\"string\">\"childGroup set already\"</span>);</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">       <span class=\"keyword\">this</span>.childGroup = childGroup;    <span class=\"comment\">// 绑定workerGroup</span></span><br><span class=\"line\">       <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"设置服务端Channel\"><a href=\"#设置服务端Channel\" class=\"headerlink\" title=\"设置服务端Channel\"></a>设置服务端Channel</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.channel(NioServerSocketChannel.class)</span><br></pre></td></tr></table></figure>\n\n<p>调用channel()方法设置服务端Channel类型，注意这里参数是Class对象，Netty通过工厂类，利用反射来创建NioServerSocketChannel对象</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> B <span class=\"title\">channel</span><span class=\"params\">(Class&lt;? extends C&gt; channelClass)</span> </span>&#123;</span><br><span class=\"line\">       <span class=\"keyword\">if</span> (channelClass == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">           <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> NullPointerException(<span class=\"string\">\"channelClass\"</span>);</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">       <span class=\"keyword\">return</span> channelFactory(<span class=\"keyword\">new</span> ReflectiveChannelFactory&lt;C&gt;(channelClass));</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n\n<p>这里传递的是 ReflectiveChannelFactory，其源代码如下： </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ReflectiveChannelFactory</span>&lt;<span class=\"title\">T</span> <span class=\"keyword\">extends</span> <span class=\"title\">Channel</span>&gt; <span class=\"keyword\">implements</span> <span class=\"title\">ChannelFactory</span>&lt;<span class=\"title\">T</span>&gt; </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Class&lt;? extends T&gt; clazz;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ReflectiveChannelFactory</span><span class=\"params\">(Class&lt;? extends T&gt; clazz)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (clazz == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> NullPointerException(<span class=\"string\">\"clazz\"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.clazz = clazz;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//需要创建 channel 的时候，该方法将被调用</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> T <span class=\"title\">newChannel</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 反射创建对应 channel</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> clazz.newInstance();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Throwable t) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> ChannelException(<span class=\"string\">\"Unable to create Channel from class \"</span> + clazz, t);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">toString</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> StringUtil.simpleClassName(clazz) + <span class=\"string\">\".class\"</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"添加并设置ChannelHandler\"><a href=\"#添加并设置ChannelHandler\" class=\"headerlink\" title=\"添加并设置ChannelHandler\"></a>添加并设置ChannelHandler</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">\t.handler(<span class=\"keyword\">new</span> LoggingServerHandler())</span><br><span class=\"line\">.childHandler(<span class=\"keyword\">new</span> ChannelInitializer()&#123;</span><br><span class=\"line\">\t<span class=\"meta\">@Override</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">initChannel</span><span class=\"params\">(Channel ch)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">\t\tch.pipeline().addLast(<span class=\"string\">\"decoder\"</span>, <span class=\"keyword\">new</span> HttpRequestDecoder());</span><br><span class=\"line\">\t\tch.pipeline().addLast(<span class=\"string\">\"encoder\"</span>, <span class=\"keyword\">new</span> HttpResponseEncoder());</span><br><span class=\"line\">\t\tch.pipeline().addLast(<span class=\"string\">\"httpServerHandler\"</span>, <span class=\"keyword\">new</span> HttpServerHandler());</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p><code>handler()</code>设置的 Handler 是服务端 NioServerSocketChannel的，childHandler()`设置的 Handler 是属于每一个新建的 NioSocketChannel 的</p>\n<h4 id=\"绑定端口，启动服务端\"><a href=\"#绑定端口，启动服务端\" class=\"headerlink\" title=\"绑定端口，启动服务端\"></a>绑定端口，启动服务端</h4><p>绑定端口并启动服务，如下： </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ChannelFuture future = b.bind(port).sync();</span><br></pre></td></tr></table></figure>\n\n<p>深入源码我们发现核心方法有两个<code>initAndRegister()</code>， <code>doBind0()</code></p>\n<h5 id=\"initAndRegister\"><a href=\"#initAndRegister\" class=\"headerlink\" title=\"initAndRegister()\"></a>initAndRegister()</h5><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> ChannelFuture <span class=\"title\">initAndRegister</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    Channel channel = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">    channel = channelFactory.newChannel();</span><br><span class=\"line\">    <span class=\"comment\">//...</span></span><br><span class=\"line\">    init(channel);</span><br><span class=\"line\">    <span class=\"comment\">//...</span></span><br><span class=\"line\">    ChannelFuture regFuture = config().group().register(channel);</span><br><span class=\"line\">    <span class=\"comment\">//...</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> regFuture;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>initAndRegister做了3件事：</p>\n<p>1.<strong>new一个Channel</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">channel = channelFactory.newChannel();</span><br></pre></td></tr></table></figure>\n\n<p>前面在ServerBootstrap实例设置服务端Channel时，设置了这个Channel的类型，这里就通过工厂类的方法生成NioServerSocketChannel对象。</p>\n<p>追溯NioServerSocketChannel的默认构造函数，我们可以发现在构造该实例时，设置了channel为非阻塞模式、SelectionKey.OP_ACCEPT事件、channelId 、NioMessageUnsafe(封装了用于数据传输操作的函数)、DefaultChannelPipeline和 NioServerSocketChannelConfig 属性。 </p>\n<p>2.<strong>init这个Channel</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">init</span><span class=\"params\">(Channel channel)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">         <span class=\"comment\">// 设置配置的option参数</span></span><br><span class=\"line\">        <span class=\"keyword\">final</span> Map&lt;ChannelOption&lt;?&gt;, Object&gt; options = options0();</span><br><span class=\"line\">        <span class=\"keyword\">synchronized</span> (options) &#123;</span><br><span class=\"line\">            channel.config().setOptions(options);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">final</span> Map&lt;AttributeKey&lt;?&gt;, Object&gt; attrs = attrs0();</span><br><span class=\"line\">        <span class=\"keyword\">synchronized</span> (attrs) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (Entry&lt;AttributeKey&lt;?&gt;, Object&gt; e: attrs.entrySet()) &#123;</span><br><span class=\"line\">                <span class=\"meta\">@SuppressWarnings</span>(<span class=\"string\">\"unchecked\"</span>)</span><br><span class=\"line\">                AttributeKey&lt;Object&gt; key = (AttributeKey&lt;Object&gt;) e.getKey();</span><br><span class=\"line\">                channel.attr(key).set(e.getValue());</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 获取绑定的pipeline</span></span><br><span class=\"line\">        ChannelPipeline p = channel.pipeline();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 准备child用到的4个part</span></span><br><span class=\"line\">        <span class=\"keyword\">final</span> EventLoopGroup currentChildGroup = childGroup;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> ChannelHandler currentChildHandler = childHandler;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> Entry&lt;ChannelOption&lt;?&gt;, Object&gt;[] currentChildOptions;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> Entry&lt;AttributeKey&lt;?&gt;, Object&gt;[] currentChildAttrs;</span><br><span class=\"line\">        <span class=\"keyword\">synchronized</span> (childOptions) &#123;</span><br><span class=\"line\">            currentChildOptions = childOptions.entrySet().toArray(newOptionArray(childOptions.size()));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">synchronized</span> (childAttrs) &#123;</span><br><span class=\"line\">            currentChildAttrs = childAttrs.entrySet().toArray(newAttrArray(childAttrs.size()));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 为NioServerSocketChannel的pipeline添加一个初始化Handler,</span></span><br><span class=\"line\">        <span class=\"comment\">// 当NioServerSocketChannel在EventLoop注册成功时，该handler的init方法将被调用</span></span><br><span class=\"line\">        p.addLast(<span class=\"keyword\">new</span> ChannelInitializer&lt;Channel&gt;() &#123;</span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">initChannel</span><span class=\"params\">(Channel ch)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">                <span class=\"keyword\">final</span> ChannelPipeline pipeline = ch.pipeline();</span><br><span class=\"line\">                ChannelHandler handler = config.handler();</span><br><span class=\"line\">                <span class=\"comment\">//如果用户配置过Handler</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (handler != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                    pipeline.addLast(handler);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                ch.eventLoop().execute(<span class=\"keyword\">new</span> Runnable() &#123;</span><br><span class=\"line\">                    <span class=\"meta\">@Override</span></span><br><span class=\"line\">                    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">                        <span class=\"comment\">// 为NioServerSocketChannel的pipeline添加ServerBootstrapAcceptor处理器</span></span><br><span class=\"line\">                        <span class=\"comment\">// 该Handler主要用来将新创建的NioSocketChannel注册到EventLoopGroup中</span></span><br><span class=\"line\">                        pipeline.addLast(<span class=\"keyword\">new</span> ServerBootstrapAcceptor(</span><br><span class=\"line\">                                currentChildGroup, currentChildHandler, currentChildOptions, currentChildAttrs));</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们发现init其实就做了三件事：</p>\n<ul>\n<li>设置options、attrs</li>\n<li>设置新接入Channel的options、attrs</li>\n<li>将用于服务端注册的 Handler ServerBootstrapAcceptor 添加到 ServerChannel的ChannelPipeline 中。ServerBootstrapAcceptor 为一个接入器，专门接受新请求。</li>\n</ul>\n<p>3.<strong>向EventLoopGroup中注册这个Channel</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ChannelFuture regFuture = config().group().register(channel);</span><br></pre></td></tr></table></figure>\n\n<p>通过追溯我们发现过程如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> ChannelFuture <span class=\"title\">register</span><span class=\"params\">(Channel channel)</span> </span>&#123;</span><br><span class=\"line\">       <span class=\"keyword\">return</span> next().register(channel);</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n\n<p>调用 <code>next()</code> 方法从 EventLoopGroup 中获取下一个 EventLoop，调用 <code>register()</code> 方法注册： </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> ChannelFuture <span class=\"title\">register</span><span class=\"params\">(Channel channel)</span> </span>&#123;</span><br><span class=\"line\">       <span class=\"keyword\">return</span> register(<span class=\"keyword\">new</span> DefaultChannelPromise(channel, <span class=\"keyword\">this</span>));</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n\n<p>将Channel和EventLoop封装成一个DefaultChannelPromise对象，然后调用register()方法。DefaultChannelPromis为ChannelPromise的默认实现，而ChannelPromisee继承Future，具备异步执行结构，绑定Channel，所以又具备了监听的能力，故而ChannelPromis是Netty异步执行的核心接口。 </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> ChannelFuture <span class=\"title\">register</span><span class=\"params\">(ChannelPromise promise)</span> </span>&#123;</span><br><span class=\"line\">       ObjectUtil.checkNotNull(promise, <span class=\"string\">\"promise\"</span>);</span><br><span class=\"line\">       promise.channel().unsafe().register(<span class=\"keyword\">this</span>, promise);</span><br><span class=\"line\">       <span class=\"keyword\">return</span> promise;</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n\n<p>unsafe就是我们之前构造NioServerSocketChannel时new的对象，这里调用register方法过程如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">register</span><span class=\"params\">(EventLoop eventLoop, <span class=\"keyword\">final</span> ChannelPromise promise)</span> </span>&#123;</span><br><span class=\"line\">          <span class=\"keyword\">if</span> (eventLoop == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">              <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> NullPointerException(<span class=\"string\">\"eventLoop\"</span>);</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">          <span class=\"keyword\">if</span> (isRegistered()) &#123;</span><br><span class=\"line\">              promise.setFailure(<span class=\"keyword\">new</span> IllegalStateException(<span class=\"string\">\"registered to an event loop already\"</span>));</span><br><span class=\"line\">              <span class=\"keyword\">return</span>;</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">          <span class=\"keyword\">if</span> (!isCompatible(eventLoop)) &#123;</span><br><span class=\"line\">              promise.setFailure(</span><br><span class=\"line\">                      <span class=\"keyword\">new</span> IllegalStateException(<span class=\"string\">\"incompatible event loop type: \"</span> + eventLoop.getClass().getName()));</span><br><span class=\"line\">              <span class=\"keyword\">return</span>;</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">          AbstractChannel.<span class=\"keyword\">this</span>.eventLoop = eventLoop;</span><br><span class=\"line\"></span><br><span class=\"line\">          <span class=\"comment\">// 必须要保证注册是由该EventLoop发起的</span></span><br><span class=\"line\">          <span class=\"keyword\">if</span> (eventLoop.inEventLoop()) &#123;</span><br><span class=\"line\">              register0(promise);        <span class=\"comment\">// 注册</span></span><br><span class=\"line\">          &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">              <span class=\"comment\">// 如果不是单独封装成一个task异步执行</span></span><br><span class=\"line\">              <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                  eventLoop.execute(<span class=\"keyword\">new</span> Runnable() &#123;</span><br><span class=\"line\">                      <span class=\"meta\">@Override</span></span><br><span class=\"line\">                      <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">                          register0(promise);</span><br><span class=\"line\">                      &#125;</span><br><span class=\"line\">                  &#125;);</span><br><span class=\"line\">              &#125; <span class=\"keyword\">catch</span> (Throwable t) &#123;</span><br><span class=\"line\">                  logger.warn(</span><br><span class=\"line\">                          <span class=\"string\">\"Force-closing a channel whose registration task was not accepted by an event loop: &#123;&#125;\"</span>,</span><br><span class=\"line\">                          AbstractChannel.<span class=\"keyword\">this</span>, t);</span><br><span class=\"line\">                  closeForcibly();</span><br><span class=\"line\">                  closeFuture.setClosed();</span><br><span class=\"line\">                  safeSetFailure(promise, t);</span><br><span class=\"line\">              &#125;</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">      &#125;</span><br></pre></td></tr></table></figure>\n\n<p>首先通过<code>isRegistered()</code> 判断该 Channel 是否已经注册到 EventLoop 中；  </p>\n<p>通过 <code>eventLoop.inEventLoop()</code> 来判断当前线程是否为该 EventLoop 自身发起的，如果是，则调用 <code>register0()</code> 直接注册;</p>\n<p>如果不是，说明该 EventLoop 中的线程此时没有执行权，则需要新建一个线程，单独封装一个 Task，而该 Task 的主要任务则是执行<code>register0()</code>。 </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">register0</span><span class=\"params\">(ChannelPromise promise)</span> </span>&#123;</span><br><span class=\"line\">          <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">              <span class=\"comment\">// 确保 Channel 处于 open</span></span><br><span class=\"line\">              <span class=\"keyword\">if</span> (!promise.setUncancellable() || !ensureOpen(promise)) &#123;</span><br><span class=\"line\">                  <span class=\"keyword\">return</span>;</span><br><span class=\"line\">              &#125;</span><br><span class=\"line\">              <span class=\"keyword\">boolean</span> firstRegistration = neverRegistered;</span><br><span class=\"line\"></span><br><span class=\"line\">              <span class=\"comment\">// 真正的注册动作</span></span><br><span class=\"line\">              doRegister();</span><br><span class=\"line\"></span><br><span class=\"line\">              neverRegistered = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">              registered = <span class=\"keyword\">true</span>;        </span><br><span class=\"line\"></span><br><span class=\"line\">              pipeline.invokeHandlerAddedIfNeeded();    </span><br><span class=\"line\">              safeSetSuccess(promise);        <span class=\"comment\">//设置注册结果为成功</span></span><br><span class=\"line\"></span><br><span class=\"line\">              pipeline.fireChannelRegistered();</span><br><span class=\"line\"></span><br><span class=\"line\">              <span class=\"keyword\">if</span> (isActive()) &#123; </span><br><span class=\"line\">                  <span class=\"comment\">//如果是首次注册,发起 pipeline 的 fireChannelActive</span></span><br><span class=\"line\">                  <span class=\"keyword\">if</span> (firstRegistration) &#123;</span><br><span class=\"line\">                      pipeline.fireChannelActive();</span><br><span class=\"line\">                  &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (config().isAutoRead()) &#123;</span><br><span class=\"line\">                      beginRead();</span><br><span class=\"line\">                  &#125;</span><br><span class=\"line\">              &#125;</span><br><span class=\"line\">          &#125; <span class=\"keyword\">catch</span> (Throwable t) &#123;</span><br><span class=\"line\">              closeForcibly();</span><br><span class=\"line\">              closeFuture.setClosed();</span><br><span class=\"line\">              safeSetFailure(promise, t);</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">      &#125;</span><br></pre></td></tr></table></figure>\n\n<p>如果 Channel 处于 open 状态，则调用 <code>doRegister()</code> 方法完成注册，然后将注册结果设置为成功。最后判断如果是首次注册且处于激活状态，则发起 pipeline 的 <code>fireChannelActive()</code>。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">doRegister</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">       <span class=\"keyword\">boolean</span> selected = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">       <span class=\"keyword\">for</span> (;;) &#123;</span><br><span class=\"line\">           <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">               <span class=\"comment\">// 注册到NIOEventLoop的Selector上</span></span><br><span class=\"line\">               selectionKey = javaChannel().register(eventLoop().selector, <span class=\"number\">0</span>, <span class=\"keyword\">this</span>);</span><br><span class=\"line\">               <span class=\"keyword\">return</span>;</span><br><span class=\"line\">           &#125; <span class=\"keyword\">catch</span> (CancelledKeyException e) &#123;</span><br><span class=\"line\">               <span class=\"keyword\">if</span> (!selected) &#123;</span><br><span class=\"line\">                   eventLoop().selectNow();</span><br><span class=\"line\">                   selected = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">               &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                   <span class=\"keyword\">throw</span> e;</span><br><span class=\"line\">               &#125;</span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n\n<p>因为当前没有将一个ServerSocket绑定到一个address</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (isActive()) &#123; </span><br><span class=\"line\">\t<span class=\"comment\">//如果是首次注册,发起 pipeline 的 fireChannelActive</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (firstRegistration) &#123;</span><br><span class=\"line\">\t\tpipeline.fireChannelActive();</span><br><span class=\"line\">\t&#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (config().isAutoRead()) &#123;</span><br><span class=\"line\">\t\tbeginRead();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isActive</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">       <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.javaChannel().socket().isBound();</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">doBeginRead</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">       SelectionKey selectionKey = <span class=\"keyword\">this</span>.selectionKey;</span><br><span class=\"line\">       <span class=\"keyword\">if</span> (selectionKey.isValid()) &#123;</span><br><span class=\"line\">           <span class=\"keyword\">this</span>.readPending = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">           <span class=\"keyword\">int</span> interestOps = selectionKey.interestOps();</span><br><span class=\"line\">           <span class=\"keyword\">if</span> ((interestOps &amp; <span class=\"keyword\">this</span>.readInterestOp) == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">               selectionKey.interestOps(interestOps | <span class=\"keyword\">this</span>.readInterestOp);</span><br><span class=\"line\">           &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n\n<p>这里将selectionKey的监听操作设置为之前构造NioServerSocketChannel设置的SelectionKey.OP_ACCEPT</p>\n<h5 id=\"he-doBind0\"><a href=\"#he-doBind0\" class=\"headerlink\" title=\"he doBind0()\"></a>he doBind0()</h5><p>追溯doBind0()的实现，我们可以发现会调用初始化时NioMessageUnsafe的bind方法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">bind</span><span class=\"params\">(<span class=\"keyword\">final</span> SocketAddress localAddress, <span class=\"keyword\">final</span> ChannelPromise promise)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">    <span class=\"keyword\">boolean</span> wasActive = isActive();</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">    doBind(localAddress);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!wasActive &amp;&amp; isActive()) &#123;</span><br><span class=\"line\">        invokeLater(<span class=\"keyword\">new</span> Runnable() &#123;</span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">                pipeline.fireChannelActive();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    safeSetSuccess(promise);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>doBind(localAddress) 调用JDK的代码，实现了端口绑定</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">protected void doBind(SocketAddress localAddress) throws Exception &#123;</span><br><span class=\"line\">    if (PlatformDependent.javaVersion() &gt;= 7) &#123;</span><br><span class=\"line\">        //noinspection Since15</span><br><span class=\"line\">        javaChannel().bind(localAddress, config.getBacklog());</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">        javaChannel().socket().bind(localAddress, config.getBacklog());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>绑定后isActice()返回true，fireChannelActive() 被调用。</p>\n<h2 id=\"4-内存管理\"><a href=\"#4-内存管理\" class=\"headerlink\" title=\"4 内存管理\"></a>4 内存管理</h2><h3 id=\"4-1-ByteBuffer、ByteBuf\"><a href=\"#4-1-ByteBuffer、ByteBuf\" class=\"headerlink\" title=\"4.1 ByteBuffer、ByteBuf\"></a>4.1 ByteBuffer、ByteBuf</h3><p>为了减少频繁I/O操作，引进了Buffer的概念，把突发的大数量较小规模的 I/O 整理成平稳的小数量较大规模的 I/O 。Java NIO封装了ByteBuffer组件。ByteBuffer具有4个重要的属性：mark、position、limit、capacity ，以及两个重要的方法clear()、flip()</p>\n<ol>\n<li>position:读写指针，代表当前读或写操作的位置，这个值总是小于等于limit的。</li>\n<li>mark：在使用ByteBuffer的过程中，如果想要记住当前的position，则会将当前的position值给mark，需要恢复的时候，再将mark的值给position。</li>\n<li>capacity：代表这块内存区域的大小。</li>\n<li>limit：初始的Buffer中，limit和capacity的值是相等的，通常在clear操作和flip操作的时候会对这个值进行操作，在clear操作的时候会将这个值和capacity的值设置为相等，当flip的时候会将当前的position的值给limit，我们可以总结在写的时候，limit的值代表最大的可写位置，在读的时候，limit的值代表最大的可读位置。</li>\n</ol>\n<p><img src=\"/png/netty/ByteBuffer.png\" alt></p>\n<p>在写操作之前调用clear()</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> Buffer <span class=\"title\">clear</span><span class=\"params\">()</span> </span>&#123; </span><br><span class=\"line\">\tposition = <span class=\"number\">0</span>; <span class=\"comment\">//设置当前下标为0</span></span><br><span class=\"line\">\tlimit = capacity; <span class=\"comment\">//设置写越界位置与和Buffer容量相同</span></span><br><span class=\"line\">\tmark = -<span class=\"number\">1</span>; <span class=\"comment\">//取消标记</span></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"keyword\">this</span>; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在读操作之前调用flip()</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> Buffer <span class=\"title\">flip</span><span class=\"params\">()</span> </span>&#123; </span><br><span class=\"line\">\tlimit = position; </span><br><span class=\"line\">\tposition = <span class=\"number\">0</span>; </span><br><span class=\"line\">\tmark = -<span class=\"number\">1</span>; </span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"keyword\">this</span>; </span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n\n<p>ByteBuffer具有以下缺陷</p>\n<ul>\n<li>ByteBuffer长度固定，一旦分配完成，它的容量不能动态扩展和收缩，当需要编码的POJO对象大于ByteBuffer的容量时，会发生索引越界异常；</li>\n<li>ByteBuffer只有一个标识位控的指针position，读写的时候需要手工调用 flip() 和 clear() 等；</li>\n<li>ByteBuffer的API功能有限，一些高级和实用的特性它不支持，需要使用者自己编程实现。</li>\n</ul>\n<p>Netty为了解决ByteBuffer的缺陷，重写了一个新的数据接口ByteBuf。 与ByteBuffer相比，ByteBuf提供了两个指针 readerIndex 和 writeIndex 来分别指向读的位置和写的位置，不需要每次为读写做准备，直接设置读写指针进行读写操作即可。 </p>\n<p><img src=\"/png/netty/%E8%AF%BB%E5%86%99%E4%B8%AD%E9%97%B4%E7%8A%B6%E6%80%81%E7%9A%84Buffer.png\" alt></p>\n<p>这是中间状态的Buffer，可以通过调用discardReadBytes方法来回收已读区域</p>\n<p><img src=\"/png/netty/discardReadBytes.png\" alt></p>\n<p>通过clear方法清楚指针状态</p>\n<p><img src=\"/png/netty/clear%E5%90%8E%E7%9A%84Buffer.png\" alt></p>\n<p>对比ByteBuffer，使用ByteBuf读的时候仅仅依赖readerIndex指针，写的时候仅仅依赖writerIndex指针，不需每次读写之前调用对应的方法，而且没有必须一次读完的限制。 </p>\n<h3 id=\"4-2-内存管理\"><a href=\"#4-2-内存管理\" class=\"headerlink\" title=\"4.2 内存管理\"></a>4.2 内存管理</h3><h4 id=\"4-2-1-零拷贝\"><a href=\"#4-2-1-零拷贝\" class=\"headerlink\" title=\"4.2.1 零拷贝\"></a>4.2.1 零拷贝</h4><p>当JVM堆内存上的数据需要和IO设备进行I/O操作时，会将JVM堆上所维护的byte[]拷贝至堆外内存（一般是通过C/C++分配的内存），然后堆外内存直接和IO设备交互。这是因为<strong>JVM需要进行GC，如果IO设备直接和JVM堆上的数据进行交互，这个时候JVM进行了GC，那么有可能会导致没有被回收的数据进行了压缩，位置被移动到了连续的存储区域，这样会导致正在进行的IO操作相关的数据全部乱套</strong>。</p>\n<p>NIO可以使用native 函数库直接分配堆外内存，然后通过一个存储在堆上的DirectByteBuffer 对象作为这块内存的引用进行操作，避免了在Java堆和Native堆中来回复制数据。 </p>\n<h4 id=\"4-2-2-内存泄漏\"><a href=\"#4-2-2-内存泄漏\" class=\"headerlink\" title=\"4.2.2 内存泄漏\"></a>4.2.2 内存泄漏</h4><p>从堆中分配的缓冲区HeapByteBuffer为普通的Java对象，生命周期与普通的Java对象一样，当不再被引用时，Buffer对象会被回收。而直接缓冲区（DirectByteBuffer）为堆外内存，并不在Java堆中，也不能被JVM垃圾回收。由于直接缓冲区在JVM里被包装进Java对象DirectByteBuffer中，当它的包装类被垃圾回收时，会调用相应的JNI方法释放堆外内存，所以堆外内存的释放也依赖于JVM中DirectByteBuffer对象的回收。</p>\n<p>由于垃圾回收本身成本较高，一般JVM在堆内存未耗尽时，不会进行垃圾回收操作。如果不断分配本地内存，堆内存很少使用，那么JVM就不需要执行GC，DirectByteBuffer对象们就不会被回收，这时候堆内存充足，但本地内存可能已经使用光了，再次尝试分配本地内存就会出现OutOfMemoryError，那程序就直接崩溃了。</p>\n<h4 id=\"4-2-3-ByteBuf引用计数\"><a href=\"#4-2-3-ByteBuf引用计数\" class=\"headerlink\" title=\"4.2.3 ByteBuf引用计数\"></a>4.2.3 ByteBuf引用计数</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">ReferenceCounted</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">refCnt</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\">ReferenceCounted <span class=\"title\">retain</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\">ReferenceCounted <span class=\"title\">retain</span><span class=\"params\">(<span class=\"keyword\">int</span> var1)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\">ReferenceCounted <span class=\"title\">touch</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\">ReferenceCounted <span class=\"title\">touch</span><span class=\"params\">(Object var1)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">release</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">release</span><span class=\"params\">(<span class=\"keyword\">int</span> var1)</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>ByteBuf扩展了ReferenceCountered接口 ，这个接口定义的功能主要是引用计数。</p>\n<p>当 ByteBuf 引用+1的时候，需要调用 retain() 来让refCnt + 1，当Buffer引用数-1的时候需要调用 release() 来让 refCnt - 1。当refCnt变为0的时候Netty为pooled和unpooled的不同buffer提供了不同的实现，通常对于非内存池的用法，Netty把Buffer的内存回收交给了垃圾回收器，对于内存池的用法，Netty对内存的回收实际上是回收到内存池内，以提供下一次的申请所使用。</p>\n<h4 id=\"4-2-4-池化\"><a href=\"#4-2-4-池化\" class=\"headerlink\" title=\"4.2.4 池化\"></a>4.2.4 池化</h4><p>如果对于Buffer的使用都基于直接内存实现的话，将会大大提高I/O效率，然而直接内存空间的申请比堆内存要消耗更高的性能。</p>\n<p>因此Netty结合引用计数实现了PolledBuffer，即池化的用法，当引用计数等于0的时候，Netty将Buffer回收至池中，在下一次申请Buffer的时刻会被复用。 </p>\n<p>堆内存和直接内存的池化实现分别是PooledHeapByteBuf和PooledDirectByteBuf，在各自的实现中都维护着一个Recycler 。Recycler是一个抽象类，向外部提供了两个公共方法get和recycle分别用于从对象池中获取对象和回收对象。</p>\n<p>以PooledHeapByteBuf为例，新建PooledHeapByteBuf对象时</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> PooledHeapByteBuf <span class=\"title\">newInstance</span><span class=\"params\">(<span class=\"keyword\">int</span> maxCapacity)</span> </span>&#123;</span><br><span class=\"line\">       PooledHeapByteBuf buf = (PooledHeapByteBuf)RECYCLER.get();</span><br><span class=\"line\">       buf.reuse(maxCapacity);</span><br><span class=\"line\">       <span class=\"keyword\">return</span> buf;</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n\n<p>当Buffer引用数 -1时</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">release</span><span class=\"params\">(<span class=\"keyword\">int</span> decrement)</span> </span>&#123;</span><br><span class=\"line\">       <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.release0(ObjectUtil.checkPositive(decrement, <span class=\"string\">\"decrement\"</span>));</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> <span class=\"title\">release0</span><span class=\"params\">(<span class=\"keyword\">int</span> decrement)</span> </span>&#123;</span><br><span class=\"line\">       <span class=\"keyword\">int</span> oldRef = refCntUpdater.getAndAdd(<span class=\"keyword\">this</span>, -decrement);</span><br><span class=\"line\">       <span class=\"keyword\">if</span> (oldRef == decrement) &#123;</span><br><span class=\"line\">           <span class=\"keyword\">this</span>.deallocate();</span><br><span class=\"line\">           <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">       &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (oldRef &gt;= decrement &amp;&amp; oldRef - decrement &lt;= oldRef) &#123;</span><br><span class=\"line\">           <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">       &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">           refCntUpdater.getAndAdd(<span class=\"keyword\">this</span>, decrement);</span><br><span class=\"line\">           <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalReferenceCountException(oldRef, -decrement);</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n\n<p>PooledByteBuf.class</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">deallocate</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.handle &gt;= <span class=\"number\">0L</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">long</span> handle = <span class=\"keyword\">this</span>.handle;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.handle = -<span class=\"number\">1L</span>;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.memory = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.tmpNioBuf = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.chunk.arena.free(<span class=\"keyword\">this</span>.chunk, handle, <span class=\"keyword\">this</span>.maxLength, <span class=\"keyword\">this</span>.cache);</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.chunk = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.recycle();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">recycle</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.recyclerHandle.recycle(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"4-3-半包读写\"><a href=\"#4-3-半包读写\" class=\"headerlink\" title=\"4.3 半包读写\"></a>4.3 半包读写</h3><p>TCP是个”流”协议，所谓流，就是没有界限没有分割的一串数据。TCP会根据缓冲区的实际情况进行包划分，一个完整的包可能会拆分成多个包进行发送，也用可能把多个小包封装成一个大的数据包发送。这就是TCP粘包/拆包。</p>\n<p>举个例子：假设操作系统已经接收到了三个包，如下：</p>\n<p><img src=\"/png/netty/%E6%B5%81-%E6%8B%86%E5%8C%85.png\" alt></p>\n<p>由于流传输的这个普通属性，在读取他们的时候将会存在很大的几率，这些数据会被分段成下面的几部分：</p>\n<p><img src=\"/png/netty/%E6%B5%81-%E7%B2%98%E5%8C%85.png\" alt></p>\n<p>也就是读取的数据有可能超过一个完整的数据包或者过多或者过少的半包。</p>\n<p>因此，作为一个接收方，不管它是服务端还是客户端，都需要把接收到的数据整理成一个或多个有意义的并且能够被应用程序容易理解的数据。</p>\n<p><strong>拆包方案：</strong></p>\n<ul>\n<li><strong>消息定长</strong>，固定报文长度，不够空格补全，发送和接收方遵循相同的约定，这样即使粘包了通过接收方编程实现获取定长报文也能区分。</li>\n<li><strong>包尾添加特殊分隔符</strong>，例如每条报文结束都添加回车换行符（例如FTP协议）或者指定特殊字符作为报文分隔符，接收方通过特殊分隔符切分报文区分。</li>\n<li><strong>将消息分为消息头和消息体</strong>，消息头中包含表示信息的总长度（或者消息体长度）的字段</li>\n</ul>\n<p><strong>Netty提供了几种解码器：</strong></p>\n<ul>\n<li>定长解码器：FixedLengthFrameDecoder</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ch.pipeline().addLast(new FixedLengthFrameDecoder(30));//设置定长解码器</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>特殊分隔符解码器：DelimiterBasedFrameDecoder</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ByteBuf delimiter = Unpooled.copiedBuffer(&quot;&amp;&quot;.getBytes());</span><br><span class=\"line\">//1024表示单条消息的最大长度，解码器在查找分隔符的时候，达到该长度还没找到的话会抛异常</span><br><span class=\"line\">ch.pipeline().addLast(new DelimiterBasedFrameDecoder(1024,delimiter));</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>基于包头不固定长度的解码器：LengthFieldBasedFrameDecoder</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * maxFrameLength：解码的帧的最大长度</span></span><br><span class=\"line\"><span class=\"comment\"> * lengthFieldOffset：长度属性的起始位（偏移位），包中存放有整个大数据包长度的字节，这段字节的其实位置</span></span><br><span class=\"line\"><span class=\"comment\"> * lengthFieldLength：长度属性的长度，即存放整个大数据包长度的字节所占的长度</span></span><br><span class=\"line\"><span class=\"comment\"> * lengthAdjustmen：长度调节值，在总长被定义为包含包头长度时，修正信息长度。</span></span><br><span class=\"line\"><span class=\"comment\"> * initialBytesToStrip：跳过的字节数，根据需要我们跳过lengthFieldLength个字节，以便接收端直接接受到不</span></span><br><span class=\"line\"><span class=\"comment\">                        含“长度属性”的内容</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">ch.pipeline().addLast(<span class=\"string\">\"decoder\"</span>, <span class=\"keyword\">new</span> LengthFieldBasedFrameDecoder(MAX_FRAME_LENGTH, LENGTH_OFFSET, </span><br><span class=\"line\">                                    LENGTH_LEN, LENGTH_ADJUGEMENT, INIT_BYTE_TO_STRIP));</span><br></pre></td></tr></table></figure>\n\n<p><strong>参考资料</strong></p>\n<table>\n<thead>\n<tr>\n<th>资料名称</th>\n<th>来源</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>《Netty实战》</td>\n<td>图书</td>\n</tr>\n<tr>\n<td>《Netty权威指南》</td>\n<td>图书</td>\n</tr>\n<tr>\n<td>Netty官网wiki</td>\n<td><a href=\"https://netty.io/wiki/related-articles.html\" target=\"_blank\" rel=\"noopener\">https://netty.io/wiki/related-articles.html</a></td>\n</tr>\n<tr>\n<td>其他互联网资料链接</td>\n<td>见最后</td>\n</tr>\n</tbody></table>\n<p><strong>参考链接：</strong></p>\n<p><a href=\"https://netty.io/index.html\" target=\"_blank\" rel=\"noopener\">https://netty.io/index.html</a><br><a href=\"https://blog.csdn.net/syc001/article/details/72841945\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/syc001/article/details/72841945</a><br><a href=\"http://ifeve.com/%E8%B0%88%E8%B0%88netty%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/\" target=\"_blank\" rel=\"noopener\">http://ifeve.com/%E8%B0%88%E8%B0%88netty%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/</a><br><a href=\"https://www.cnblogs.com/wxd0108/p/6681627.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/wxd0108/p/6681627.html</a><br><a href=\"https://my.oschina.net/plucury/blog/192577\" target=\"_blank\" rel=\"noopener\">https://my.oschina.net/plucury/blog/192577</a><br><a href=\"https://blog.csdn.net/chenssy/article/details/78714003\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/chenssy/article/details/78714003</a></p>\n","site":{"data":{}},"excerpt":"<h2 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h2><p>Netty是一款异步的事件驱动的网络应用程序框架，支持快速地开发可维护的高性能的面向协议的服务器和客户端。它提供了对TCP、UDP和文件传输的支持，作为一个异步NIO框架，Netty的所有IO操作都是异步非阻塞的，通过Future-Listener机制，用户可以方便的主动获取或者通过通知机制获得IO操作结果。</p>","more":"<p><img src=\"/png/netty/netty.png\" alt></p>\n<p>为什么用Netty不用NIO</p>\n<ol>\n<li>NIO的类库和API繁杂，使用麻烦，你需要熟练掌握Selector、ServerSocketChannel、SocketChannel、ByteBuffer等；</li>\n<li>需要具备其它的额外技能做铺垫，例如熟悉Java多线程编程，因为NIO编程涉及到Reactor模式，你必须对多线程和网路编程非常熟悉，才能编写出高质量的NIO程序；</li>\n<li>可靠性能力补齐，工作量和难度都非常大。例如客户端面临断连重连、网络闪断、半包读写、失败缓存、网络拥塞和异常码流的处理等等，NIO编程的特点是功能开发相对容易，但是可靠性能力补齐工作量和难度都非常大；</li>\n<li>JDK NIO的BUG，例如epoll bug，它会导致Selector空轮询，最终导致CPU 100%。官方声称在JDK1.6版本的update18修复了该问题，但是直到JDK1.7版本该问题仍旧存在，只不过该bug发生概率降低了一些而已，它并没有被根本解决。</li>\n</ol>\n<h2 id=\"Reactor模式和Netty线程模型\"><a href=\"#Reactor模式和Netty线程模型\" class=\"headerlink\" title=\"Reactor模式和Netty线程模型\"></a>Reactor模式和Netty线程模型</h2><h3 id=\"什么是reactor模式\"><a href=\"#什么是reactor模式\" class=\"headerlink\" title=\"什么是reactor模式\"></a>什么是reactor模式</h3><p>Reactor模式是<strong>事件驱动的，有一个或多个并发输入源，有一个Service Handler，有多个Request Handlers</strong>；这个Service Handler会同步的将输入的请求多路复用的分发给相应的Request Handler。 </p>\n<p><img src=\"/png/netty/reactor%E6%A8%A1%E5%BC%8F.png\" alt></p>\n<h3 id=\"3种reactor模式\"><a href=\"#3种reactor模式\" class=\"headerlink\" title=\"3种reactor模式\"></a>3种reactor模式</h3><h4 id=\"单线程的reactor模式\"><a href=\"#单线程的reactor模式\" class=\"headerlink\" title=\"单线程的reactor模式\"></a>单线程的reactor模式</h4><p><img src=\"/png/netty/%E5%8D%95%E7%BA%BF%E7%A8%8Breactor%E6%A8%A1%E5%9E%8B.jpg\" alt></p>\n<p>Reactor线程是个多面手，负责多路分离套接字，Accept新连接，并分派请求到处理器链中。该模型适用于处理器链中业务处理组件能快速完成的场景。不过，这种单线程模型不能充分利用多核资源，所以实际使用的不多。 </p>\n<p>性能缺陷：</p>\n<ol>\n<li>一个NIO线程同时处理成百上千的链路，性能上无法支撑。即便NIO线程的CPU负荷达到100%，也无法满足海量消息的编码、解码、读取和发送；</li>\n<li>当NIO线程负载过重之后，处理速度将变慢，这会导致大量客户端连接超时，超时之后往往进行重发，这更加重了NIO线程的负载，最终导致大量消息积压和处理超时，NIO线程会成为系统的性能瓶颈；</li>\n<li>可靠性问题。一旦NIO线程出现错误，或者进入死循环，会导致整个系统通讯模块不可用，不能接收和处理外部信息，造成节点故障。</li>\n</ol>\n<h4 id=\"多线程的reactor模式\"><a href=\"#多线程的reactor模式\" class=\"headerlink\" title=\"多线程的reactor模式\"></a>多线程的reactor模式</h4><p><img src=\"/png/netty/%E5%A4%9A%E7%BA%BF%E7%A8%8Breactor%E6%A8%A1%E5%9E%8B.jpg\" alt></p>\n<p>Reactor多线程模型的特点：</p>\n<ol>\n<li>有专门一个NIO线程-Acceptor线程用于监听服务端，接收客户端的TCP连接请求； </li>\n<li>网络IO操作-读、写等由一个NIO线程池负责，线程池可以采用标准的JDK线程池实现，它包含一个任务队列和N个可用的线程，由这些NIO线程负责消息的读取、解码、编码和发送； </li>\n<li>1个NIO线程可以同时处理N条链路，但是1个链路只对应1个NIO线程，防止发生并发操作问题。</li>\n</ol>\n<p>在绝大多数场景下，Reactor多线程模型都可以满足性能需求；但是，当用户进一步增加的时候，一个NIO线程负责监听和处理所有的客户端连接可能会存在性能问题。例如并发百万客户端连接，或者服务端需要对客户端握手进行安全认证，但是认证本身非常损耗性能。在这类场景下，单独一个Acceptor线程可能会存在性能不足问题。</p>\n<h4 id=\"主从reactor多线程模型\"><a href=\"#主从reactor多线程模型\" class=\"headerlink\" title=\"主从reactor多线程模型\"></a>主从reactor多线程模型</h4><p><img src=\"/png/netty/%E4%B8%BB%E4%BB%8E%E6%A8%A1%E5%BC%8Freactor%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B.jpg\" alt></p>\n<p>注册accepter事件处理器到mainReactor线程池中，这样mainReactor会监听客户端向服务端发起的连接请求</p>\n<p>当客户端向服务端发起连接请求时，mainReactor监听到了该请求将事件派发给acceptor事件处理器进行处理，可通过accept方法获得连接socketChannel，然后将socketChannel传递给subReactor线程池</p>\n<p>subReactor线程池分配一个subReactor线程给这个SocketChannel，监听I/O的read、write操作，相关业务逻辑的处理交给工作线程池来完成</p>\n<h3 id=\"Netty的线程模型\"><a href=\"#Netty的线程模型\" class=\"headerlink\" title=\"Netty的线程模型\"></a>Netty的线程模型</h3><p><img src=\"/png/netty/netty%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B.png\" alt></p>\n<p>当NettyServer启动时候会创建两个NioEventLoopGroup线程池组。</p>\n<p>boss组用来接受客户端发来的连接，在监听一个端口的情况下，一个NioEventLoop通过一个NioServerSocketChannel监听端口，处理TCP连接。worker组则负责对完成TCP三次握手的连接进行处理。</p>\n<p>如上图每个NioEventLoopGroup里面包含了多个NioEventLoop，每个NioEventLoop中包含了一个NIO Selector、一个队列、一个线程；其中线程用来做轮询注册到Selector上的Channel的读写事件和对投递到队列里面的事件进行处理。 </p>\n<h2 id=\"核心组件\"><a href=\"#核心组件\" class=\"headerlink\" title=\"核心组件\"></a>核心组件</h2><h3 id=\"Channel接口、EventLoop接口\"><a href=\"#Channel接口、EventLoop接口\" class=\"headerlink\" title=\"Channel接口、EventLoop接口\"></a>Channel接口、EventLoop接口</h3><p>Channel 是 Netty 网络操作抽象类，它除了包括基本的 I/O 操作，如 bind、connect、read、write 之外，还包括了 Netty 框架相关的一些功能，如获取该 Channe l的 EventLoop。 </p>\n<p>在传统的网络编程中，作为核心类的 Socket ，它对程序员来说并不是那么友好，直接使用其成本还是稍微高了点。而Netty 的 Channel 则提供的一系列的 API ，它大大降低了直接与 Socket 进行操作的复杂性。 </p>\n<p>Netty 基于事件驱动模型，使用不同的事件来通知我们状态的改变或者操作状态的改变。它定义了在整个连接的生命周期里当有事件发生的时候处理的核心抽象。</p>\n<p>Channel 为Netty 网络操作抽象类，EventLoop 主要是为Channel 处理 I/O 操作，两者配合参与 I/O 操作。</p>\n<p><img src=\"/png/netty/channel&eventLoop.jpg\" alt></p>\n<ul>\n<li>一个EventLoopGroup包含一个或者多个EventLoop</li>\n<li>一个EventLoop在他的生命周期只和一个线程绑定</li>\n<li>所有由EventLoop处理的I/O事件都将在它专有的线程上被处理</li>\n<li>一个Channel在它的生命周期内只注册于一个EventLoop</li>\n<li>一个EventLoop可能会被分配给一个或多个Channel</li>\n</ul>\n<h3 id=\"ChannelFuture接口\"><a href=\"#ChannelFuture接口\" class=\"headerlink\" title=\"ChannelFuture接口\"></a>ChannelFuture接口</h3><p>Netty 为异步非阻塞，即所有的 I/O 操作都为异步的，因此，我们不能立刻得知消息是否已经被处理了。Netty 提供了 ChannelFuture 接口，通过该接口的 addListener() 方法注册一个 ChannelFutureListener，当操作执行完成（成功或者失败）时，监听就会自动触发返回结果。</p>\n<h3 id=\"ChannelHandler、ChannelPipeline\"><a href=\"#ChannelHandler、ChannelPipeline\" class=\"headerlink\" title=\"ChannelHandler、ChannelPipeline\"></a>ChannelHandler、ChannelPipeline</h3><h4 id=\"ChannelHandler\"><a href=\"#ChannelHandler\" class=\"headerlink\" title=\"ChannelHandler\"></a>ChannelHandler</h4><p>ChannelHandler 为 Netty 中最核心的组件，它充当了所有处理入站和出站数据的应用程序逻辑的容器。ChannelHandler 主要用来处理各种事件，这里的事件很广泛，比如可以是连接、数据接收、异常、数据转换等。</p>\n<p>ChannelHandler 有两个核心子类 ChannelInboundHandler 和 ChannelOutboundHandler，其中 ChannelInboundHandler 用于接收、处理入站数据和事件，而 ChannelOutboundHandler 则相反。我们经常通过一个ChannelInboundHandler的实现类来实现业务逻辑的处理。</p>\n<h4 id=\"ChannelPipeline\"><a href=\"#ChannelPipeline\" class=\"headerlink\" title=\"ChannelPipeline\"></a>ChannelPipeline</h4><p>ChannelPipeline 为 ChannelHandler 链提供了一个容器并定义了用于沿着链传播入站和出站事件流的 API。一个数据或者事件可能会被多个 Handler 处理，在这个过程中，数据或者事件经流 ChannelPipeline，由 ChannelHandler 处理。在这个处理过程中，一个 ChannelHandler 接收数据后处理完成后交给下一个 ChannelHandler，或者什么都不做直接交给下一个 ChannelHandler。 </p>\n<p><img src=\"/png/netty/channelPipeline.jpg\" alt></p>\n<p>当一个数据流进入 ChannlePipeline 时，它会从 ChannelPipeline 头部开始传给第一个 ChannelInboundHandler ，当第一个处理完后再传给下一个，一直传递到管道的尾部。与之相对应的是，当数据被写出时，它会从管道的尾部开始，先经过管道尾部的 “最后” 一个ChannelOutboundHandler，当它处理完成后会传递给前一个 ChannelOutboundHandler 。</p>\n<p>当ChannelHandler被添加到ChannelPipeline时，它将会被分配一个ChannelHandlerContext，代表了ChannelHandler和ChannelPipeline之间的绑定。</p>\n<h4 id=\"编码器和解码器\"><a href=\"#编码器和解码器\" class=\"headerlink\" title=\"编码器和解码器\"></a>编码器和解码器</h4><p>由于网络数据总是一系列的字节，通过Netty发送或者接受消息时，将会发生一次数据转换：入站消息会被解码，由字节转换为另一种格式，通常是一个Java对象；出站消息会被编码，从当前格式转换为字节。</p>\n<p>Netty提供了编码器的基类MessageToByteEncoder以及解码器的基类ByteToMessageDecoder，Netty提供的所有解码器/编码器适配器类都实现了ChannelInboundHandler或者ChannelOutboundHandler接口。如果我们要自定义的编码/解码规则，只需要继承基类，实现encode()/decode()方法。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">encode</span><span class=\"params\">(ChannelHandlerContext channelHandlerContext, Object iotPacketRequest, </span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                           ByteBuf out)</span> </span>&#123;</span><br><span class=\"line\">       <span class=\"keyword\">if</span> (<span class=\"keyword\">null</span> == iotPacketRequest) &#123;</span><br><span class=\"line\">           <span class=\"keyword\">return</span>;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">       String body = JsonUtils.bean2Json(iotPacketRequest);</span><br><span class=\"line\">       <span class=\"keyword\">byte</span>[] bodyBytes = body.getBytes(Charset.forName(<span class=\"string\">\"utf-8\"</span>));</span><br><span class=\"line\">       out.writeShort(IotConnectProperties.MAGIC_CODE);</span><br><span class=\"line\">       out.writeShort(bodyBytes.length);</span><br><span class=\"line\">       out.writeBytes(bodyBytes);</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"服务端启动分析\"><a href=\"#服务端启动分析\" class=\"headerlink\" title=\"服务端启动分析\"></a>服务端启动分析</h3><p>以创建一个Netty服务端为例</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">NettyServer</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">bind</span><span class=\"params\">(<span class=\"keyword\">int</span> port)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 创建EventLoopGroup</span></span><br><span class=\"line\">        EventLoopGroup bossGroup = <span class=\"keyword\">new</span> NioEventLoopGroup();</span><br><span class=\"line\">        EventLoopGroup workerGroup = <span class=\"keyword\">new</span> NioEventLoopGroup();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 创建ServerBootStrap实例</span></span><br><span class=\"line\">            <span class=\"comment\">// ServerBootstrap 用于启动NIO服务端的辅助启动类，目的是降低服务端的开发复杂度</span></span><br><span class=\"line\">            ServerBootstrap b = <span class=\"keyword\">new</span> ServerBootstrap();</span><br><span class=\"line\">            <span class=\"comment\">// 绑定Reactor线程池</span></span><br><span class=\"line\">            b.group(bossGroup, workerGroup)</span><br><span class=\"line\">                    <span class=\"comment\">// 设置并绑定服务端Channel</span></span><br><span class=\"line\">                    <span class=\"comment\">// 指定所使用的NIO传输的Channel</span></span><br><span class=\"line\">                    .channel(NioServerSocketChannel.class)</span><br><span class=\"line\">                    .option(ChannelOption.SO_BACKLOG, <span class=\"number\">1024</span>)</span><br><span class=\"line\">                    .handler(<span class=\"keyword\">new</span> LoggingServerHandler())</span><br><span class=\"line\">                    .childHandler(<span class=\"keyword\">new</span> ChannelInitializer()&#123;</span><br><span class=\"line\">                        <span class=\"meta\">@Override</span></span><br><span class=\"line\">                        <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">initChannel</span><span class=\"params\">(Channel ch)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">                            ch.pipeline().addLast(<span class=\"string\">\"decoder\"</span>, <span class=\"keyword\">new</span> HttpRequestDecoder());</span><br><span class=\"line\">                            ch.pipeline().addLast(<span class=\"string\">\"encoder\"</span>, <span class=\"keyword\">new</span> HttpResponseEncoder());</span><br><span class=\"line\">                            ch.pipeline().addLast(<span class=\"string\">\"httpServerHandler\"</span>, <span class=\"keyword\">new</span> HttpServerHandler());</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// 绑定端口，同步等待成功</span></span><br><span class=\"line\">            ChannelFuture future = b.bind(port).sync();</span><br><span class=\"line\">            <span class=\"comment\">// 等待服务端监听端口关闭</span></span><br><span class=\"line\">            future.channel().closeFuture().sync();</span><br><span class=\"line\"></span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 优雅地关闭</span></span><br><span class=\"line\">            bossGroup.shutdownGracefully();</span><br><span class=\"line\">            workerGroup.shutdownGracefully();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>服务端的创建主要步骤为：</p>\n<ol>\n<li>创建 ServerBootstrap 实例</li>\n<li>设置并绑定 Reactor 线程池</li>\n<li>设置服务端 Channel</li>\n<li>添加并设置 ChannelHandler</li>\n<li>绑定并启动监听端口</li>\n</ol>\n<h4 id=\"创建EventLoopGroup\"><a href=\"#创建EventLoopGroup\" class=\"headerlink\" title=\"创建EventLoopGroup\"></a>创建EventLoopGroup</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">EventLoopGroup bossGroup = <span class=\"keyword\">new</span> NioEventLoopGroup();</span><br><span class=\"line\">EventLoopGroup workerGroup = <span class=\"keyword\">new</span> NioEventLoopGroup();</span><br></pre></td></tr></table></figure>\n\n<p>bossGroup 为 BOSS 线程组，用于服务端接受客户端的连接, workerGroup 为 worker 线程组，用于进行 SocketChannel 的网络读写。 </p>\n<h4 id=\"创建ServerBootstrap实例\"><a href=\"#创建ServerBootstrap实例\" class=\"headerlink\" title=\"创建ServerBootstrap实例\"></a><strong>创建ServerBootstrap实例</strong></h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ServerBootstrap b = <span class=\"keyword\">new</span> ServerBootstrap();</span><br></pre></td></tr></table></figure>\n\n<p>ServerBootStrap为Netty服务端的启动引导类，用于帮助用户快速配置、启动服务端服务。 客户端的引导类是Bootstrap。ServerBootStrap 提供了如下一些方法</p>\n<table>\n<thead>\n<tr>\n<th>方法名称</th>\n<th>方法描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>group</code></td>\n<td>设置 ServerBootstrap 要用的 EventLoopGroup</td>\n</tr>\n<tr>\n<td><code>channel</code></td>\n<td>设置将要被实例化的 ServerChannel 类</td>\n</tr>\n<tr>\n<td><code>option</code></td>\n<td>实例化的 ServerChannel 的配置项</td>\n</tr>\n<tr>\n<td><code>Handler</code></td>\n<td>设置并添加 Handler</td>\n</tr>\n<tr>\n<td><code>bind</code></td>\n<td>绑定 ServerChannel</td>\n</tr>\n</tbody></table>\n<h4 id=\"设置并绑定线程池\"><a href=\"#设置并绑定线程池\" class=\"headerlink\" title=\"设置并绑定线程池\"></a>设置并绑定线程池</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">b.group(bossGroup, workerGroup)</span><br></pre></td></tr></table></figure>\n\n<p>调用group()方法，为ServerBootstrap实例设置绑定reactor线程池</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> ServerBootstrap <span class=\"title\">group</span><span class=\"params\">(EventLoopGroup parentGroup, EventLoopGroup childGroup)</span> </span>&#123;</span><br><span class=\"line\">       <span class=\"keyword\">super</span>.group(parentGroup);        <span class=\"comment\">// 绑定boosGroup</span></span><br><span class=\"line\">       <span class=\"keyword\">if</span> (childGroup == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">           <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> NullPointerException(<span class=\"string\">\"childGroup\"</span>);</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">       <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.childGroup != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">           <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException(<span class=\"string\">\"childGroup set already\"</span>);</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">       <span class=\"keyword\">this</span>.childGroup = childGroup;    <span class=\"comment\">// 绑定workerGroup</span></span><br><span class=\"line\">       <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"设置服务端Channel\"><a href=\"#设置服务端Channel\" class=\"headerlink\" title=\"设置服务端Channel\"></a>设置服务端Channel</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.channel(NioServerSocketChannel.class)</span><br></pre></td></tr></table></figure>\n\n<p>调用channel()方法设置服务端Channel类型，注意这里参数是Class对象，Netty通过工厂类，利用反射来创建NioServerSocketChannel对象</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> B <span class=\"title\">channel</span><span class=\"params\">(Class&lt;? extends C&gt; channelClass)</span> </span>&#123;</span><br><span class=\"line\">       <span class=\"keyword\">if</span> (channelClass == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">           <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> NullPointerException(<span class=\"string\">\"channelClass\"</span>);</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">       <span class=\"keyword\">return</span> channelFactory(<span class=\"keyword\">new</span> ReflectiveChannelFactory&lt;C&gt;(channelClass));</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n\n<p>这里传递的是 ReflectiveChannelFactory，其源代码如下： </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ReflectiveChannelFactory</span>&lt;<span class=\"title\">T</span> <span class=\"keyword\">extends</span> <span class=\"title\">Channel</span>&gt; <span class=\"keyword\">implements</span> <span class=\"title\">ChannelFactory</span>&lt;<span class=\"title\">T</span>&gt; </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Class&lt;? extends T&gt; clazz;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ReflectiveChannelFactory</span><span class=\"params\">(Class&lt;? extends T&gt; clazz)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (clazz == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> NullPointerException(<span class=\"string\">\"clazz\"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.clazz = clazz;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//需要创建 channel 的时候，该方法将被调用</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> T <span class=\"title\">newChannel</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 反射创建对应 channel</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> clazz.newInstance();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Throwable t) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> ChannelException(<span class=\"string\">\"Unable to create Channel from class \"</span> + clazz, t);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">toString</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> StringUtil.simpleClassName(clazz) + <span class=\"string\">\".class\"</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"添加并设置ChannelHandler\"><a href=\"#添加并设置ChannelHandler\" class=\"headerlink\" title=\"添加并设置ChannelHandler\"></a>添加并设置ChannelHandler</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">\t.handler(<span class=\"keyword\">new</span> LoggingServerHandler())</span><br><span class=\"line\">.childHandler(<span class=\"keyword\">new</span> ChannelInitializer()&#123;</span><br><span class=\"line\">\t<span class=\"meta\">@Override</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">initChannel</span><span class=\"params\">(Channel ch)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">\t\tch.pipeline().addLast(<span class=\"string\">\"decoder\"</span>, <span class=\"keyword\">new</span> HttpRequestDecoder());</span><br><span class=\"line\">\t\tch.pipeline().addLast(<span class=\"string\">\"encoder\"</span>, <span class=\"keyword\">new</span> HttpResponseEncoder());</span><br><span class=\"line\">\t\tch.pipeline().addLast(<span class=\"string\">\"httpServerHandler\"</span>, <span class=\"keyword\">new</span> HttpServerHandler());</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p><code>handler()</code>设置的 Handler 是服务端 NioServerSocketChannel的，childHandler()`设置的 Handler 是属于每一个新建的 NioSocketChannel 的</p>\n<h4 id=\"绑定端口，启动服务端\"><a href=\"#绑定端口，启动服务端\" class=\"headerlink\" title=\"绑定端口，启动服务端\"></a>绑定端口，启动服务端</h4><p>绑定端口并启动服务，如下： </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ChannelFuture future = b.bind(port).sync();</span><br></pre></td></tr></table></figure>\n\n<p>深入源码我们发现核心方法有两个<code>initAndRegister()</code>， <code>doBind0()</code></p>\n<h5 id=\"initAndRegister\"><a href=\"#initAndRegister\" class=\"headerlink\" title=\"initAndRegister()\"></a>initAndRegister()</h5><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> ChannelFuture <span class=\"title\">initAndRegister</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    Channel channel = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">    channel = channelFactory.newChannel();</span><br><span class=\"line\">    <span class=\"comment\">//...</span></span><br><span class=\"line\">    init(channel);</span><br><span class=\"line\">    <span class=\"comment\">//...</span></span><br><span class=\"line\">    ChannelFuture regFuture = config().group().register(channel);</span><br><span class=\"line\">    <span class=\"comment\">//...</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> regFuture;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>initAndRegister做了3件事：</p>\n<p>1.<strong>new一个Channel</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">channel = channelFactory.newChannel();</span><br></pre></td></tr></table></figure>\n\n<p>前面在ServerBootstrap实例设置服务端Channel时，设置了这个Channel的类型，这里就通过工厂类的方法生成NioServerSocketChannel对象。</p>\n<p>追溯NioServerSocketChannel的默认构造函数，我们可以发现在构造该实例时，设置了channel为非阻塞模式、SelectionKey.OP_ACCEPT事件、channelId 、NioMessageUnsafe(封装了用于数据传输操作的函数)、DefaultChannelPipeline和 NioServerSocketChannelConfig 属性。 </p>\n<p>2.<strong>init这个Channel</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">init</span><span class=\"params\">(Channel channel)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">         <span class=\"comment\">// 设置配置的option参数</span></span><br><span class=\"line\">        <span class=\"keyword\">final</span> Map&lt;ChannelOption&lt;?&gt;, Object&gt; options = options0();</span><br><span class=\"line\">        <span class=\"keyword\">synchronized</span> (options) &#123;</span><br><span class=\"line\">            channel.config().setOptions(options);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">final</span> Map&lt;AttributeKey&lt;?&gt;, Object&gt; attrs = attrs0();</span><br><span class=\"line\">        <span class=\"keyword\">synchronized</span> (attrs) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (Entry&lt;AttributeKey&lt;?&gt;, Object&gt; e: attrs.entrySet()) &#123;</span><br><span class=\"line\">                <span class=\"meta\">@SuppressWarnings</span>(<span class=\"string\">\"unchecked\"</span>)</span><br><span class=\"line\">                AttributeKey&lt;Object&gt; key = (AttributeKey&lt;Object&gt;) e.getKey();</span><br><span class=\"line\">                channel.attr(key).set(e.getValue());</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 获取绑定的pipeline</span></span><br><span class=\"line\">        ChannelPipeline p = channel.pipeline();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 准备child用到的4个part</span></span><br><span class=\"line\">        <span class=\"keyword\">final</span> EventLoopGroup currentChildGroup = childGroup;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> ChannelHandler currentChildHandler = childHandler;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> Entry&lt;ChannelOption&lt;?&gt;, Object&gt;[] currentChildOptions;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> Entry&lt;AttributeKey&lt;?&gt;, Object&gt;[] currentChildAttrs;</span><br><span class=\"line\">        <span class=\"keyword\">synchronized</span> (childOptions) &#123;</span><br><span class=\"line\">            currentChildOptions = childOptions.entrySet().toArray(newOptionArray(childOptions.size()));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">synchronized</span> (childAttrs) &#123;</span><br><span class=\"line\">            currentChildAttrs = childAttrs.entrySet().toArray(newAttrArray(childAttrs.size()));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 为NioServerSocketChannel的pipeline添加一个初始化Handler,</span></span><br><span class=\"line\">        <span class=\"comment\">// 当NioServerSocketChannel在EventLoop注册成功时，该handler的init方法将被调用</span></span><br><span class=\"line\">        p.addLast(<span class=\"keyword\">new</span> ChannelInitializer&lt;Channel&gt;() &#123;</span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">initChannel</span><span class=\"params\">(Channel ch)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">                <span class=\"keyword\">final</span> ChannelPipeline pipeline = ch.pipeline();</span><br><span class=\"line\">                ChannelHandler handler = config.handler();</span><br><span class=\"line\">                <span class=\"comment\">//如果用户配置过Handler</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (handler != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                    pipeline.addLast(handler);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                ch.eventLoop().execute(<span class=\"keyword\">new</span> Runnable() &#123;</span><br><span class=\"line\">                    <span class=\"meta\">@Override</span></span><br><span class=\"line\">                    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">                        <span class=\"comment\">// 为NioServerSocketChannel的pipeline添加ServerBootstrapAcceptor处理器</span></span><br><span class=\"line\">                        <span class=\"comment\">// 该Handler主要用来将新创建的NioSocketChannel注册到EventLoopGroup中</span></span><br><span class=\"line\">                        pipeline.addLast(<span class=\"keyword\">new</span> ServerBootstrapAcceptor(</span><br><span class=\"line\">                                currentChildGroup, currentChildHandler, currentChildOptions, currentChildAttrs));</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们发现init其实就做了三件事：</p>\n<ul>\n<li>设置options、attrs</li>\n<li>设置新接入Channel的options、attrs</li>\n<li>将用于服务端注册的 Handler ServerBootstrapAcceptor 添加到 ServerChannel的ChannelPipeline 中。ServerBootstrapAcceptor 为一个接入器，专门接受新请求。</li>\n</ul>\n<p>3.<strong>向EventLoopGroup中注册这个Channel</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ChannelFuture regFuture = config().group().register(channel);</span><br></pre></td></tr></table></figure>\n\n<p>通过追溯我们发现过程如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> ChannelFuture <span class=\"title\">register</span><span class=\"params\">(Channel channel)</span> </span>&#123;</span><br><span class=\"line\">       <span class=\"keyword\">return</span> next().register(channel);</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n\n<p>调用 <code>next()</code> 方法从 EventLoopGroup 中获取下一个 EventLoop，调用 <code>register()</code> 方法注册： </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> ChannelFuture <span class=\"title\">register</span><span class=\"params\">(Channel channel)</span> </span>&#123;</span><br><span class=\"line\">       <span class=\"keyword\">return</span> register(<span class=\"keyword\">new</span> DefaultChannelPromise(channel, <span class=\"keyword\">this</span>));</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n\n<p>将Channel和EventLoop封装成一个DefaultChannelPromise对象，然后调用register()方法。DefaultChannelPromis为ChannelPromise的默认实现，而ChannelPromisee继承Future，具备异步执行结构，绑定Channel，所以又具备了监听的能力，故而ChannelPromis是Netty异步执行的核心接口。 </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> ChannelFuture <span class=\"title\">register</span><span class=\"params\">(ChannelPromise promise)</span> </span>&#123;</span><br><span class=\"line\">       ObjectUtil.checkNotNull(promise, <span class=\"string\">\"promise\"</span>);</span><br><span class=\"line\">       promise.channel().unsafe().register(<span class=\"keyword\">this</span>, promise);</span><br><span class=\"line\">       <span class=\"keyword\">return</span> promise;</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n\n<p>unsafe就是我们之前构造NioServerSocketChannel时new的对象，这里调用register方法过程如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">register</span><span class=\"params\">(EventLoop eventLoop, <span class=\"keyword\">final</span> ChannelPromise promise)</span> </span>&#123;</span><br><span class=\"line\">          <span class=\"keyword\">if</span> (eventLoop == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">              <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> NullPointerException(<span class=\"string\">\"eventLoop\"</span>);</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">          <span class=\"keyword\">if</span> (isRegistered()) &#123;</span><br><span class=\"line\">              promise.setFailure(<span class=\"keyword\">new</span> IllegalStateException(<span class=\"string\">\"registered to an event loop already\"</span>));</span><br><span class=\"line\">              <span class=\"keyword\">return</span>;</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">          <span class=\"keyword\">if</span> (!isCompatible(eventLoop)) &#123;</span><br><span class=\"line\">              promise.setFailure(</span><br><span class=\"line\">                      <span class=\"keyword\">new</span> IllegalStateException(<span class=\"string\">\"incompatible event loop type: \"</span> + eventLoop.getClass().getName()));</span><br><span class=\"line\">              <span class=\"keyword\">return</span>;</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">          AbstractChannel.<span class=\"keyword\">this</span>.eventLoop = eventLoop;</span><br><span class=\"line\"></span><br><span class=\"line\">          <span class=\"comment\">// 必须要保证注册是由该EventLoop发起的</span></span><br><span class=\"line\">          <span class=\"keyword\">if</span> (eventLoop.inEventLoop()) &#123;</span><br><span class=\"line\">              register0(promise);        <span class=\"comment\">// 注册</span></span><br><span class=\"line\">          &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">              <span class=\"comment\">// 如果不是单独封装成一个task异步执行</span></span><br><span class=\"line\">              <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                  eventLoop.execute(<span class=\"keyword\">new</span> Runnable() &#123;</span><br><span class=\"line\">                      <span class=\"meta\">@Override</span></span><br><span class=\"line\">                      <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">                          register0(promise);</span><br><span class=\"line\">                      &#125;</span><br><span class=\"line\">                  &#125;);</span><br><span class=\"line\">              &#125; <span class=\"keyword\">catch</span> (Throwable t) &#123;</span><br><span class=\"line\">                  logger.warn(</span><br><span class=\"line\">                          <span class=\"string\">\"Force-closing a channel whose registration task was not accepted by an event loop: &#123;&#125;\"</span>,</span><br><span class=\"line\">                          AbstractChannel.<span class=\"keyword\">this</span>, t);</span><br><span class=\"line\">                  closeForcibly();</span><br><span class=\"line\">                  closeFuture.setClosed();</span><br><span class=\"line\">                  safeSetFailure(promise, t);</span><br><span class=\"line\">              &#125;</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">      &#125;</span><br></pre></td></tr></table></figure>\n\n<p>首先通过<code>isRegistered()</code> 判断该 Channel 是否已经注册到 EventLoop 中；  </p>\n<p>通过 <code>eventLoop.inEventLoop()</code> 来判断当前线程是否为该 EventLoop 自身发起的，如果是，则调用 <code>register0()</code> 直接注册;</p>\n<p>如果不是，说明该 EventLoop 中的线程此时没有执行权，则需要新建一个线程，单独封装一个 Task，而该 Task 的主要任务则是执行<code>register0()</code>。 </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">register0</span><span class=\"params\">(ChannelPromise promise)</span> </span>&#123;</span><br><span class=\"line\">          <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">              <span class=\"comment\">// 确保 Channel 处于 open</span></span><br><span class=\"line\">              <span class=\"keyword\">if</span> (!promise.setUncancellable() || !ensureOpen(promise)) &#123;</span><br><span class=\"line\">                  <span class=\"keyword\">return</span>;</span><br><span class=\"line\">              &#125;</span><br><span class=\"line\">              <span class=\"keyword\">boolean</span> firstRegistration = neverRegistered;</span><br><span class=\"line\"></span><br><span class=\"line\">              <span class=\"comment\">// 真正的注册动作</span></span><br><span class=\"line\">              doRegister();</span><br><span class=\"line\"></span><br><span class=\"line\">              neverRegistered = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">              registered = <span class=\"keyword\">true</span>;        </span><br><span class=\"line\"></span><br><span class=\"line\">              pipeline.invokeHandlerAddedIfNeeded();    </span><br><span class=\"line\">              safeSetSuccess(promise);        <span class=\"comment\">//设置注册结果为成功</span></span><br><span class=\"line\"></span><br><span class=\"line\">              pipeline.fireChannelRegistered();</span><br><span class=\"line\"></span><br><span class=\"line\">              <span class=\"keyword\">if</span> (isActive()) &#123; </span><br><span class=\"line\">                  <span class=\"comment\">//如果是首次注册,发起 pipeline 的 fireChannelActive</span></span><br><span class=\"line\">                  <span class=\"keyword\">if</span> (firstRegistration) &#123;</span><br><span class=\"line\">                      pipeline.fireChannelActive();</span><br><span class=\"line\">                  &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (config().isAutoRead()) &#123;</span><br><span class=\"line\">                      beginRead();</span><br><span class=\"line\">                  &#125;</span><br><span class=\"line\">              &#125;</span><br><span class=\"line\">          &#125; <span class=\"keyword\">catch</span> (Throwable t) &#123;</span><br><span class=\"line\">              closeForcibly();</span><br><span class=\"line\">              closeFuture.setClosed();</span><br><span class=\"line\">              safeSetFailure(promise, t);</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">      &#125;</span><br></pre></td></tr></table></figure>\n\n<p>如果 Channel 处于 open 状态，则调用 <code>doRegister()</code> 方法完成注册，然后将注册结果设置为成功。最后判断如果是首次注册且处于激活状态，则发起 pipeline 的 <code>fireChannelActive()</code>。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">doRegister</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">       <span class=\"keyword\">boolean</span> selected = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">       <span class=\"keyword\">for</span> (;;) &#123;</span><br><span class=\"line\">           <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">               <span class=\"comment\">// 注册到NIOEventLoop的Selector上</span></span><br><span class=\"line\">               selectionKey = javaChannel().register(eventLoop().selector, <span class=\"number\">0</span>, <span class=\"keyword\">this</span>);</span><br><span class=\"line\">               <span class=\"keyword\">return</span>;</span><br><span class=\"line\">           &#125; <span class=\"keyword\">catch</span> (CancelledKeyException e) &#123;</span><br><span class=\"line\">               <span class=\"keyword\">if</span> (!selected) &#123;</span><br><span class=\"line\">                   eventLoop().selectNow();</span><br><span class=\"line\">                   selected = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">               &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                   <span class=\"keyword\">throw</span> e;</span><br><span class=\"line\">               &#125;</span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n\n<p>因为当前没有将一个ServerSocket绑定到一个address</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (isActive()) &#123; </span><br><span class=\"line\">\t<span class=\"comment\">//如果是首次注册,发起 pipeline 的 fireChannelActive</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (firstRegistration) &#123;</span><br><span class=\"line\">\t\tpipeline.fireChannelActive();</span><br><span class=\"line\">\t&#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (config().isAutoRead()) &#123;</span><br><span class=\"line\">\t\tbeginRead();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isActive</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">       <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.javaChannel().socket().isBound();</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">doBeginRead</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">       SelectionKey selectionKey = <span class=\"keyword\">this</span>.selectionKey;</span><br><span class=\"line\">       <span class=\"keyword\">if</span> (selectionKey.isValid()) &#123;</span><br><span class=\"line\">           <span class=\"keyword\">this</span>.readPending = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">           <span class=\"keyword\">int</span> interestOps = selectionKey.interestOps();</span><br><span class=\"line\">           <span class=\"keyword\">if</span> ((interestOps &amp; <span class=\"keyword\">this</span>.readInterestOp) == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">               selectionKey.interestOps(interestOps | <span class=\"keyword\">this</span>.readInterestOp);</span><br><span class=\"line\">           &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n\n<p>这里将selectionKey的监听操作设置为之前构造NioServerSocketChannel设置的SelectionKey.OP_ACCEPT</p>\n<h5 id=\"he-doBind0\"><a href=\"#he-doBind0\" class=\"headerlink\" title=\"he doBind0()\"></a>he doBind0()</h5><p>追溯doBind0()的实现，我们可以发现会调用初始化时NioMessageUnsafe的bind方法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">bind</span><span class=\"params\">(<span class=\"keyword\">final</span> SocketAddress localAddress, <span class=\"keyword\">final</span> ChannelPromise promise)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">    <span class=\"keyword\">boolean</span> wasActive = isActive();</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">    doBind(localAddress);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!wasActive &amp;&amp; isActive()) &#123;</span><br><span class=\"line\">        invokeLater(<span class=\"keyword\">new</span> Runnable() &#123;</span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">                pipeline.fireChannelActive();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    safeSetSuccess(promise);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>doBind(localAddress) 调用JDK的代码，实现了端口绑定</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">protected void doBind(SocketAddress localAddress) throws Exception &#123;</span><br><span class=\"line\">    if (PlatformDependent.javaVersion() &gt;= 7) &#123;</span><br><span class=\"line\">        //noinspection Since15</span><br><span class=\"line\">        javaChannel().bind(localAddress, config.getBacklog());</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">        javaChannel().socket().bind(localAddress, config.getBacklog());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>绑定后isActice()返回true，fireChannelActive() 被调用。</p>\n<h2 id=\"4-内存管理\"><a href=\"#4-内存管理\" class=\"headerlink\" title=\"4 内存管理\"></a>4 内存管理</h2><h3 id=\"4-1-ByteBuffer、ByteBuf\"><a href=\"#4-1-ByteBuffer、ByteBuf\" class=\"headerlink\" title=\"4.1 ByteBuffer、ByteBuf\"></a>4.1 ByteBuffer、ByteBuf</h3><p>为了减少频繁I/O操作，引进了Buffer的概念，把突发的大数量较小规模的 I/O 整理成平稳的小数量较大规模的 I/O 。Java NIO封装了ByteBuffer组件。ByteBuffer具有4个重要的属性：mark、position、limit、capacity ，以及两个重要的方法clear()、flip()</p>\n<ol>\n<li>position:读写指针，代表当前读或写操作的位置，这个值总是小于等于limit的。</li>\n<li>mark：在使用ByteBuffer的过程中，如果想要记住当前的position，则会将当前的position值给mark，需要恢复的时候，再将mark的值给position。</li>\n<li>capacity：代表这块内存区域的大小。</li>\n<li>limit：初始的Buffer中，limit和capacity的值是相等的，通常在clear操作和flip操作的时候会对这个值进行操作，在clear操作的时候会将这个值和capacity的值设置为相等，当flip的时候会将当前的position的值给limit，我们可以总结在写的时候，limit的值代表最大的可写位置，在读的时候，limit的值代表最大的可读位置。</li>\n</ol>\n<p><img src=\"/png/netty/ByteBuffer.png\" alt></p>\n<p>在写操作之前调用clear()</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> Buffer <span class=\"title\">clear</span><span class=\"params\">()</span> </span>&#123; </span><br><span class=\"line\">\tposition = <span class=\"number\">0</span>; <span class=\"comment\">//设置当前下标为0</span></span><br><span class=\"line\">\tlimit = capacity; <span class=\"comment\">//设置写越界位置与和Buffer容量相同</span></span><br><span class=\"line\">\tmark = -<span class=\"number\">1</span>; <span class=\"comment\">//取消标记</span></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"keyword\">this</span>; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在读操作之前调用flip()</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> Buffer <span class=\"title\">flip</span><span class=\"params\">()</span> </span>&#123; </span><br><span class=\"line\">\tlimit = position; </span><br><span class=\"line\">\tposition = <span class=\"number\">0</span>; </span><br><span class=\"line\">\tmark = -<span class=\"number\">1</span>; </span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"keyword\">this</span>; </span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n\n<p>ByteBuffer具有以下缺陷</p>\n<ul>\n<li>ByteBuffer长度固定，一旦分配完成，它的容量不能动态扩展和收缩，当需要编码的POJO对象大于ByteBuffer的容量时，会发生索引越界异常；</li>\n<li>ByteBuffer只有一个标识位控的指针position，读写的时候需要手工调用 flip() 和 clear() 等；</li>\n<li>ByteBuffer的API功能有限，一些高级和实用的特性它不支持，需要使用者自己编程实现。</li>\n</ul>\n<p>Netty为了解决ByteBuffer的缺陷，重写了一个新的数据接口ByteBuf。 与ByteBuffer相比，ByteBuf提供了两个指针 readerIndex 和 writeIndex 来分别指向读的位置和写的位置，不需要每次为读写做准备，直接设置读写指针进行读写操作即可。 </p>\n<p><img src=\"/png/netty/%E8%AF%BB%E5%86%99%E4%B8%AD%E9%97%B4%E7%8A%B6%E6%80%81%E7%9A%84Buffer.png\" alt></p>\n<p>这是中间状态的Buffer，可以通过调用discardReadBytes方法来回收已读区域</p>\n<p><img src=\"/png/netty/discardReadBytes.png\" alt></p>\n<p>通过clear方法清楚指针状态</p>\n<p><img src=\"/png/netty/clear%E5%90%8E%E7%9A%84Buffer.png\" alt></p>\n<p>对比ByteBuffer，使用ByteBuf读的时候仅仅依赖readerIndex指针，写的时候仅仅依赖writerIndex指针，不需每次读写之前调用对应的方法，而且没有必须一次读完的限制。 </p>\n<h3 id=\"4-2-内存管理\"><a href=\"#4-2-内存管理\" class=\"headerlink\" title=\"4.2 内存管理\"></a>4.2 内存管理</h3><h4 id=\"4-2-1-零拷贝\"><a href=\"#4-2-1-零拷贝\" class=\"headerlink\" title=\"4.2.1 零拷贝\"></a>4.2.1 零拷贝</h4><p>当JVM堆内存上的数据需要和IO设备进行I/O操作时，会将JVM堆上所维护的byte[]拷贝至堆外内存（一般是通过C/C++分配的内存），然后堆外内存直接和IO设备交互。这是因为<strong>JVM需要进行GC，如果IO设备直接和JVM堆上的数据进行交互，这个时候JVM进行了GC，那么有可能会导致没有被回收的数据进行了压缩，位置被移动到了连续的存储区域，这样会导致正在进行的IO操作相关的数据全部乱套</strong>。</p>\n<p>NIO可以使用native 函数库直接分配堆外内存，然后通过一个存储在堆上的DirectByteBuffer 对象作为这块内存的引用进行操作，避免了在Java堆和Native堆中来回复制数据。 </p>\n<h4 id=\"4-2-2-内存泄漏\"><a href=\"#4-2-2-内存泄漏\" class=\"headerlink\" title=\"4.2.2 内存泄漏\"></a>4.2.2 内存泄漏</h4><p>从堆中分配的缓冲区HeapByteBuffer为普通的Java对象，生命周期与普通的Java对象一样，当不再被引用时，Buffer对象会被回收。而直接缓冲区（DirectByteBuffer）为堆外内存，并不在Java堆中，也不能被JVM垃圾回收。由于直接缓冲区在JVM里被包装进Java对象DirectByteBuffer中，当它的包装类被垃圾回收时，会调用相应的JNI方法释放堆外内存，所以堆外内存的释放也依赖于JVM中DirectByteBuffer对象的回收。</p>\n<p>由于垃圾回收本身成本较高，一般JVM在堆内存未耗尽时，不会进行垃圾回收操作。如果不断分配本地内存，堆内存很少使用，那么JVM就不需要执行GC，DirectByteBuffer对象们就不会被回收，这时候堆内存充足，但本地内存可能已经使用光了，再次尝试分配本地内存就会出现OutOfMemoryError，那程序就直接崩溃了。</p>\n<h4 id=\"4-2-3-ByteBuf引用计数\"><a href=\"#4-2-3-ByteBuf引用计数\" class=\"headerlink\" title=\"4.2.3 ByteBuf引用计数\"></a>4.2.3 ByteBuf引用计数</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">ReferenceCounted</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">refCnt</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\">ReferenceCounted <span class=\"title\">retain</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\">ReferenceCounted <span class=\"title\">retain</span><span class=\"params\">(<span class=\"keyword\">int</span> var1)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\">ReferenceCounted <span class=\"title\">touch</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\">ReferenceCounted <span class=\"title\">touch</span><span class=\"params\">(Object var1)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">release</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">release</span><span class=\"params\">(<span class=\"keyword\">int</span> var1)</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>ByteBuf扩展了ReferenceCountered接口 ，这个接口定义的功能主要是引用计数。</p>\n<p>当 ByteBuf 引用+1的时候，需要调用 retain() 来让refCnt + 1，当Buffer引用数-1的时候需要调用 release() 来让 refCnt - 1。当refCnt变为0的时候Netty为pooled和unpooled的不同buffer提供了不同的实现，通常对于非内存池的用法，Netty把Buffer的内存回收交给了垃圾回收器，对于内存池的用法，Netty对内存的回收实际上是回收到内存池内，以提供下一次的申请所使用。</p>\n<h4 id=\"4-2-4-池化\"><a href=\"#4-2-4-池化\" class=\"headerlink\" title=\"4.2.4 池化\"></a>4.2.4 池化</h4><p>如果对于Buffer的使用都基于直接内存实现的话，将会大大提高I/O效率，然而直接内存空间的申请比堆内存要消耗更高的性能。</p>\n<p>因此Netty结合引用计数实现了PolledBuffer，即池化的用法，当引用计数等于0的时候，Netty将Buffer回收至池中，在下一次申请Buffer的时刻会被复用。 </p>\n<p>堆内存和直接内存的池化实现分别是PooledHeapByteBuf和PooledDirectByteBuf，在各自的实现中都维护着一个Recycler 。Recycler是一个抽象类，向外部提供了两个公共方法get和recycle分别用于从对象池中获取对象和回收对象。</p>\n<p>以PooledHeapByteBuf为例，新建PooledHeapByteBuf对象时</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> PooledHeapByteBuf <span class=\"title\">newInstance</span><span class=\"params\">(<span class=\"keyword\">int</span> maxCapacity)</span> </span>&#123;</span><br><span class=\"line\">       PooledHeapByteBuf buf = (PooledHeapByteBuf)RECYCLER.get();</span><br><span class=\"line\">       buf.reuse(maxCapacity);</span><br><span class=\"line\">       <span class=\"keyword\">return</span> buf;</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n\n<p>当Buffer引用数 -1时</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">release</span><span class=\"params\">(<span class=\"keyword\">int</span> decrement)</span> </span>&#123;</span><br><span class=\"line\">       <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.release0(ObjectUtil.checkPositive(decrement, <span class=\"string\">\"decrement\"</span>));</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> <span class=\"title\">release0</span><span class=\"params\">(<span class=\"keyword\">int</span> decrement)</span> </span>&#123;</span><br><span class=\"line\">       <span class=\"keyword\">int</span> oldRef = refCntUpdater.getAndAdd(<span class=\"keyword\">this</span>, -decrement);</span><br><span class=\"line\">       <span class=\"keyword\">if</span> (oldRef == decrement) &#123;</span><br><span class=\"line\">           <span class=\"keyword\">this</span>.deallocate();</span><br><span class=\"line\">           <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">       &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (oldRef &gt;= decrement &amp;&amp; oldRef - decrement &lt;= oldRef) &#123;</span><br><span class=\"line\">           <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">       &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">           refCntUpdater.getAndAdd(<span class=\"keyword\">this</span>, decrement);</span><br><span class=\"line\">           <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalReferenceCountException(oldRef, -decrement);</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n\n<p>PooledByteBuf.class</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">deallocate</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.handle &gt;= <span class=\"number\">0L</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">long</span> handle = <span class=\"keyword\">this</span>.handle;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.handle = -<span class=\"number\">1L</span>;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.memory = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.tmpNioBuf = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.chunk.arena.free(<span class=\"keyword\">this</span>.chunk, handle, <span class=\"keyword\">this</span>.maxLength, <span class=\"keyword\">this</span>.cache);</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.chunk = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.recycle();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">recycle</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.recyclerHandle.recycle(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"4-3-半包读写\"><a href=\"#4-3-半包读写\" class=\"headerlink\" title=\"4.3 半包读写\"></a>4.3 半包读写</h3><p>TCP是个”流”协议，所谓流，就是没有界限没有分割的一串数据。TCP会根据缓冲区的实际情况进行包划分，一个完整的包可能会拆分成多个包进行发送，也用可能把多个小包封装成一个大的数据包发送。这就是TCP粘包/拆包。</p>\n<p>举个例子：假设操作系统已经接收到了三个包，如下：</p>\n<p><img src=\"/png/netty/%E6%B5%81-%E6%8B%86%E5%8C%85.png\" alt></p>\n<p>由于流传输的这个普通属性，在读取他们的时候将会存在很大的几率，这些数据会被分段成下面的几部分：</p>\n<p><img src=\"/png/netty/%E6%B5%81-%E7%B2%98%E5%8C%85.png\" alt></p>\n<p>也就是读取的数据有可能超过一个完整的数据包或者过多或者过少的半包。</p>\n<p>因此，作为一个接收方，不管它是服务端还是客户端，都需要把接收到的数据整理成一个或多个有意义的并且能够被应用程序容易理解的数据。</p>\n<p><strong>拆包方案：</strong></p>\n<ul>\n<li><strong>消息定长</strong>，固定报文长度，不够空格补全，发送和接收方遵循相同的约定，这样即使粘包了通过接收方编程实现获取定长报文也能区分。</li>\n<li><strong>包尾添加特殊分隔符</strong>，例如每条报文结束都添加回车换行符（例如FTP协议）或者指定特殊字符作为报文分隔符，接收方通过特殊分隔符切分报文区分。</li>\n<li><strong>将消息分为消息头和消息体</strong>，消息头中包含表示信息的总长度（或者消息体长度）的字段</li>\n</ul>\n<p><strong>Netty提供了几种解码器：</strong></p>\n<ul>\n<li>定长解码器：FixedLengthFrameDecoder</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ch.pipeline().addLast(new FixedLengthFrameDecoder(30));//设置定长解码器</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>特殊分隔符解码器：DelimiterBasedFrameDecoder</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ByteBuf delimiter = Unpooled.copiedBuffer(&quot;&amp;&quot;.getBytes());</span><br><span class=\"line\">//1024表示单条消息的最大长度，解码器在查找分隔符的时候，达到该长度还没找到的话会抛异常</span><br><span class=\"line\">ch.pipeline().addLast(new DelimiterBasedFrameDecoder(1024,delimiter));</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>基于包头不固定长度的解码器：LengthFieldBasedFrameDecoder</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * maxFrameLength：解码的帧的最大长度</span></span><br><span class=\"line\"><span class=\"comment\"> * lengthFieldOffset：长度属性的起始位（偏移位），包中存放有整个大数据包长度的字节，这段字节的其实位置</span></span><br><span class=\"line\"><span class=\"comment\"> * lengthFieldLength：长度属性的长度，即存放整个大数据包长度的字节所占的长度</span></span><br><span class=\"line\"><span class=\"comment\"> * lengthAdjustmen：长度调节值，在总长被定义为包含包头长度时，修正信息长度。</span></span><br><span class=\"line\"><span class=\"comment\"> * initialBytesToStrip：跳过的字节数，根据需要我们跳过lengthFieldLength个字节，以便接收端直接接受到不</span></span><br><span class=\"line\"><span class=\"comment\">                        含“长度属性”的内容</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">ch.pipeline().addLast(<span class=\"string\">\"decoder\"</span>, <span class=\"keyword\">new</span> LengthFieldBasedFrameDecoder(MAX_FRAME_LENGTH, LENGTH_OFFSET, </span><br><span class=\"line\">                                    LENGTH_LEN, LENGTH_ADJUGEMENT, INIT_BYTE_TO_STRIP));</span><br></pre></td></tr></table></figure>\n\n<p><strong>参考资料</strong></p>\n<table>\n<thead>\n<tr>\n<th>资料名称</th>\n<th>来源</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>《Netty实战》</td>\n<td>图书</td>\n</tr>\n<tr>\n<td>《Netty权威指南》</td>\n<td>图书</td>\n</tr>\n<tr>\n<td>Netty官网wiki</td>\n<td><a href=\"https://netty.io/wiki/related-articles.html\" target=\"_blank\" rel=\"noopener\">https://netty.io/wiki/related-articles.html</a></td>\n</tr>\n<tr>\n<td>其他互联网资料链接</td>\n<td>见最后</td>\n</tr>\n</tbody></table>\n<p><strong>参考链接：</strong></p>\n<p><a href=\"https://netty.io/index.html\" target=\"_blank\" rel=\"noopener\">https://netty.io/index.html</a><br><a href=\"https://blog.csdn.net/syc001/article/details/72841945\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/syc001/article/details/72841945</a><br><a href=\"http://ifeve.com/%E8%B0%88%E8%B0%88netty%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/\" target=\"_blank\" rel=\"noopener\">http://ifeve.com/%E8%B0%88%E8%B0%88netty%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/</a><br><a href=\"https://www.cnblogs.com/wxd0108/p/6681627.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/wxd0108/p/6681627.html</a><br><a href=\"https://my.oschina.net/plucury/blog/192577\" target=\"_blank\" rel=\"noopener\">https://my.oschina.net/plucury/blog/192577</a><br><a href=\"https://blog.csdn.net/chenssy/article/details/78714003\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/chenssy/article/details/78714003</a></p>"}],"PostAsset":[],"PostCategory":[],"PostTag":[{"post_id":"ck0e0icq800028wudm3q01bqn","tag_id":"ck0e0icqe00038wudyabfi8zs","_id":"ck0e0icqg00048wud3pqc44w8"},{"post_id":"ck0e0icv100058wudqj6z5jxa","tag_id":"ck0e0icv300068wudr3el7zy1","_id":"ck0e0icv300078wudiy0prcft"}],"Tag":[{"name":"NIO","_id":"ck0e0icqe00038wudyabfi8zs"},{"name":"Netty","_id":"ck0e0icv300068wudr3el7zy1"}]}}